import{_ as p,e as t,k as c,f as a,g as e,i,h as l,r as d,o as r}from"./app-CY03Lsxp.js";const v={};function u(m,n){const s=d("RouteLink");return r(),t("div",null,[n[3]||(n[3]=c('<h1 id="函数" tabindex="-1"><a class="header-anchor" href="#函数"><span>函数</span></a></h1><p>同样的规则也适用于函数：在使用类型 <code>T</code> 前给出 <code>&lt;T&gt;</code>，那么 <code>T</code> 就变成了泛型。</p><p>调用泛型函数有时需要显式地指明类型参量。这可能是因为调用了返回类型是泛型的函数，或者编译器没有足够的信息来推断类型参数。</p><p>调用函数时，使用显式指定的类型参数会像是这样：<code>fun::&lt;A, B, ...&gt;()</code>。</p><div class="language-rust,editable line-numbers-mode" data-highlighter="shiki" data-ext="rust,editable" data-title="rust,editable" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>struct A;          // 具体类型 `A`。</span></span>\n<span class="line"><span>struct S(A);       // 具体类型 `S`。</span></span>\n<span class="line"><span>struct SGen&lt;T&gt;(T); // 泛型类型 `SGen`。</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>// 下面全部函数都得到了变量的所有权，并立即使之离开作用域，将变量释放。</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>// 定义一个函数 `reg_fn`，接受一个 `S` 类型的参数 `_s`。</span></span>\n<span class="line"><span>// 因为没有 `&lt;T&gt;` 这样的泛型类型参数，所以这不是泛型函数。</span></span>\n<span class="line"><span>fn reg_fn(_s: S) {}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>// 定义一个函数 `gen_spec_t`，接受一个 `SGen&lt;A&gt;` 类型的参数 `_s`。</span></span>\n<span class="line"><span>// `SGen&lt;&gt;` 显式地接受了类型参数 `A`，且在 `gen_spec_t` 中，`A` 没有被用作</span></span>\n<span class="line"><span>// 泛型类型参数，所以函数不是泛型的。</span></span>\n<span class="line"><span>fn gen_spec_t(_s: SGen&lt;A&gt;) {}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>// 定义一个函数 `gen_spec_i32`，接受一个 `SGen&lt;i32&gt;` 类型的参数 `_s`。</span></span>\n<span class="line"><span>// `SGen&lt;&gt;` 显式地接受了类型参量 `i32`，而 `i32` 是一个具体类型。</span></span>\n<span class="line"><span>// 由于 `i32` 不是一个泛型类型，所以这个函数也不是泛型的。</span></span>\n<span class="line"><span>fn gen_spec_i32(_s: SGen&lt;i32&gt;) {}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>// 定义一个函数 `generic`，接受一个 `SGen&lt;T&gt;` 类型的参数 `_s`。</span></span>\n<span class="line"><span>// 因为 `SGen&lt;T&gt;` 之前有 `&lt;T&gt;`，所以这个函数是关于 `T` 的泛型函数。</span></span>\n<span class="line"><span>fn generic&lt;T&gt;(_s: SGen&lt;T&gt;) {}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>fn main() {</span></span>\n<span class="line"><span>    // 使用非泛型函数</span></span>\n<span class="line"><span>    reg_fn(S(A));          // 具体类型。</span></span>\n<span class="line"><span>    gen_spec_t(SGen(A));   // 隐式地指定类型参数 `A`。</span></span>\n<span class="line"><span>    gen_spec_i32(SGen(6)); // 隐式地指定类型参数 `i32`。</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    // 为 `generic()` 显式地指定类型参数 `char`。</span></span>\n<span class="line"><span>    generic::&lt;char&gt;(SGen(&#39;a&#39;));</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    // 为 `generic()` 隐式地指定类型参数 `char`。</span></span>\n<span class="line"><span>    generic(SGen(&#39;c&#39;));</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="参见" tabindex="-1"><a class="header-anchor" href="#参见"><span>参见：</span></a></h3>',6)),a("p",null,[e(s,{to:"/fn.html"},{default:l(()=>n[0]||(n[0]=[i("函数")])),_:1}),n[2]||(n[2]=i(" 和 ")),e(s,{to:"/custom_types/structs.html"},{default:l(()=>n[1]||(n[1]=[a("code",null,"structs",-1)])),_:1})])])}const o=p(v,[["render",u],["__file","gen_fn.html.vue"]]),b=JSON.parse('{"path":"/generics/gen_fn.html","title":"函数","lang":"zh-CN","frontmatter":{"description":"函数 同样的规则也适用于函数：在使用类型 T 前给出 <T>，那么 T 就变成了泛型。 调用泛型函数有时需要显式地指明类型参量。这可能是因为调用了返回类型是泛型的函数，或者编译器没有足够的信息来推断类型参数。 调用函数时，使用显式指定的类型参数会像是这样：fun::<A, B, ...>()。 参见： 和","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/rust-by-example-cn/generics/gen_fn.html"}],["meta",{"property":"og:site_name","content":"rust-by-example-cn"}],["meta",{"property":"og:title","content":"函数"}],["meta",{"property":"og:description","content":"函数 同样的规则也适用于函数：在使用类型 T 前给出 <T>，那么 T 就变成了泛型。 调用泛型函数有时需要显式地指明类型参量。这可能是因为调用了返回类型是泛型的函数，或者编译器没有足够的信息来推断类型参数。 调用函数时，使用显式指定的类型参数会像是这样：fun::<A, B, ...>()。 参见： 和"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"函数\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/rust-by-example-cn/\\"}]}"]]},"git":{},"readingTime":{"minutes":1.66,"words":498},"filePathRelative":"generics/gen_fn.md","excerpt":"\\n<p>同样的规则也适用于函数：在使用类型 <code>T</code> 前给出 <code>&lt;T&gt;</code>，那么 <code>T</code> 就变成了泛型。</p>\\n<p>调用泛型函数有时需要显式地指明类型参量。这可能是因为调用了返回类型是泛型的函数，或者编译器没有足够的信息来推断类型参数。</p>\\n<p>调用函数时，使用显式指定的类型参数会像是这样：<code>fun::&lt;A, B, ...&gt;()</code>。</p>\\n<div class=\\"language-rust,editable line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"rust,editable\\" data-title=\\"rust,editable\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>struct A;          // 具体类型 `A`。</span></span>\\n<span class=\\"line\\"><span>struct S(A);       // 具体类型 `S`。</span></span>\\n<span class=\\"line\\"><span>struct SGen&lt;T&gt;(T); // 泛型类型 `SGen`。</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>// 下面全部函数都得到了变量的所有权，并立即使之离开作用域，将变量释放。</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>// 定义一个函数 `reg_fn`，接受一个 `S` 类型的参数 `_s`。</span></span>\\n<span class=\\"line\\"><span>// 因为没有 `&lt;T&gt;` 这样的泛型类型参数，所以这不是泛型函数。</span></span>\\n<span class=\\"line\\"><span>fn reg_fn(_s: S) {}</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>// 定义一个函数 `gen_spec_t`，接受一个 `SGen&lt;A&gt;` 类型的参数 `_s`。</span></span>\\n<span class=\\"line\\"><span>// `SGen&lt;&gt;` 显式地接受了类型参数 `A`，且在 `gen_spec_t` 中，`A` 没有被用作</span></span>\\n<span class=\\"line\\"><span>// 泛型类型参数，所以函数不是泛型的。</span></span>\\n<span class=\\"line\\"><span>fn gen_spec_t(_s: SGen&lt;A&gt;) {}</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>// 定义一个函数 `gen_spec_i32`，接受一个 `SGen&lt;i32&gt;` 类型的参数 `_s`。</span></span>\\n<span class=\\"line\\"><span>// `SGen&lt;&gt;` 显式地接受了类型参量 `i32`，而 `i32` 是一个具体类型。</span></span>\\n<span class=\\"line\\"><span>// 由于 `i32` 不是一个泛型类型，所以这个函数也不是泛型的。</span></span>\\n<span class=\\"line\\"><span>fn gen_spec_i32(_s: SGen&lt;i32&gt;) {}</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>// 定义一个函数 `generic`，接受一个 `SGen&lt;T&gt;` 类型的参数 `_s`。</span></span>\\n<span class=\\"line\\"><span>// 因为 `SGen&lt;T&gt;` 之前有 `&lt;T&gt;`，所以这个函数是关于 `T` 的泛型函数。</span></span>\\n<span class=\\"line\\"><span>fn generic&lt;T&gt;(_s: SGen&lt;T&gt;) {}</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>fn main() {</span></span>\\n<span class=\\"line\\"><span>    // 使用非泛型函数</span></span>\\n<span class=\\"line\\"><span>    reg_fn(S(A));          // 具体类型。</span></span>\\n<span class=\\"line\\"><span>    gen_spec_t(SGen(A));   // 隐式地指定类型参数 `A`。</span></span>\\n<span class=\\"line\\"><span>    gen_spec_i32(SGen(6)); // 隐式地指定类型参数 `i32`。</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    // 为 `generic()` 显式地指定类型参数 `char`。</span></span>\\n<span class=\\"line\\"><span>    generic::&lt;char&gt;(SGen(\'a\'));</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    // 为 `generic()` 隐式地指定类型参数 `char`。</span></span>\\n<span class=\\"line\\"><span>    generic(SGen(\'c\'));</span></span>\\n<span class=\\"line\\"><span>}</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true,"bioChainData":{"outlink":[{"title":"fn","link":"fn.html"},{"title":"structs","link":"custom_types/structs.html"}],"backlink":[{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"generics/gen_fn.md","value":{"title":"gen_fn","path":"generics/gen_fn.md","outlink":["fn.md","custom_types/structs.md"],"backlink":["SUMMARY.md"]}},{"id":"fn.md","value":{"title":"fn","path":"fn.md","outlink":[],"backlink":[]}},{"id":"custom_types/structs.md","value":{"title":"structs","path":"custom_types/structs.md","outlink":[],"backlink":[]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"generics/gen_fn.md","target":"fn.md"},{"source":"generics/gen_fn.md","target":"custom_types/structs.md"},{"source":"SUMMARY.md","target":"generics/gen_fn.md"}]}}}');export{o as comp,b as data};
