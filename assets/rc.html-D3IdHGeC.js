import{_ as c,e as i,k as l,f as e,i as s,g as p,r as t,o as r}from"./app-CY03Lsxp.js";const d={},o={href:"https://rustwiki.org/zh-CN/std/sync/struct.Arc.html",target:"_blank",rel:"noopener noreferrer"};function u(m,n){const a=t("VPIcon");return r(),i("div",null,[n[5]||(n[5]=l(`<h1 id="引用计数-rc" tabindex="-1"><a class="header-anchor" href="#引用计数-rc"><span>引用计数 <code>Rc</code></span></a></h1><p>当需要多个所有权时，可以使用 <code>Rc</code>（引用计数，Reference Counting 缩写）。<code>Rc</code> 跟踪引用的数量，这相当于包裹在 <code>Rc</code> 值的所有者的数量.</p><p>每当克隆一个 <code>Rc</code> 时，<code>Rc</code> 的引用计数就会增加 1，而每当克隆得到的 <code>Rc</code> 退出作用域时，引用计数就会减少 1。当 <code>Rc</code> 的引用计数变为 0 时，这意味着已经没有所有者，<code>Rc</code> 和值两者都将被删除。</p><p>克隆 <code>Rc</code> 从不执行深拷贝。克隆只创建另一个指向包裹值的指针，并增加计数。</p><div class="language-rust,editable line-numbers-mode" data-highlighter="shiki" data-ext="rust,editable" data-title="rust,editable" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>use std::rc::Rc;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>fn main() {</span></span>
<span class="line"><span>    let rc_examples = &quot;Rc examples&quot;.to_string();</span></span>
<span class="line"><span>    {</span></span>
<span class="line"><span>        println!(&quot;--- rc_a is created ---&quot;);</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        let rc_a: Rc&lt;String&gt; = Rc::new(rc_examples);</span></span>
<span class="line"><span>        println!(&quot;Reference Count of rc_a: {}&quot;, Rc::strong_count(&amp;rc_a));</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        {</span></span>
<span class="line"><span>            println!(&quot;--- rc_a is cloned to rc_b ---&quot;);</span></span>
<span class="line"><span>            </span></span>
<span class="line"><span>            let rc_b: Rc&lt;String&gt; = Rc::clone(&amp;rc_a);</span></span>
<span class="line"><span>            println!(&quot;Reference Count of rc_b: {}&quot;, Rc::strong_count(&amp;rc_b));</span></span>
<span class="line"><span>            println!(&quot;Reference Count of rc_a: {}&quot;, Rc::strong_count(&amp;rc_a));</span></span>
<span class="line"><span>            </span></span>
<span class="line"><span>            // 如果两者内部的值相等的话，则两个 \`Rc\` 相等。</span></span>
<span class="line"><span>            println!(&quot;rc_a and rc_b are equal: {}&quot;, rc_a.eq(&amp;rc_b));</span></span>
<span class="line"><span>                        </span></span>
<span class="line"><span>            // 我们可以直接使用值的方法</span></span>
<span class="line"><span>            println!(&quot;Length of the value inside rc_a: {}&quot;, rc_a.len());</span></span>
<span class="line"><span>            println!(&quot;Value of rc_b: {}&quot;, rc_b);</span></span>
<span class="line"><span>            </span></span>
<span class="line"><span>            println!(&quot;--- rc_b is dropped out of scope ---&quot;);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        println!(&quot;Reference Count of rc_a: {}&quot;, Rc::strong_count(&amp;rc_a));</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        println!(&quot;--- rc_a is dropped out of scope ---&quot;);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    // 报错！\`rc_examples\` 已经移入 \`rc_a\`。</span></span>
<span class="line"><span>    // 而且当 \`rc_a\` 被删时，\`rc_examples\` 也被一起删除。</span></span>
<span class="line"><span>    // println!(&quot;rc_examples: {}&quot;, rc_examples);</span></span>
<span class="line"><span>    // 试一试 ^ 注释掉此行代码</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="参见" tabindex="-1"><a class="header-anchor" href="#参见"><span>参见：</span></a></h3>`,6)),e("p",null,[n[2]||(n[2]=e("a",{href:"https://rustwiki.org/zh-CN/std/rc/index.html",target:"_blank",rel:"noopener noreferrer"},"std::rc",-1)),n[3]||(n[3]=s(" 和 ")),e("a",o,[n[0]||(n[0]=s("std")),p(a,{icon:"sync"}),n[1]||(n[1]=s("arc"))]),n[4]||(n[4]=s("。"))])])}const b=c(d,[["render",u],["__file","rc.html.vue"]]),R=JSON.parse('{"path":"/std/rc.html","title":"引用计数 Rc","lang":"zh-CN","frontmatter":{"description":"引用计数 Rc 当需要多个所有权时，可以使用 Rc（引用计数，Reference Counting 缩写）。Rc 跟踪引用的数量，这相当于包裹在 Rc 值的所有者的数量. 每当克隆一个 Rc 时，Rc 的引用计数就会增加 1，而每当克隆得到的 Rc 退出作用域时，引用计数就会减少 1。当 Rc 的引用计数变为 0 时，这意味着已经没有所有者，Rc 和值...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/rust-by-example-cn/std/rc.html"}],["meta",{"property":"og:site_name","content":"rust-by-example-cn"}],["meta",{"property":"og:title","content":"引用计数 Rc"}],["meta",{"property":"og:description","content":"引用计数 Rc 当需要多个所有权时，可以使用 Rc（引用计数，Reference Counting 缩写）。Rc 跟踪引用的数量，这相当于包裹在 Rc 值的所有者的数量. 每当克隆一个 Rc 时，Rc 的引用计数就会增加 1，而每当克隆得到的 Rc 退出作用域时，引用计数就会减少 1。当 Rc 的引用计数变为 0 时，这意味着已经没有所有者，Rc 和值..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"引用计数 Rc\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/rust-by-example-cn/\\"}]}"]]},"git":{},"readingTime":{"minutes":1.17,"words":351},"filePathRelative":"std/rc.md","excerpt":"\\n<p>当需要多个所有权时，可以使用 <code>Rc</code>（引用计数，Reference Counting 缩写）。<code>Rc</code> 跟踪引用的数量，这相当于包裹在 <code>Rc</code> 值的所有者的数量.</p>\\n<p>每当克隆一个 <code>Rc</code> 时，<code>Rc</code> 的引用计数就会增加 1，而每当克隆得到的 <code>Rc</code> 退出作用域时，引用计数就会减少 1。当 <code>Rc</code> 的引用计数变为 0 时，这意味着已经没有所有者，<code>Rc</code> 和值两者都将被删除。</p>\\n<p>克隆 <code>Rc</code> 从不执行深拷贝。克隆只创建另一个指向包裹值的指针，并增加计数。</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"std/rc.md","value":{"title":"rc","path":"std/rc.md","outlink":[],"backlink":["SUMMARY.md"]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"SUMMARY.md","target":"std/rc.md"}]}}}');export{b as comp,R as data};
