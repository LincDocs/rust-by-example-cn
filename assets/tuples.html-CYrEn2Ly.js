import{_ as l,e as p,k as s,f as a,i,g as t,h as d,r,o as c}from"./app-CVSWwIkE.js";const u={};function v(o,n){const e=r("RouteLink");return c(),p("div",null,[n[5]||(n[5]=s(`<h1 id="元组" tabindex="-1"><a class="header-anchor" href="#元组"><span>元组</span></a></h1><p>元组是一个可以包含各种类型值的组合。元组使用括号 <code>()</code> 来构造（construct），而每个元组自身又是一个类型标记为 <code>(T1, T2, ...)</code> 的值，其中 <code>T1</code>、<code>T2</code> 是每个元素的类型。函数可以使用元组来返回多个值，因为元组可以拥有任意多个值。</p><div class="language-rust,editable line-numbers-mode" data-highlighter="shiki" data-ext="rust,editable" data-title="rust,editable" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// 元组可以充当函数的参数和返回值</span></span>
<span class="line"><span>fn reverse(pair: (i32, bool)) -&gt; (bool, i32) {</span></span>
<span class="line"><span>    // 可以使用 \`let\` 把一个元组的成员绑定到一些变量</span></span>
<span class="line"><span>    let (integer, boolean) = pair;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    (boolean, integer)</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 在 “动手试一试” 的练习中要用到下面这个结构体。</span></span>
<span class="line"><span>#[derive(Debug)]</span></span>
<span class="line"><span>struct Matrix(f32, f32, f32, f32);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>fn main() {</span></span>
<span class="line"><span>    // 包含各种不同类型的元组</span></span>
<span class="line"><span>    let long_tuple = (1u8, 2u16, 3u32, 4u64,</span></span>
<span class="line"><span>                      -1i8, -2i16, -3i32, -4i64,</span></span>
<span class="line"><span>                      0.1f32, 0.2f64,</span></span>
<span class="line"><span>                      &#39;a&#39;, true);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 通过元组的下标来访问具体的值</span></span>
<span class="line"><span>    println!(&quot;long tuple first value: {}&quot;, long_tuple.0);</span></span>
<span class="line"><span>    println!(&quot;long tuple second value: {}&quot;, long_tuple.1);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 元组也可以充当元组的元素</span></span>
<span class="line"><span>    let tuple_of_tuples = ((1u8, 2u16, 2u32), (4u64, -1i8), -2i16);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 元组可以打印</span></span>
<span class="line"><span>    println!(&quot;tuple of tuples: {:?}&quot;, tuple_of_tuples);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 但很长的元组无法打印</span></span>
<span class="line"><span>    // let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);</span></span>
<span class="line"><span>    // println!(&quot;too long tuple: {:?}&quot;, too_long_tuple);</span></span>
<span class="line"><span>    // 试一试 ^ 取消上面两行的注释，阅读编译器给出的错误信息。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    let pair = (1, true);</span></span>
<span class="line"><span>    println!(&quot;pair is {:?}&quot;, pair);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    println!(&quot;the reversed pair is {:?}&quot;, reverse(pair));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建单元素元组需要一个额外的逗号，这是为了和被括号包含的字面量作区分。</span></span>
<span class="line"><span>    println!(&quot;one element tuple: {:?}&quot;, (5u32,));</span></span>
<span class="line"><span>    println!(&quot;just an integer: {:?}&quot;, (5u32));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 元组可以被解构（deconstruct），从而将值绑定给变量</span></span>
<span class="line"><span>    let tuple = (1, &quot;hello&quot;, 4.5, true);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    let (a, b, c, d) = tuple;</span></span>
<span class="line"><span>    println!(&quot;{:?}, {:?}, {:?}, {:?}&quot;, a, b, c, d);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    let matrix = Matrix(1.1, 1.2, 2.1, 2.2);</span></span>
<span class="line"><span>    println!(&quot;{:?}&quot;, matrix)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="动手试一试" tabindex="-1"><a class="header-anchor" href="#动手试一试"><span>动手试一试</span></a></h3>`,4)),a("ol",null,[a("li",null,[n[3]||(n[3]=s(`<p><strong>复习</strong>：在上面的例子中给 Matrix <code>结构体</code> 加上 <code>fmt::Display</code> trait，这样当你从 Debug 格式化 <code>{:?}</code> 切换到 Display 格式化 <code>{}</code> 时，会得到如下的输出：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>( 1.1 1.2 )</span></span>
<span class="line"><span>( 2.1 2.2 )</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>`,2)),a("p",null,[n[1]||(n[1]=i("可以回顾之前学过的")),t(e,{to:"/hello/print/print_display.html"},{default:d(()=>n[0]||(n[0]=[i("显示（display）")])),_:1}),n[2]||(n[2]=i("的例子。"))])]),n[4]||(n[4]=s(`<li><p>以 <code>reverse</code> 函数作为样板，写一个 <code>transpose</code> 函数，它可以接受一个 Matrix 作为参数，并返回一个右上 - 左下对角线上的两元素交换后的 Matrix。举个例子：</p><div class="language-rust,ignore line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore" data-title="rust,ignore" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>println!(&quot;Matrix:\\n{}&quot;, matrix);</span></span>
<span class="line"><span>println!(&quot;Transpose:\\n{}&quot;, transpose(matrix));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Matrix:</span></span>
<span class="line"><span>( 1.1 1.2 )</span></span>
<span class="line"><span>( 2.1 2.2 )</span></span>
<span class="line"><span>Transpose:</span></span>
<span class="line"><span>( 1.1 2.1 )</span></span>
<span class="line"><span>( 1.2 2.2 )</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>`,1))])])}const b=l(u,[["render",v],["__file","tuples.html.vue"]]),h=JSON.parse('{"path":"/primitives/tuples.html","title":"元组","lang":"zh-CN","frontmatter":{"description":"元组 元组是一个可以包含各种类型值的组合。元组使用括号 () 来构造（construct），而每个元组自身又是一个类型标记为 (T1, T2, ...) 的值，其中 T1、T2 是每个元素的类型。函数可以使用元组来返回多个值，因为元组可以拥有任意多个值。 动手试一试 复习：在上面的例子中给 Matrix 结构体 加上 fmt::Display trai...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/rust-by-example-cn-/primitives/tuples.html"}],["meta",{"property":"og:site_name","content":"rust-by-example-cn-"}],["meta",{"property":"og:title","content":"元组"}],["meta",{"property":"og:description","content":"元组 元组是一个可以包含各种类型值的组合。元组使用括号 () 来构造（construct），而每个元组自身又是一个类型标记为 (T1, T2, ...) 的值，其中 T1、T2 是每个元素的类型。函数可以使用元组来返回多个值，因为元组可以拥有任意多个值。 动手试一试 复习：在上面的例子中给 Matrix 结构体 加上 fmt::Display trai..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"元组\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/rust-by-example-cn-/\\"}]}"]]},"git":{},"readingTime":{"minutes":1.9,"words":571},"filePathRelative":"primitives/tuples.md","excerpt":"\\n<p>元组是一个可以包含各种类型值的组合。元组使用括号 <code>()</code> 来构造（construct），而每个元组自身又是一个类型标记为 <code>(T1, T2, ...)</code> 的值，其中 <code>T1</code>、<code>T2</code> 是每个元素的类型。函数可以使用元组来返回多个值，因为元组可以拥有任意多个值。</p>\\n<div class=\\"language-rust,editable line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"rust,editable\\" data-title=\\"rust,editable\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>// 元组可以充当函数的参数和返回值</span></span>\\n<span class=\\"line\\"><span>fn reverse(pair: (i32, bool)) -&gt; (bool, i32) {</span></span>\\n<span class=\\"line\\"><span>    // 可以使用 `let` 把一个元组的成员绑定到一些变量</span></span>\\n<span class=\\"line\\"><span>    let (integer, boolean) = pair;</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    (boolean, integer)</span></span>\\n<span class=\\"line\\"><span>}</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>// 在 “动手试一试” 的练习中要用到下面这个结构体。</span></span>\\n<span class=\\"line\\"><span>#[derive(Debug)]</span></span>\\n<span class=\\"line\\"><span>struct Matrix(f32, f32, f32, f32);</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>fn main() {</span></span>\\n<span class=\\"line\\"><span>    // 包含各种不同类型的元组</span></span>\\n<span class=\\"line\\"><span>    let long_tuple = (1u8, 2u16, 3u32, 4u64,</span></span>\\n<span class=\\"line\\"><span>                      -1i8, -2i16, -3i32, -4i64,</span></span>\\n<span class=\\"line\\"><span>                      0.1f32, 0.2f64,</span></span>\\n<span class=\\"line\\"><span>                      \'a\', true);</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    // 通过元组的下标来访问具体的值</span></span>\\n<span class=\\"line\\"><span>    println!(\\"long tuple first value: {}\\", long_tuple.0);</span></span>\\n<span class=\\"line\\"><span>    println!(\\"long tuple second value: {}\\", long_tuple.1);</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    // 元组也可以充当元组的元素</span></span>\\n<span class=\\"line\\"><span>    let tuple_of_tuples = ((1u8, 2u16, 2u32), (4u64, -1i8), -2i16);</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    // 元组可以打印</span></span>\\n<span class=\\"line\\"><span>    println!(\\"tuple of tuples: {:?}\\", tuple_of_tuples);</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    // 但很长的元组无法打印</span></span>\\n<span class=\\"line\\"><span>    // let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);</span></span>\\n<span class=\\"line\\"><span>    // println!(\\"too long tuple: {:?}\\", too_long_tuple);</span></span>\\n<span class=\\"line\\"><span>    // 试一试 ^ 取消上面两行的注释，阅读编译器给出的错误信息。</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    let pair = (1, true);</span></span>\\n<span class=\\"line\\"><span>    println!(\\"pair is {:?}\\", pair);</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    println!(\\"the reversed pair is {:?}\\", reverse(pair));</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    // 创建单元素元组需要一个额外的逗号，这是为了和被括号包含的字面量作区分。</span></span>\\n<span class=\\"line\\"><span>    println!(\\"one element tuple: {:?}\\", (5u32,));</span></span>\\n<span class=\\"line\\"><span>    println!(\\"just an integer: {:?}\\", (5u32));</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    // 元组可以被解构（deconstruct），从而将值绑定给变量</span></span>\\n<span class=\\"line\\"><span>    let tuple = (1, \\"hello\\", 4.5, true);</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    let (a, b, c, d) = tuple;</span></span>\\n<span class=\\"line\\"><span>    println!(\\"{:?}, {:?}, {:?}, {:?}\\", a, b, c, d);</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    let matrix = Matrix(1.1, 1.2, 2.1, 2.2);</span></span>\\n<span class=\\"line\\"><span>    println!(\\"{:?}\\", matrix)</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>}</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true,"bioChainData":{"outlink":[{"title":"print_display","link":"hello/print/print_display.html"}],"backlink":[{"title":"SUMMARY","link":"SUMMARY.html"},{"title":"guard","link":"flow_control/match/guard.html"},{"title":"destructure_tuple","link":"flow_control/match/destructuring/destructure_tuple.html"}],"localMap":{"nodes":[{"id":"primitives/tuples.md","value":{"title":"tuples","path":"primitives/tuples.md","outlink":["hello/print/print_display.md"],"backlink":["SUMMARY.md","flow_control/match/guard.md","flow_control/match/destructuring/destructure_tuple.md"]}},{"id":"hello/print/print_display.md","value":{"title":"print_display","path":"hello/print/print_display.md","outlink":[],"backlink":[]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}},{"id":"flow_control/match/guard.md","value":{"title":"guard","path":"flow_control/match/guard.md","outlink":[],"backlink":[]}},{"id":"flow_control/match/destructuring/destructure_tuple.md","value":{"title":"destructure_tuple","path":"flow_control/match/destructuring/destructure_tuple.md","outlink":[],"backlink":[]}}],"links":[{"source":"primitives/tuples.md","target":"hello/print/print_display.md"},{"source":"SUMMARY.md","target":"primitives/tuples.md"},{"source":"flow_control/match/guard.md","target":"primitives/tuples.md"},{"source":"flow_control/match/destructuring/destructure_tuple.md","target":"primitives/tuples.md"}]}}}');export{b as comp,h as data};
