import{_ as n,e as a,k as i,o as e}from"./app-CVSWwIkE.js";const l={};function p(t,s){return e(),a("div",null,s[0]||(s[0]=[i(`<h1 id="impl-trait" tabindex="-1"><a class="header-anchor" href="#impl-trait"><span><code>impl Trait</code></span></a></h1><p>如果函数返回实现了 <code>MyTrait</code> 的类型，可以将其返回类型编写为 <code>-&gt; impl MyTrait</code>。这可以大大简化你的类型签名！</p><div class="language-rust,editable line-numbers-mode" data-highlighter="shiki" data-ext="rust,editable" data-title="rust,editable" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>use std::iter;</span></span>
<span class="line"><span>use std::vec::IntoIter;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 该函数组合了两个 \`Vec &lt;i32&gt;\` 并在其上返回一个迭代器。</span></span>
<span class="line"><span>// 看看它的返回类型多么复杂！</span></span>
<span class="line"><span>fn combine_vecs_explicit_return_type(</span></span>
<span class="line"><span>    v: Vec&lt;i32&gt;,</span></span>
<span class="line"><span>    u: Vec&lt;i32&gt;,</span></span>
<span class="line"><span>) -&gt; iter::Cycle&lt;iter::Chain&lt;IntoIter&lt;i32&gt;, IntoIter&lt;i32&gt;&gt;&gt; {</span></span>
<span class="line"><span>    v.into_iter().chain(u.into_iter()).cycle()</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这是完全相同的函数，但其返回类型使用 \`impl Trait\`。</span></span>
<span class="line"><span>// 看看它多么简单！</span></span>
<span class="line"><span>fn combine_vecs(</span></span>
<span class="line"><span>    v: Vec&lt;i32&gt;,</span></span>
<span class="line"><span>    u: Vec&lt;i32&gt;,</span></span>
<span class="line"><span>) -&gt; impl Iterator&lt;Item=i32&gt; {</span></span>
<span class="line"><span>    v.into_iter().chain(u.into_iter()).cycle()</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>fn main() {</span></span>
<span class="line"><span>    let v1 = vec![1, 2, 3];</span></span>
<span class="line"><span>    let v2 = vec![4, 5];</span></span>
<span class="line"><span>    let mut v3 = combine_vecs(v1, v2);</span></span>
<span class="line"><span>    assert_eq!(Some(1), v3.next());</span></span>
<span class="line"><span>    assert_eq!(Some(2), v3.next());</span></span>
<span class="line"><span>    assert_eq!(Some(3), v3.next());</span></span>
<span class="line"><span>    assert_eq!(Some(4), v3.next());</span></span>
<span class="line"><span>    assert_eq!(Some(5), v3.next());</span></span>
<span class="line"><span>    println!(&quot;all done&quot;);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>更重要的是，某些 Rust 类型无法写出。例如，每个闭包都有自己未命名的具体类型。在使用 <code>impl Trait</code> 语法之前，必须在堆上进行分配才能返回闭包。但是现在你可以像下面这样静态地完成所有操作：</p><div class="language-rust,editable line-numbers-mode" data-highlighter="shiki" data-ext="rust,editable" data-title="rust,editable" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// 返回一个将输入和 \`y\` 相加的函数</span></span>
<span class="line"><span>fn make_adder_function(y: i32) -&gt; impl Fn(i32) -&gt; i32 {</span></span>
<span class="line"><span>    let closure = move |x: i32| { x + y };</span></span>
<span class="line"><span>    closure</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>fn main() {</span></span>
<span class="line"><span>    let plus_one = make_adder_function(1);</span></span>
<span class="line"><span>    assert_eq!(plus_one(2), 3);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>您还可以使用 <code>impl Trait</code> 返回使用 <code>map</code> 或 <code>filter</code> 闭包的迭代器！这使得使用 <code>map</code> 和 <code>filter</code> 更容易。因为闭包类型没有名称，所以如果函数返回带闭包的迭代器，则无法写出显式的返回类型。但是有了 <code>impl Trait</code>，你就可以轻松地做到这一点：</p><div class="language-rust,editable line-numbers-mode" data-highlighter="shiki" data-ext="rust,editable" data-title="rust,editable" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>fn double_positives&lt;&#39;a&gt;(numbers: &amp;&#39;a Vec&lt;i32&gt;) -&gt; impl Iterator&lt;Item = i32&gt; + &#39;a {</span></span>
<span class="line"><span>    numbers</span></span>
<span class="line"><span>        .iter()</span></span>
<span class="line"><span>        .filter(|x| x &gt; &amp;&amp;0)</span></span>
<span class="line"><span>        .map(|x| x * 2)</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,7)]))}const r=n(l,[["render",p],["__file","impl_trait.html.vue"]]),d=JSON.parse('{"path":"/trait/impl_trait.html","title":"impl Trait","lang":"zh-CN","frontmatter":{"description":"impl Trait 如果函数返回实现了 MyTrait 的类型，可以将其返回类型编写为 -> impl MyTrait。这可以大大简化你的类型签名！ 更重要的是，某些 Rust 类型无法写出。例如，每个闭包都有自己未命名的具体类型。在使用 impl Trait 语法之前，必须在堆上进行分配才能返回闭包。但是现在你可以像下面这样静态地完成所有操作： 您...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/rust-by-example-cn-/trait/impl_trait.html"}],["meta",{"property":"og:site_name","content":"rust-by-example-cn-"}],["meta",{"property":"og:title","content":"impl Trait"}],["meta",{"property":"og:description","content":"impl Trait 如果函数返回实现了 MyTrait 的类型，可以将其返回类型编写为 -> impl MyTrait。这可以大大简化你的类型签名！ 更重要的是，某些 Rust 类型无法写出。例如，每个闭包都有自己未命名的具体类型。在使用 impl Trait 语法之前，必须在堆上进行分配才能返回闭包。但是现在你可以像下面这样静态地完成所有操作： 您..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"impl Trait\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/rust-by-example-cn-/\\"}]}"]]},"git":{},"readingTime":{"minutes":1.41,"words":422},"filePathRelative":"trait/impl_trait.md","excerpt":"\\n<p>如果函数返回实现了 <code>MyTrait</code> 的类型，可以将其返回类型编写为 <code>-&gt; impl MyTrait</code>。这可以大大简化你的类型签名！</p>\\n<div class=\\"language-rust,editable line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"rust,editable\\" data-title=\\"rust,editable\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>use std::iter;</span></span>\\n<span class=\\"line\\"><span>use std::vec::IntoIter;</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>// 该函数组合了两个 `Vec &lt;i32&gt;` 并在其上返回一个迭代器。</span></span>\\n<span class=\\"line\\"><span>// 看看它的返回类型多么复杂！</span></span>\\n<span class=\\"line\\"><span>fn combine_vecs_explicit_return_type(</span></span>\\n<span class=\\"line\\"><span>    v: Vec&lt;i32&gt;,</span></span>\\n<span class=\\"line\\"><span>    u: Vec&lt;i32&gt;,</span></span>\\n<span class=\\"line\\"><span>) -&gt; iter::Cycle&lt;iter::Chain&lt;IntoIter&lt;i32&gt;, IntoIter&lt;i32&gt;&gt;&gt; {</span></span>\\n<span class=\\"line\\"><span>    v.into_iter().chain(u.into_iter()).cycle()</span></span>\\n<span class=\\"line\\"><span>}</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>// 这是完全相同的函数，但其返回类型使用 `impl Trait`。</span></span>\\n<span class=\\"line\\"><span>// 看看它多么简单！</span></span>\\n<span class=\\"line\\"><span>fn combine_vecs(</span></span>\\n<span class=\\"line\\"><span>    v: Vec&lt;i32&gt;,</span></span>\\n<span class=\\"line\\"><span>    u: Vec&lt;i32&gt;,</span></span>\\n<span class=\\"line\\"><span>) -&gt; impl Iterator&lt;Item=i32&gt; {</span></span>\\n<span class=\\"line\\"><span>    v.into_iter().chain(u.into_iter()).cycle()</span></span>\\n<span class=\\"line\\"><span>}</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>fn main() {</span></span>\\n<span class=\\"line\\"><span>    let v1 = vec![1, 2, 3];</span></span>\\n<span class=\\"line\\"><span>    let v2 = vec![4, 5];</span></span>\\n<span class=\\"line\\"><span>    let mut v3 = combine_vecs(v1, v2);</span></span>\\n<span class=\\"line\\"><span>    assert_eq!(Some(1), v3.next());</span></span>\\n<span class=\\"line\\"><span>    assert_eq!(Some(2), v3.next());</span></span>\\n<span class=\\"line\\"><span>    assert_eq!(Some(3), v3.next());</span></span>\\n<span class=\\"line\\"><span>    assert_eq!(Some(4), v3.next());</span></span>\\n<span class=\\"line\\"><span>    assert_eq!(Some(5), v3.next());</span></span>\\n<span class=\\"line\\"><span>    println!(\\"all done\\");</span></span>\\n<span class=\\"line\\"><span>}</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"SUMMARY","link":"SUMMARY.html"},{"title":"output_parameters","link":"fn/closures/output_parameters.html"}],"localMap":{"nodes":[{"id":"trait/impl_trait.md","value":{"title":"impl_trait","path":"trait/impl_trait.md","outlink":[],"backlink":["SUMMARY.md","fn/closures/output_parameters.md"]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}},{"id":"fn/closures/output_parameters.md","value":{"title":"output_parameters","path":"fn/closures/output_parameters.md","outlink":[],"backlink":[]}}],"links":[{"source":"SUMMARY.md","target":"trait/impl_trait.md"},{"source":"fn/closures/output_parameters.md","target":"trait/impl_trait.md"}]}}}');export{r as comp,d as data};
