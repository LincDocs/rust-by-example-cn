import{_ as s,e,k as a,o as i}from"./app-CY03Lsxp.js";const t={};function r(l,n){return i(),e("div",null,n[0]||(n[0]=[a(`<h1 id="from-和-into" tabindex="-1"><a class="header-anchor" href="#from-和-into"><span><code>From</code> 和 <code>Into</code></span></a></h1><p><a href="https://rustwiki.org/zh-CN/std/convert/trait.From.html" target="_blank" rel="noopener noreferrer"><code>From</code></a> 和 <a href="https://rustwiki.org/zh-CN/std/convert/trait.Into.html" target="_blank" rel="noopener noreferrer"><code>Into</code></a> 两个 trait 是内部相关联的，实际上这是它们实现的一部分。如果我们能够从类型 B 得到类型 A，那么很容易相信我们也能够把类型 A 转换为类型 B。</p><h2 id="from" tabindex="-1"><a class="header-anchor" href="#from"><span><code>From</code></span></a></h2><p><a href="https://rustwiki.org/zh-CN/std/convert/trait.From.html" target="_blank" rel="noopener noreferrer"><code>From</code></a> trait 允许一种类型定义 “怎么根据另一种类型生成自己”，因此它提供了一种类型转换的简单机制。在标准库中有无数 <code>From</code> 的实现，规定原生类型及其他常见类型的转换功能。</p><p>比如，可以很容易地把 <code>str</code> 转换成 <code>String</code>：</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> my_str</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;hello&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> my_string</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">my_str</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以为我们自己的类型定义转换机制：</p><div class="language-rust,editable line-numbers-mode" data-highlighter="shiki" data-ext="rust,editable" data-title="rust,editable" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>use std::convert::From;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#[derive(Debug)]</span></span>
<span class="line"><span>struct Number {</span></span>
<span class="line"><span>    value: i32,</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>impl From&lt;i32&gt; for Number {</span></span>
<span class="line"><span>    fn from(item: i32) -&gt; Self {</span></span>
<span class="line"><span>        Number { value: item }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>fn main() {</span></span>
<span class="line"><span>    let num = Number::from(30);</span></span>
<span class="line"><span>    println!(&quot;My number is {:?}&quot;, num);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="into" tabindex="-1"><a class="header-anchor" href="#into"><span><code>Into</code></span></a></h2><p><a href="https://rustwiki.org/zh-CN/std/convert/trait.Into.html" target="_blank" rel="noopener noreferrer"><code>Into</code></a> trait 就是把 <code>From</code> trait 倒过来而已。也就是说，如果你为你的类型实现了 <code>From</code>，那么同时你也就免费获得了 <code>Into</code>。</p><p>使用 <code>Into</code> trait 通常要求指明要转换到的类型，因为编译器大多数时候不能推断它。不过考虑到我们免费获得了 <code>Into</code>，这点代价不值一提。</p><div class="language-rust,editable line-numbers-mode" data-highlighter="shiki" data-ext="rust,editable" data-title="rust,editable" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>use std::convert::Into;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#[derive(Debug)]</span></span>
<span class="line"><span>struct Number {</span></span>
<span class="line"><span>    value: i32,</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>impl Into&lt;Number&gt; for i32 {</span></span>
<span class="line"><span>    fn into(self) -&gt; Number {</span></span>
<span class="line"><span>        Number { value: self }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>fn main() {</span></span>
<span class="line"><span>    let int = 5;</span></span>
<span class="line"><span>    // 试试删除类型注释</span></span>
<span class="line"><span>    let num: Number = int.into();</span></span>
<span class="line"><span>    println!(&quot;My number is {:?}&quot;, num);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,12)]))}const o=s(t,[["render",r],["__file","from_into.html.vue"]]),d=JSON.parse('{"path":"/conversion/from_into.html","title":"From 和 Into","lang":"zh-CN","frontmatter":{"description":"From 和 Into From 和 Into 两个 trait 是内部相关联的，实际上这是它们实现的一部分。如果我们能够从类型 B 得到类型 A，那么很容易相信我们也能够把类型 A 转换为类型 B。 From From trait 允许一种类型定义 “怎么根据另一种类型生成自己”，因此它提供了一种类型转换的简单机制。在标准库中有无数 From 的实现...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/rust-by-example-cn/conversion/from_into.html"}],["meta",{"property":"og:site_name","content":"rust-by-example-cn"}],["meta",{"property":"og:title","content":"From 和 Into"}],["meta",{"property":"og:description","content":"From 和 Into From 和 Into 两个 trait 是内部相关联的，实际上这是它们实现的一部分。如果我们能够从类型 B 得到类型 A，那么很容易相信我们也能够把类型 A 转换为类型 B。 From From trait 允许一种类型定义 “怎么根据另一种类型生成自己”，因此它提供了一种类型转换的简单机制。在标准库中有无数 From 的实现..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"From 和 Into\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/rust-by-example-cn/\\"}]}"]]},"git":{},"readingTime":{"minutes":1.21,"words":364},"filePathRelative":"conversion/from_into.md","excerpt":"\\n<p><a href=\\"https://rustwiki.org/zh-CN/std/convert/trait.From.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\"><code>From</code></a> 和 <a href=\\"https://rustwiki.org/zh-CN/std/convert/trait.Into.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\"><code>Into</code></a> 两个 trait 是内部相关联的，实际上这是它们实现的一部分。如果我们能够从类型 B 得到类型 A，那么很容易相信我们也能够把类型 A 转换为类型 B。</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"conversion/from_into.md","value":{"title":"from_into","path":"conversion/from_into.md","outlink":[],"backlink":["SUMMARY.md"]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"SUMMARY.md","target":"conversion/from_into.md"}]}}}');export{o as comp,d as data};
