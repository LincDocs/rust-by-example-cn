import{_ as i,e as t,k as a,f as s,g as l,h as c,r,o}from"./app-CVSWwIkE.js";const p={};function d(m,e){const n=r("RouteLink");return o(),t("div",null,[e[1]||(e[1]=a('<h1 id="泛型" tabindex="-1"><a class="header-anchor" href="#泛型"><span>泛型</span></a></h1><p><strong>泛型</strong>（generic）是关于泛化类型和函数功能，以扩大其适用范围的话题。泛型极大地减少了代码的重复，但它自身的语法很要求细心。也就是说，采用泛型意味着仔细地指定泛型类型具体化时，什么样的具体类型是合法的。泛型最简单和常用的用法是用于类型参数。</p><blockquote><p>译注：定义泛型类型或泛型函数之类的东西时，我们会用 <code>&lt;A&gt;</code> 或者 <code>&lt;T&gt;</code> 这类标记<br> 作为类型的代号，就像函数的形参一样。在使用时，为把 <code>&lt;A&gt;</code>、<code>&lt;T&gt;</code> 具体化，我们<br> 会把类型说明像实参一样使用，像是 <code>&lt;i32&gt;</code> 这样。这两种把（泛型的或具体的）类型<br> 当作参数的用法就是<strong>类型参数</strong>。</p></blockquote><p>泛型的类型参数是使用尖括号和<a href="https://en.wikipedia.org/wiki/CamelCase" target="_blank" rel="noopener noreferrer">大驼峰命名</a>的名称：<code>&lt;Aaa, Bbb, ...&gt;</code><br> 来指定的。泛型类型参数一般用 <code>&lt;T&gt;</code> 来表示。在 Rust 中，“泛型的” 除了表示类型，还表示可以接受一个或多个泛型类型参数 <code>&lt;T&gt;</code> 的任何内容。任何用泛型类型参数表示的类型都是泛型，其他的类型都是具体（非泛型）类型。</p><p>例如定义一个名为 <code>foo</code> 的 <strong>泛型函数</strong>，它可接受类型为 <code>T</code> 的任何参数 <code>arg</code>：</p><div class="language-rust,ignore line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore" data-title="rust,ignore" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>fn foo&lt;T&gt;(arg: T) { ... }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>因为我们使用了泛型类型参数 <code>&lt;T&gt;</code>，所以这里的 <code>(arg: T)</code> 中的 <code>T</code> 就是泛型类型。即使 <code>T</code> 在之前被定义为 <code>struct</code>，这里的 <code>T</code> 仍然代表泛型。</p><p>下面例子展示了泛型语法的使用：</p><div class="language-rust,editable line-numbers-mode" data-highlighter="shiki" data-ext="rust,editable" data-title="rust,editable" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// 一个具体类型 `A`。</span></span>\n<span class="line"><span>struct A;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>// 在定义类型 `Single` 时，第一次使用类型 `A` 之前没有写 `&lt;A&gt;`。</span></span>\n<span class="line"><span>// 因此，`Single` 是个具体类型，`A` 取上面的定义。</span></span>\n<span class="line"><span>struct Single(A);</span></span>\n<span class="line"><span>//            ^ 这里是 `Single` 对类型 `A` 的第一次使用。</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>// 此处 `&lt;T&gt;` 在第一次使用 `T` 前出现，所以 `SingleGen` 是一个泛型类型。</span></span>\n<span class="line"><span>// 因为 `T` 是泛型的，所以它可以是任何类型，包括在上面定义的具体类型 `A`。</span></span>\n<span class="line"><span>struct SingleGen&lt;T&gt;(T);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>fn main() {</span></span>\n<span class="line"><span>    // `Single` 是具体类型，并且显式地使用类型 `A`。</span></span>\n<span class="line"><span>    let _s = Single(A);</span></span>\n<span class="line"><span>    </span></span>\n<span class="line"><span>    // 创建一个 `SingleGen&lt;char&gt;` 类型的变量 `_char`，并令其值为 `SingleGen(&#39;a&#39;)`</span></span>\n<span class="line"><span>    // 这里的 `SingleGen` 的类型参数是显式指定的。</span></span>\n<span class="line"><span>    let _char: SingleGen&lt;char&gt; = SingleGen(&#39;a&#39;);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    // `SingleGen` 的类型参数也可以隐式地指定。</span></span>\n<span class="line"><span>    let _t    = SingleGen(A); // 使用在上面定义的 `A`。</span></span>\n<span class="line"><span>    let _i32  = SingleGen(6); // 使用 `i32` 类型。</span></span>\n<span class="line"><span>    let _char = SingleGen(&#39;a&#39;); // 使用 `char`。</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="参见" tabindex="-1"><a class="header-anchor" href="#参见"><span>参见：</span></a></h3>',10)),s("p",null,[l(n,{to:"/custom_types/structs.html"},{default:c(()=>e[0]||(e[0]=[s("code",null,"struct",-1)])),_:1})])])}const g=i(p,[["render",d],["__file","generics.html.vue"]]),b=JSON.parse('{"path":"/generics.html","title":"泛型","lang":"zh-CN","frontmatter":{"description":"泛型 泛型（generic）是关于泛化类型和函数功能，以扩大其适用范围的话题。泛型极大地减少了代码的重复，但它自身的语法很要求细心。也就是说，采用泛型意味着仔细地指定泛型类型具体化时，什么样的具体类型是合法的。泛型最简单和常用的用法是用于类型参数。 译注：定义泛型类型或泛型函数之类的东西时，我们会用 <A> 或者 <T> 这类标记 作为类型的代号，就像...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/rust-by-example-cn-/generics.html"}],["meta",{"property":"og:site_name","content":"rust-by-example-cn-"}],["meta",{"property":"og:title","content":"泛型"}],["meta",{"property":"og:description","content":"泛型 泛型（generic）是关于泛化类型和函数功能，以扩大其适用范围的话题。泛型极大地减少了代码的重复，但它自身的语法很要求细心。也就是说，采用泛型意味着仔细地指定泛型类型具体化时，什么样的具体类型是合法的。泛型最简单和常用的用法是用于类型参数。 译注：定义泛型类型或泛型函数之类的东西时，我们会用 <A> 或者 <T> 这类标记 作为类型的代号，就像..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"泛型\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/rust-by-example-cn-/\\"}]}"]]},"git":{},"readingTime":{"minutes":2.24,"words":672},"filePathRelative":"generics.md","excerpt":"\\n<p><strong>泛型</strong>（generic）是关于泛化类型和函数功能，以扩大其适用范围的话题。泛型极大地减少了代码的重复，但它自身的语法很要求细心。也就是说，采用泛型意味着仔细地指定泛型类型具体化时，什么样的具体类型是合法的。泛型最简单和常用的用法是用于类型参数。</p>\\n<blockquote>\\n<p>译注：定义泛型类型或泛型函数之类的东西时，我们会用 <code>&lt;A&gt;</code> 或者 <code>&lt;T&gt;</code> 这类标记<br>\\n作为类型的代号，就像函数的形参一样。在使用时，为把 <code>&lt;A&gt;</code>、<code>&lt;T&gt;</code> 具体化，我们<br>\\n会把类型说明像实参一样使用，像是 <code>&lt;i32&gt;</code> 这样。这两种把（泛型的或具体的）类型<br>\\n当作参数的用法就是<strong>类型参数</strong>。</p>\\n</blockquote>","autoDesc":true,"bioChainData":{"outlink":[{"title":"structs","link":"custom_types/structs.html"}],"backlink":[{"title":"SUMMARY","link":"SUMMARY.html"},{"title":"struct_visibility","link":"mod/struct_visibility.html"},{"title":"anonymity","link":"fn/closures/anonymity.html"},{"title":"output_parameters","link":"fn/closures/output_parameters.html"},{"title":"explicit","link":"scope/lifetime/explicit.html"},{"title":"lifetime_bounds","link":"scope/lifetime/lifetime_bounds.html"}],"localMap":{"nodes":[{"id":"generics.md","value":{"title":"generics","path":"generics.md","outlink":["custom_types/structs.md"],"backlink":["SUMMARY.md","mod/struct_visibility.md","fn/closures/anonymity.md","fn/closures/output_parameters.md","scope/lifetime/explicit.md","scope/lifetime/lifetime_bounds.md"]}},{"id":"custom_types/structs.md","value":{"title":"structs","path":"custom_types/structs.md","outlink":[],"backlink":[]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}},{"id":"mod/struct_visibility.md","value":{"title":"struct_visibility","path":"mod/struct_visibility.md","outlink":[],"backlink":[]}},{"id":"fn/closures/anonymity.md","value":{"title":"anonymity","path":"fn/closures/anonymity.md","outlink":[],"backlink":[]}},{"id":"fn/closures/output_parameters.md","value":{"title":"output_parameters","path":"fn/closures/output_parameters.md","outlink":[],"backlink":[]}},{"id":"scope/lifetime/explicit.md","value":{"title":"explicit","path":"scope/lifetime/explicit.md","outlink":[],"backlink":[]}},{"id":"scope/lifetime/lifetime_bounds.md","value":{"title":"lifetime_bounds","path":"scope/lifetime/lifetime_bounds.md","outlink":[],"backlink":[]}}],"links":[{"source":"generics.md","target":"custom_types/structs.md"},{"source":"SUMMARY.md","target":"generics.md"},{"source":"mod/struct_visibility.md","target":"generics.md"},{"source":"fn/closures/anonymity.md","target":"generics.md"},{"source":"fn/closures/output_parameters.md","target":"generics.md"},{"source":"scope/lifetime/explicit.md","target":"generics.md"},{"source":"scope/lifetime/lifetime_bounds.md","target":"generics.md"}]}}}');export{g as comp,b as data};
