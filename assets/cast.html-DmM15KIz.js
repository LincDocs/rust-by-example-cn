import{_ as n,e as a,k as i,o as e}from"./app-CVSWwIkE.js";const l={};function p(c,s){return e(),a("div",null,s[0]||(s[0]=[i(`<h1 id="类型转换" tabindex="-1"><a class="header-anchor" href="#类型转换"><span>类型转换</span></a></h1><p>Rust 不提供原生类型之间的隐式类型转换（coercion），但可以使用 <code>as</code> 关键字进行显式类型转换（casting）。</p><p>整型之间的转换大体遵循 C 语言的惯例，除了 C 会产生未定义行为的情形。在 Rust 中所有整型转换都是定义良好的。</p><div class="language-rust,editable,ignore,mdbook-runnable line-numbers-mode" data-highlighter="shiki" data-ext="rust,editable,ignore,mdbook-runnable" data-title="rust,editable,ignore,mdbook-runnable" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// 不显示类型转换产生的溢出警告。</span></span>
<span class="line"><span>#![allow(overflowing_literals)]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>fn main() {</span></span>
<span class="line"><span>    let decimal = 65.4321_f32;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 错误！不提供隐式转换</span></span>
<span class="line"><span>    let integer: u8 = decimal;</span></span>
<span class="line"><span>    // 改正 ^ 注释掉这一行</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 可以显式转换</span></span>
<span class="line"><span>    let integer = decimal as u8;</span></span>
<span class="line"><span>    let character = integer as char;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    println!(&quot;Casting: {} -&gt; {} -&gt; {}&quot;, decimal, integer, character);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 当把任何类型转换为无符号类型 T 时，会不断加上或减去 (std::T::MAX + 1)</span></span>
<span class="line"><span>    // 直到值位于新类型 T 的范围内。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 1000 已经在 u16 的范围内</span></span>
<span class="line"><span>    println!(&quot;1000 as a u16 is: {}&quot;, 1000 as u16);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 1000 - 256 - 256 - 256 = 232</span></span>
<span class="line"><span>    // 事实上的处理方式是：从最低有效位（LSB，least significant bits）开始保留</span></span>
<span class="line"><span>    // 8 位，然后剩余位置，直到最高有效位（MSB，most significant bit）都被抛弃。</span></span>
<span class="line"><span>    // 译注：MSB 就是二进制的最高位，LSB 就是二进制的最低位，按日常书写习惯就是</span></span>
<span class="line"><span>    // 最左边一位和最右边一位。</span></span>
<span class="line"><span>    println!(&quot;1000 as a u8 is : {}&quot;, 1000 as u8);</span></span>
<span class="line"><span>    // -1 + 256 = 255</span></span>
<span class="line"><span>    println!(&quot;  -1 as a u8 is : {}&quot;, (-1i8) as u8);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 对正数，这就和取模一样。</span></span>
<span class="line"><span>    println!(&quot;1000 mod 256 is : {}&quot;, 1000 % 256);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 当转换到有符号类型时，（位操作的）结果就和 “先转换到对应的无符号类型，</span></span>
<span class="line"><span>    // 如果 MSB 是 1，则该值为负” 是一样的。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 当然如果数值已经在目标类型的范围内，就直接把它放进去。</span></span>
<span class="line"><span>    println!(&quot; 128 as a i16 is: {}&quot;, 128 as i16);</span></span>
<span class="line"><span>    // 128 转成 u8 还是 128，但转到 i8 相当于给 128 取八位的二进制补码，其值是：</span></span>
<span class="line"><span>    println!(&quot; 128 as a i8 is : {}&quot;, 128 as i8);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 重复之前的例子</span></span>
<span class="line"><span>    // 1000 as u8 -&gt; 232</span></span>
<span class="line"><span>    println!(&quot;1000 as a u8 is : {}&quot;, 1000 as u8);</span></span>
<span class="line"><span>    // 232 的二进制补码是 -24</span></span>
<span class="line"><span>    println!(&quot; 232 as a i8 is : {}&quot;, 232 as i8);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,4)]))}const t=n(l,[["render",p],["__file","cast.html.vue"]]),r=JSON.parse('{"path":"/types/cast.html","title":"类型转换","lang":"zh-CN","frontmatter":{"description":"类型转换 Rust 不提供原生类型之间的隐式类型转换（coercion），但可以使用 as 关键字进行显式类型转换（casting）。 整型之间的转换大体遵循 C 语言的惯例，除了 C 会产生未定义行为的情形。在 Rust 中所有整型转换都是定义良好的。","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/rust-by-example-cn-/types/cast.html"}],["meta",{"property":"og:site_name","content":"rust-by-example-cn-"}],["meta",{"property":"og:title","content":"类型转换"}],["meta",{"property":"og:description","content":"类型转换 Rust 不提供原生类型之间的隐式类型转换（coercion），但可以使用 as 关键字进行显式类型转换（casting）。 整型之间的转换大体遵循 C 语言的惯例，除了 C 会产生未定义行为的情形。在 Rust 中所有整型转换都是定义良好的。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"类型转换\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/rust-by-example-cn-/\\"}]}"]]},"git":{},"readingTime":{"minutes":1.73,"words":519},"filePathRelative":"types/cast.md","excerpt":"\\n<p>Rust 不提供原生类型之间的隐式类型转换（coercion），但可以使用 <code>as</code> 关键字进行显式类型转换（casting）。</p>\\n<p>整型之间的转换大体遵循 C 语言的惯例，除了 C 会产生未定义行为的情形。在 Rust 中所有整型转换都是定义良好的。</p>\\n<div class=\\"language-rust,editable,ignore,mdbook-runnable line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"rust,editable,ignore,mdbook-runnable\\" data-title=\\"rust,editable,ignore,mdbook-runnable\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>// 不显示类型转换产生的溢出警告。</span></span>\\n<span class=\\"line\\"><span>#![allow(overflowing_literals)]</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>fn main() {</span></span>\\n<span class=\\"line\\"><span>    let decimal = 65.4321_f32;</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    // 错误！不提供隐式转换</span></span>\\n<span class=\\"line\\"><span>    let integer: u8 = decimal;</span></span>\\n<span class=\\"line\\"><span>    // 改正 ^ 注释掉这一行</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    // 可以显式转换</span></span>\\n<span class=\\"line\\"><span>    let integer = decimal as u8;</span></span>\\n<span class=\\"line\\"><span>    let character = integer as char;</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    println!(\\"Casting: {} -&gt; {} -&gt; {}\\", decimal, integer, character);</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    // 当把任何类型转换为无符号类型 T 时，会不断加上或减去 (std::T::MAX + 1)</span></span>\\n<span class=\\"line\\"><span>    // 直到值位于新类型 T 的范围内。</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    // 1000 已经在 u16 的范围内</span></span>\\n<span class=\\"line\\"><span>    println!(\\"1000 as a u16 is: {}\\", 1000 as u16);</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    // 1000 - 256 - 256 - 256 = 232</span></span>\\n<span class=\\"line\\"><span>    // 事实上的处理方式是：从最低有效位（LSB，least significant bits）开始保留</span></span>\\n<span class=\\"line\\"><span>    // 8 位，然后剩余位置，直到最高有效位（MSB，most significant bit）都被抛弃。</span></span>\\n<span class=\\"line\\"><span>    // 译注：MSB 就是二进制的最高位，LSB 就是二进制的最低位，按日常书写习惯就是</span></span>\\n<span class=\\"line\\"><span>    // 最左边一位和最右边一位。</span></span>\\n<span class=\\"line\\"><span>    println!(\\"1000 as a u8 is : {}\\", 1000 as u8);</span></span>\\n<span class=\\"line\\"><span>    // -1 + 256 = 255</span></span>\\n<span class=\\"line\\"><span>    println!(\\"  -1 as a u8 is : {}\\", (-1i8) as u8);</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    // 对正数，这就和取模一样。</span></span>\\n<span class=\\"line\\"><span>    println!(\\"1000 mod 256 is : {}\\", 1000 % 256);</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    // 当转换到有符号类型时，（位操作的）结果就和 “先转换到对应的无符号类型，</span></span>\\n<span class=\\"line\\"><span>    // 如果 MSB 是 1，则该值为负” 是一样的。</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    // 当然如果数值已经在目标类型的范围内，就直接把它放进去。</span></span>\\n<span class=\\"line\\"><span>    println!(\\" 128 as a i16 is: {}\\", 128 as i16);</span></span>\\n<span class=\\"line\\"><span>    // 128 转成 u8 还是 128，但转到 i8 相当于给 128 取八位的二进制补码，其值是：</span></span>\\n<span class=\\"line\\"><span>    println!(\\" 128 as a i8 is : {}\\", 128 as i8);</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    // 重复之前的例子</span></span>\\n<span class=\\"line\\"><span>    // 1000 as u8 -&gt; 232</span></span>\\n<span class=\\"line\\"><span>    println!(\\"1000 as a u8 is : {}\\", 1000 as u8);</span></span>\\n<span class=\\"line\\"><span>    // 232 的二进制补码是 -24</span></span>\\n<span class=\\"line\\"><span>    println!(\\" 232 as a i8 is : {}\\", 232 as i8);</span></span>\\n<span class=\\"line\\"><span>}</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"SUMMARY","link":"SUMMARY.html"},{"title":"types","link":"types.html"},{"title":"c_like","link":"custom_types/enum/c_like.html"}],"localMap":{"nodes":[{"id":"types/cast.md","value":{"title":"cast","path":"types/cast.md","outlink":[],"backlink":["SUMMARY.md","types.md","custom_types/enum/c_like.md"]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}},{"id":"types.md","value":{"title":"types","path":"types.md","outlink":[],"backlink":[]}},{"id":"custom_types/enum/c_like.md","value":{"title":"c_like","path":"custom_types/enum/c_like.md","outlink":[],"backlink":[]}}],"links":[{"source":"SUMMARY.md","target":"types/cast.md"},{"source":"types.md","target":"types/cast.md"},{"source":"custom_types/enum/c_like.md","target":"types/cast.md"}]}}}');export{t as comp,r as data};
