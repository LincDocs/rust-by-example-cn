import{_ as i,e as l,k as e,f as s,g as p,i as c,h as d,r,o as t}from"./app-CVSWwIkE.js";const v={};function u(m,n){const a=r("RouteLink");return t(),l("div",null,[n[3]||(n[3]=e(`<h1 id="捕获" tabindex="-1"><a class="header-anchor" href="#捕获"><span>捕获</span></a></h1><p>闭包本质上很灵活，能做功能要求的事情，使闭包在没有类型标注的情况下运行。这使得捕获（capture）能够灵活地适应用例，既可移动（move），又可借用（borrow）。闭包可以通过以下方式捕获变量：</p><ul><li>通过引用：<code>&amp;T</code></li><li>通过可变引用：<code>&amp;mut T</code></li><li>通过值：<code>T</code></li></ul><p>闭包优先通过引用来捕获变量，并且仅在需要时使用其他方式。</p><div class="language-rust,editable line-numbers-mode" data-highlighter="shiki" data-ext="rust,editable" data-title="rust,editable" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>fn main() {</span></span>
<span class="line"><span>    use std::mem;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    let color = String::from(&quot;green&quot;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 这个闭包打印 \`color\`。它会立即借用（通过引用，\`&amp;\`）\`color\` 并将该借用和</span></span>
<span class="line"><span>    // 闭包本身存储到 \`print\` 变量中。\`color\` 会一直保持被借用状态直到</span></span>
<span class="line"><span>    // \`print\` 离开作用域。</span></span>
<span class="line"><span>    //</span></span>
<span class="line"><span>    // \`println!\` 只需传引用就能使用，而这个闭包捕获的也是变量的引用，因此无需</span></span>
<span class="line"><span>    // 进一步处理就可以使用 \`println!\`。</span></span>
<span class="line"><span>    let print = || println!(&quot;\`color\`: {}&quot;, color);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 使用借用来调用闭包 \`color\`。</span></span>
<span class="line"><span>    print();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // \`color\` 可再次被不可变借用，因为闭包只持有一个指向 \`color\` 的不可变引用。</span></span>
<span class="line"><span>    let _reborrow = &amp;color;</span></span>
<span class="line"><span>    print();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 在最后使用 \`print\` 之后，移动或重新借用都是允许的。</span></span>
<span class="line"><span>    let _color_moved = color;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    let mut count = 0;</span></span>
<span class="line"><span>    // 这个闭包使 \`count\` 值增加。要做到这点，它需要得到 \`&amp;mut count\` 或者</span></span>
<span class="line"><span>    // \`count\` 本身，但 \`&amp;mut count\` 的要求没那么严格，所以我们采取这种方式。</span></span>
<span class="line"><span>    // 该闭包立即借用 \`count\`。</span></span>
<span class="line"><span>    //</span></span>
<span class="line"><span>    // \`inc\` 前面需要加上 \`mut\`，因为闭包里存储着一个 \`&amp;mut\` 变量。调用闭包时，</span></span>
<span class="line"><span>    // 该变量的变化就意味着闭包内部发生了变化。因此闭包需要是可变的。</span></span>
<span class="line"><span>    let mut inc = || {</span></span>
<span class="line"><span>        count += 1;</span></span>
<span class="line"><span>        println!(&quot;\`count\`: {}&quot;, count);</span></span>
<span class="line"><span>    };</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 使用可变借用调用闭包</span></span>
<span class="line"><span>    inc();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 因为之后调用闭包，所以仍然可变借用 \`count\`</span></span>
<span class="line"><span>    // 试图重新借用将导致错误</span></span>
<span class="line"><span>    // let _reborrow = &amp;count;</span></span>
<span class="line"><span>    // ^ 试一试：将此行注释去掉。</span></span>
<span class="line"><span>    inc();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 闭包不再借用 \`&amp;mut count\`，因此可以正确地重新借用</span></span>
<span class="line"><span>    let _count_reborrowed = &amp;mut count;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 不可复制类型（non-copy type）。</span></span>
<span class="line"><span>    let movable = Box::new(3);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // \`mem::drop\` 要求 \`T\` 类型本身，所以闭包将会捕获变量的值。这种情况下，</span></span>
<span class="line"><span>    // 可复制类型将会复制给闭包，从而原始值不受影响。不可复制类型必须移动</span></span>
<span class="line"><span>    // （move）到闭包中，因而 \`movable\` 变量在这里立即移动到了闭包中。</span></span>
<span class="line"><span>    let consume = || {</span></span>
<span class="line"><span>        println!(&quot;\`movable\`: {:?}&quot;, movable);</span></span>
<span class="line"><span>        mem::drop(movable);</span></span>
<span class="line"><span>    };</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // \`consume\` 消耗了该变量，所以该闭包只能调用一次。</span></span>
<span class="line"><span>    consume();</span></span>
<span class="line"><span>    //consume();</span></span>
<span class="line"><span>    // ^ 试一试：将此行注释去掉。</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在竖线 <code>|</code> 之前使用 <code>move</code> 会强制闭包取得被捕获变量的所有权：</p><div class="language-rust,editable line-numbers-mode" data-highlighter="shiki" data-ext="rust,editable" data-title="rust,editable" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>fn main() {</span></span>
<span class="line"><span>    // \`Vec\` 在语义上是不可复制的。</span></span>
<span class="line"><span>    let haystack = vec![1, 2, 3];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    let contains = move |needle| haystack.contains(needle);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    println!(&quot;{}&quot;, contains(&amp;1));</span></span>
<span class="line"><span>    println!(&quot;{}&quot;, contains(&amp;4));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    //println!(&quot;There&#39;re {} elements in vec&quot;, haystack.len());</span></span>
<span class="line"><span>    // ^ 取消上面一行的注释将导致编译时错误，因为借用检查不允许在变量被移动走</span></span>
<span class="line"><span>    // 之后继续使用它。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 在闭包的签名中删除 \`move\` 会导致闭包以不可变方式借用 \`haystack\`，因此之后</span></span>
<span class="line"><span>    // \`haystack\` 仍然可用，取消上面的注释也不会导致错误。</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="参见" tabindex="-1"><a class="header-anchor" href="#参见"><span>参见：</span></a></h3>`,8)),s("p",null,[p(a,{to:"/std/box.html"},{default:d(()=>n[0]||(n[0]=[s("code",null,"Box",-1)])),_:1}),n[1]||(n[1]=c(" 和 ")),n[2]||(n[2]=s("a",{href:"https://rustwiki.org/zh-CN/std/mem/fn.drop.html",target:"_blank",rel:"noopener noreferrer"},[s("code",null,"std::mem::drop")],-1))])])}const b=i(v,[["render",u],["__file","capture.html.vue"]]),h=JSON.parse('{"path":"/fn/closures/capture.html","title":"捕获","lang":"zh-CN","frontmatter":{"description":"捕获 闭包本质上很灵活，能做功能要求的事情，使闭包在没有类型标注的情况下运行。这使得捕获（capture）能够灵活地适应用例，既可移动（move），又可借用（borrow）。闭包可以通过以下方式捕获变量： 通过引用：&T 通过可变引用：&mut T 通过值：T 闭包优先通过引用来捕获变量，并且仅在需要时使用其他方式。 在竖线 | 之前使用 move 会...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/rust-by-example-cn-/fn/closures/capture.html"}],["meta",{"property":"og:site_name","content":"rust-by-example-cn-"}],["meta",{"property":"og:title","content":"捕获"}],["meta",{"property":"og:description","content":"捕获 闭包本质上很灵活，能做功能要求的事情，使闭包在没有类型标注的情况下运行。这使得捕获（capture）能够灵活地适应用例，既可移动（move），又可借用（borrow）。闭包可以通过以下方式捕获变量： 通过引用：&T 通过可变引用：&mut T 通过值：T 闭包优先通过引用来捕获变量，并且仅在需要时使用其他方式。 在竖线 | 之前使用 move 会..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"捕获\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/rust-by-example-cn-/\\"}]}"]]},"git":{},"readingTime":{"minutes":2.74,"words":821},"filePathRelative":"fn/closures/capture.md","excerpt":"\\n<p>闭包本质上很灵活，能做功能要求的事情，使闭包在没有类型标注的情况下运行。这使得捕获（capture）能够灵活地适应用例，既可移动（move），又可借用（borrow）。闭包可以通过以下方式捕获变量：</p>\\n<ul>\\n<li>通过引用：<code>&amp;T</code></li>\\n<li>通过可变引用：<code>&amp;mut T</code></li>\\n<li>通过值：<code>T</code></li>\\n</ul>\\n<p>闭包优先通过引用来捕获变量，并且仅在需要时使用其他方式。</p>\\n<div class=\\"language-rust,editable line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"rust,editable\\" data-title=\\"rust,editable\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>fn main() {</span></span>\\n<span class=\\"line\\"><span>    use std::mem;</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    let color = String::from(\\"green\\");</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    // 这个闭包打印 `color`。它会立即借用（通过引用，`&amp;`）`color` 并将该借用和</span></span>\\n<span class=\\"line\\"><span>    // 闭包本身存储到 `print` 变量中。`color` 会一直保持被借用状态直到</span></span>\\n<span class=\\"line\\"><span>    // `print` 离开作用域。</span></span>\\n<span class=\\"line\\"><span>    //</span></span>\\n<span class=\\"line\\"><span>    // `println!` 只需传引用就能使用，而这个闭包捕获的也是变量的引用，因此无需</span></span>\\n<span class=\\"line\\"><span>    // 进一步处理就可以使用 `println!`。</span></span>\\n<span class=\\"line\\"><span>    let print = || println!(\\"`color`: {}\\", color);</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    // 使用借用来调用闭包 `color`。</span></span>\\n<span class=\\"line\\"><span>    print();</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    // `color` 可再次被不可变借用，因为闭包只持有一个指向 `color` 的不可变引用。</span></span>\\n<span class=\\"line\\"><span>    let _reborrow = &amp;color;</span></span>\\n<span class=\\"line\\"><span>    print();</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    // 在最后使用 `print` 之后，移动或重新借用都是允许的。</span></span>\\n<span class=\\"line\\"><span>    let _color_moved = color;</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    let mut count = 0;</span></span>\\n<span class=\\"line\\"><span>    // 这个闭包使 `count` 值增加。要做到这点，它需要得到 `&amp;mut count` 或者</span></span>\\n<span class=\\"line\\"><span>    // `count` 本身，但 `&amp;mut count` 的要求没那么严格，所以我们采取这种方式。</span></span>\\n<span class=\\"line\\"><span>    // 该闭包立即借用 `count`。</span></span>\\n<span class=\\"line\\"><span>    //</span></span>\\n<span class=\\"line\\"><span>    // `inc` 前面需要加上 `mut`，因为闭包里存储着一个 `&amp;mut` 变量。调用闭包时，</span></span>\\n<span class=\\"line\\"><span>    // 该变量的变化就意味着闭包内部发生了变化。因此闭包需要是可变的。</span></span>\\n<span class=\\"line\\"><span>    let mut inc = || {</span></span>\\n<span class=\\"line\\"><span>        count += 1;</span></span>\\n<span class=\\"line\\"><span>        println!(\\"`count`: {}\\", count);</span></span>\\n<span class=\\"line\\"><span>    };</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    // 使用可变借用调用闭包</span></span>\\n<span class=\\"line\\"><span>    inc();</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    // 因为之后调用闭包，所以仍然可变借用 `count`</span></span>\\n<span class=\\"line\\"><span>    // 试图重新借用将导致错误</span></span>\\n<span class=\\"line\\"><span>    // let _reborrow = &amp;count;</span></span>\\n<span class=\\"line\\"><span>    // ^ 试一试：将此行注释去掉。</span></span>\\n<span class=\\"line\\"><span>    inc();</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    // 闭包不再借用 `&amp;mut count`，因此可以正确地重新借用</span></span>\\n<span class=\\"line\\"><span>    let _count_reborrowed = &amp;mut count;</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    // 不可复制类型（non-copy type）。</span></span>\\n<span class=\\"line\\"><span>    let movable = Box::new(3);</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    // `mem::drop` 要求 `T` 类型本身，所以闭包将会捕获变量的值。这种情况下，</span></span>\\n<span class=\\"line\\"><span>    // 可复制类型将会复制给闭包，从而原始值不受影响。不可复制类型必须移动</span></span>\\n<span class=\\"line\\"><span>    // （move）到闭包中，因而 `movable` 变量在这里立即移动到了闭包中。</span></span>\\n<span class=\\"line\\"><span>    let consume = || {</span></span>\\n<span class=\\"line\\"><span>        println!(\\"`movable`: {:?}\\", movable);</span></span>\\n<span class=\\"line\\"><span>        mem::drop(movable);</span></span>\\n<span class=\\"line\\"><span>    };</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    // `consume` 消耗了该变量，所以该闭包只能调用一次。</span></span>\\n<span class=\\"line\\"><span>    consume();</span></span>\\n<span class=\\"line\\"><span>    //consume();</span></span>\\n<span class=\\"line\\"><span>    // ^ 试一试：将此行注释去掉。</span></span>\\n<span class=\\"line\\"><span>}</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true,"bioChainData":{"outlink":[{"title":"box","link":"std/box.html"}],"backlink":[{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"fn/closures/capture.md","value":{"title":"capture","path":"fn/closures/capture.md","outlink":["std/box.md"],"backlink":["SUMMARY.md"]}},{"id":"std/box.md","value":{"title":"box","path":"std/box.md","outlink":[],"backlink":[]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"fn/closures/capture.md","target":"std/box.md"},{"source":"SUMMARY.md","target":"fn/closures/capture.md"}]}}}');export{b as comp,h as data};
