import{_ as s,e as a,k as e,o as i}from"./app-CY03Lsxp.js";const p={};function l(o,n){return i(),a("div",null,n[0]||(n[0]=[e(`<h1 id="option-和-unwrap" tabindex="-1"><a class="header-anchor" href="#option-和-unwrap"><span><code>Option</code> 和 <code>unwrap</code></span></a></h1><p>上个例子展示了如何主动地引入程序失败（program failure）。当公主收到蛇这件不合适的礼物时，我们就让程序 <code>panic</code>。但是，如果公主期待收到礼物，却没收到呢？这同样是一件糟糕的事情，所以我们要想办法来解决这个问题！</p><p>我们<strong>可以</strong>检查空字符串（<code>&quot;&quot;</code>），就像处理蛇那样。但既然我们在用 Rust，不如让编译器辨别没有礼物的情况。</p><p>在标准库（<code>std</code>）中有个叫做 <code>Option&lt;T&gt;</code>（option 中文意思是 “选项”）的枚举类型，用于有 “不存在” 的可能性的情况。它表现为以下两个 “option”（选项）中的一个：</p><ul><li><code>Some(T)</code>：找到一个属于 <code>T</code> 类型的元素</li><li><code>None</code>：找不到相应元素</li></ul><p>这些选项可以通过 <code>match</code> 显式地处理，或使用 <code>unwrap</code> 隐式地处理。隐式处理要么返回 <code>Some</code> 内部的元素，要么就 <code>panic</code>。</p><p>请注意，手动使用 <a href="https://rustwiki.org/zh-CN/std/option/enum.Option.html#method.expect" target="_blank" rel="noopener noreferrer">expect</a> 方法自定义 <code>panic</code> 信息是可能的，但相比显式处理，<code>unwrap</code> 的输出仍显得不太有意义。在下面例子中，显式处理将举出更受控制的结果，同时如果需要的话，仍然可以使程序 <code>panic</code>。</p><div class="language-rust,editable,ignore,mdbook-runnable line-numbers-mode" data-highlighter="shiki" data-ext="rust,editable,ignore,mdbook-runnable" data-title="rust,editable,ignore,mdbook-runnable" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// 平民（commoner）们见多识广，收到什么礼物都能应对。</span></span>
<span class="line"><span>// 所有礼物都显式地使用 \`match\` 来处理。</span></span>
<span class="line"><span>fn give_commoner(gift: Option&lt;&amp;str&gt;) {</span></span>
<span class="line"><span>    // 指出每种情况下的做法。</span></span>
<span class="line"><span>    match gift {</span></span>
<span class="line"><span>        Some(&quot;snake&quot;) =&gt; println!(&quot;Yuck! I&#39;m throwing that snake in a fire.&quot;),</span></span>
<span class="line"><span>        Some(inner)   =&gt; println!(&quot;{}? How nice.&quot;, inner),</span></span>
<span class="line"><span>        None          =&gt; println!(&quot;No gift? Oh well.&quot;),</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 养在深闺人未识的公主见到蛇就会 \`panic\`（恐慌）。</span></span>
<span class="line"><span>// 这里所有的礼物都使用 \`unwrap\` 隐式地处理。</span></span>
<span class="line"><span>fn give_princess(gift: Option&lt;&amp;str&gt;) {</span></span>
<span class="line"><span>    // \`unwrap\` 在接收到 \`None\` 时将返回 \`panic\`。</span></span>
<span class="line"><span>    let inside = gift.unwrap();</span></span>
<span class="line"><span>    if inside == &quot;snake&quot; { panic!(&quot;AAAaaaaa!!!!&quot;); }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    println!(&quot;I love {}s!!!!!&quot;, inside);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>fn main() {</span></span>
<span class="line"><span>    let food  = Some(&quot;chicken&quot;);</span></span>
<span class="line"><span>    let snake = Some(&quot;snake&quot;);</span></span>
<span class="line"><span>    let void  = None;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    give_commoner(food);</span></span>
<span class="line"><span>    give_commoner(snake);</span></span>
<span class="line"><span>    give_commoner(void);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    let bird = Some(&quot;robin&quot;);</span></span>
<span class="line"><span>    let nothing = None;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    give_princess(bird);</span></span>
<span class="line"><span>    give_princess(nothing);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,8)]))}const r=s(p,[["render",l],["__file","option_unwrap.html.vue"]]),c=JSON.parse('{"path":"/error/option_unwrap.html","title":"Option 和 unwrap","lang":"zh-CN","frontmatter":{"description":"Option 和 unwrap 上个例子展示了如何主动地引入程序失败（program failure）。当公主收到蛇这件不合适的礼物时，我们就让程序 panic。但是，如果公主期待收到礼物，却没收到呢？这同样是一件糟糕的事情，所以我们要想办法来解决这个问题！ 我们可以检查空字符串（\\"\\"），就像处理蛇那样。但既然我们在用 Rust，不如让编译器辨别没有礼...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/rust-by-example-cn/error/option_unwrap.html"}],["meta",{"property":"og:site_name","content":"rust-by-example-cn"}],["meta",{"property":"og:title","content":"Option 和 unwrap"}],["meta",{"property":"og:description","content":"Option 和 unwrap 上个例子展示了如何主动地引入程序失败（program failure）。当公主收到蛇这件不合适的礼物时，我们就让程序 panic。但是，如果公主期待收到礼物，却没收到呢？这同样是一件糟糕的事情，所以我们要想办法来解决这个问题！ 我们可以检查空字符串（\\"\\"），就像处理蛇那样。但既然我们在用 Rust，不如让编译器辨别没有礼..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Option 和 unwrap\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/rust-by-example-cn/\\"}]}"]]},"git":{},"readingTime":{"minutes":1.67,"words":502},"filePathRelative":"error/option_unwrap.md","excerpt":"\\n<p>上个例子展示了如何主动地引入程序失败（program failure）。当公主收到蛇这件不合适的礼物时，我们就让程序 <code>panic</code>。但是，如果公主期待收到礼物，却没收到呢？这同样是一件糟糕的事情，所以我们要想办法来解决这个问题！</p>\\n<p>我们<strong>可以</strong>检查空字符串（<code>\\"\\"</code>），就像处理蛇那样。但既然我们在用 Rust，不如让编译器辨别没有礼物的情况。</p>\\n<p>在标准库（<code>std</code>）中有个叫做 <code>Option&lt;T&gt;</code>（option 中文意思是 “选项”）的枚举类型，用于有 “不存在” 的可能性的情况。它表现为以下两个 “option”（选项）中的一个：</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"error/option_unwrap.md","value":{"title":"option_unwrap","path":"error/option_unwrap.md","outlink":[],"backlink":["SUMMARY.md"]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"SUMMARY.md","target":"error/option_unwrap.md"}]}}}');export{r as comp,c as data};
