import{_ as l,e as p,k as d,f as i,g as a,i as n,h as t,r,o}from"./app-CVSWwIkE.js";const c={};function u(m,s){const e=r("RouteLink");return o(),p("div",null,[s[17]||(s[17]=d('<h1 id="测试实例-单位说明" tabindex="-1"><a class="header-anchor" href="#测试实例-单位说明"><span>测试实例：单位说明</span></a></h1><p>通过实现一个带虚类型参数的 <code>Add</code> trait 可以实现单位检查。这种 <code>Add</code> trait 的代码如下：</p><div class="language-rust,ignore line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore" data-title="rust,ignore" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// 这个 `trait` 会要求 `Self + RHS = Output`。`&lt;RHS = Self&gt;` 表示 RHS 的默认值</span></span>\n<span class="line"><span>// 为 Self 类型，也就是如果没有在实现中另行指定，RHS 就取 Self 类型。</span></span>\n<span class="line"><span>pub trait Add&lt;RHS = Self&gt; {</span></span>\n<span class="line"><span>    type Output;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    fn add(self, rhs: RHS) -&gt; Self::Output;</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>// `Output` 必须是 `T&lt;U&gt;` 类型，所以是 `T&lt;U&gt; + T&lt;U&gt; = T&lt;U&gt;`。</span></span>\n<span class="line"><span>impl&lt;U&gt; Add for T&lt;U&gt; {</span></span>\n<span class="line"><span>    type Output = T&lt;U&gt;;</span></span>\n<span class="line"><span>    ...</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>完整实现：</p><div class="language-rust,editable line-numbers-mode" data-highlighter="shiki" data-ext="rust,editable" data-title="rust,editable" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>use std::ops::Add;</span></span>\n<span class="line"><span>use std::marker::PhantomData;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>/// 创建空枚举类型来表示单位。</span></span>\n<span class="line"><span>#[derive(Debug, Clone, Copy)]</span></span>\n<span class="line"><span>enum Inch {}</span></span>\n<span class="line"><span>#[derive(Debug, Clone, Copy)]</span></span>\n<span class="line"><span>enum Mm {}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>/// `Length` 是一个带有虚类型参数 `Unit` 的类型，</span></span>\n<span class="line"><span>/// 而且对于表示长度的类型（即 `f64`）而言，`Length` 不是泛型的。</span></span>\n<span class="line"><span>///</span></span>\n<span class="line"><span>/// `f64` 已经实现了 `Clone` 和 `Copy` trait.</span></span>\n<span class="line"><span>#[derive(Debug, Clone, Copy)]</span></span>\n<span class="line"><span>struct Length&lt;Unit&gt;(f64, PhantomData&lt;Unit&gt;);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>/// `Add` trait 定义了 `+` 运算符的行为。</span></span>\n<span class="line"><span>impl&lt;Unit&gt; Add for Length&lt;Unit&gt; {</span></span>\n<span class="line"><span>     type Output = Length&lt;Unit&gt;;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    // add() 返回一个含有和的新的 `Length` 结构体。</span></span>\n<span class="line"><span>    fn add(self, rhs: Length&lt;Unit&gt;) -&gt; Length&lt;Unit&gt; {</span></span>\n<span class="line"><span>        // `+` 调用了针对 `f64` 类型的 `Add` 实现。</span></span>\n<span class="line"><span>        Length(self.0 + rhs.0, PhantomData)</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>fn main() {</span></span>\n<span class="line"><span>    // 指定 `one_foot` 拥有虚类型参数 `Inch`。</span></span>\n<span class="line"><span>    let one_foot:  Length&lt;Inch&gt; = Length(12.0, PhantomData);</span></span>\n<span class="line"><span>    // `one_meter` 拥有虚类型参数 `Mm`。</span></span>\n<span class="line"><span>    let one_meter: Length&lt;Mm&gt;   = Length(1000.0, PhantomData);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    // `+` 调用了我们对 `Length&lt;Unit&gt;` 实现的 `add()` 方法。</span></span>\n<span class="line"><span>    //</span></span>\n<span class="line"><span>    // 由于 `Length` 了实现了 `Copy`，`add()` 不会消耗 `one_foot`</span></span>\n<span class="line"><span>    // 和 `one_meter`，而是复制它们作为 `self` 和 `rhs`。</span></span>\n<span class="line"><span>    let two_feet = one_foot + one_foot;</span></span>\n<span class="line"><span>    let two_meters = one_meter + one_meter;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    // 加法正常执行。</span></span>\n<span class="line"><span>    println!(&quot;one foot + one_foot = {:?} in&quot;, two_feet.0);</span></span>\n<span class="line"><span>    println!(&quot;one meter + one_meter = {:?} mm&quot;, two_meters.0);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    // 无意义的运算当然会失败：</span></span>\n<span class="line"><span>    // 编译期错误：类型不匹配。</span></span>\n<span class="line"><span>    //let one_feter = one_foot + one_meter;</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="参见" tabindex="-1"><a class="header-anchor" href="#参见"><span>参见：</span></a></h3>',6)),i("p",null,[a(e,{to:"/scope/borrow.html"},{default:t(()=>s[0]||(s[0]=[n("Borrowing ("),i("code",null,"&",-1),n(")")])),_:1}),s[8]||(s[8]=n(", ")),a(e,{to:"/generics/bounds.html"},{default:t(()=>s[1]||(s[1]=[n("Bounds ("),i("code",null,"X: Y",-1),n(")")])),_:1}),s[9]||(s[9]=n(", ")),a(e,{to:"/custom_types/enum.html"},{default:t(()=>s[2]||(s[2]=[n("enum")])),_:1}),s[10]||(s[10]=n(", ")),a(e,{to:"/fn/methods.html"},{default:t(()=>s[3]||(s[3]=[n("impl & self")])),_:1}),s[11]||(s[11]=n(",")),s[12]||(s[12]=i("br",null,null,-1)),a(e,{to:"/trait/ops.html"},{default:t(()=>s[4]||(s[4]=[n("Overloading")])),_:1}),s[13]||(s[13]=n(", ")),a(e,{to:"/scope/borrow/ref.html"},{default:t(()=>s[5]||(s[5]=[n("ref")])),_:1}),s[14]||(s[14]=n(", ")),a(e,{to:"/trait.html"},{default:t(()=>s[6]||(s[6]=[n("Traits ("),i("code",null,"X for Y",-1),n(")")])),_:1}),s[15]||(s[15]=n(", 和 ")),a(e,{to:"/custom_types/structs.html"},{default:t(()=>s[7]||(s[7]=[n("TupleStructs")])),_:1}),s[16]||(s[16]=n("."))])])}const b=l(c,[["render",u],["__file","testcase_units.html.vue"]]),g=JSON.parse('{"path":"/generics/phantom/testcase_units.html","title":"测试实例：单位说明","lang":"zh-CN","frontmatter":{"description":"测试实例：单位说明 通过实现一个带虚类型参数的 Add trait 可以实现单位检查。这种 Add trait 的代码如下： 完整实现： 参见： , , , , , , , 和 .","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/rust-by-example-cn-/generics/phantom/testcase_units.html"}],["meta",{"property":"og:site_name","content":"rust-by-example-cn-"}],["meta",{"property":"og:title","content":"测试实例：单位说明"}],["meta",{"property":"og:description","content":"测试实例：单位说明 通过实现一个带虚类型参数的 Add trait 可以实现单位检查。这种 Add trait 的代码如下： 完整实现： 参见： , , , , , , , 和 ."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"测试实例：单位说明\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/rust-by-example-cn-/\\"}]}"]]},"git":{},"readingTime":{"minutes":1.58,"words":475},"filePathRelative":"generics/phantom/testcase_units.md","excerpt":"\\n<p>通过实现一个带虚类型参数的 <code>Add</code> trait 可以实现单位检查。这种 <code>Add</code> trait 的代码如下：</p>\\n<div class=\\"language-rust,ignore line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"rust,ignore\\" data-title=\\"rust,ignore\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>// 这个 `trait` 会要求 `Self + RHS = Output`。`&lt;RHS = Self&gt;` 表示 RHS 的默认值</span></span>\\n<span class=\\"line\\"><span>// 为 Self 类型，也就是如果没有在实现中另行指定，RHS 就取 Self 类型。</span></span>\\n<span class=\\"line\\"><span>pub trait Add&lt;RHS = Self&gt; {</span></span>\\n<span class=\\"line\\"><span>    type Output;</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    fn add(self, rhs: RHS) -&gt; Self::Output;</span></span>\\n<span class=\\"line\\"><span>}</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>// `Output` 必须是 `T&lt;U&gt;` 类型，所以是 `T&lt;U&gt; + T&lt;U&gt; = T&lt;U&gt;`。</span></span>\\n<span class=\\"line\\"><span>impl&lt;U&gt; Add for T&lt;U&gt; {</span></span>\\n<span class=\\"line\\"><span>    type Output = T&lt;U&gt;;</span></span>\\n<span class=\\"line\\"><span>    ...</span></span>\\n<span class=\\"line\\"><span>}</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true,"bioChainData":{"outlink":[{"title":"borrow","link":"scope/borrow.html"},{"title":"bounds","link":"generics/bounds.html"},{"title":"enum","link":"custom_types/enum.html"},{"title":"methods","link":"fn/methods.html"},{"title":"ops","link":"trait/ops.html"},{"title":"ref","link":"scope/borrow/ref.html"},{"title":"trait","link":"trait.html"},{"title":"structs","link":"custom_types/structs.html"}],"backlink":[{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"generics/phantom/testcase_units.md","value":{"title":"testcase_units","path":"generics/phantom/testcase_units.md","outlink":["scope/borrow.md","generics/bounds.md","custom_types/enum.md","fn/methods.md","trait/ops.md","scope/borrow/ref.md","trait.md","custom_types/structs.md"],"backlink":["SUMMARY.md"]}},{"id":"scope/borrow.md","value":{"title":"borrow","path":"scope/borrow.md","outlink":[],"backlink":[]}},{"id":"generics/bounds.md","value":{"title":"bounds","path":"generics/bounds.md","outlink":[],"backlink":[]}},{"id":"custom_types/enum.md","value":{"title":"enum","path":"custom_types/enum.md","outlink":[],"backlink":[]}},{"id":"fn/methods.md","value":{"title":"methods","path":"fn/methods.md","outlink":[],"backlink":[]}},{"id":"trait/ops.md","value":{"title":"ops","path":"trait/ops.md","outlink":[],"backlink":[]}},{"id":"scope/borrow/ref.md","value":{"title":"ref","path":"scope/borrow/ref.md","outlink":[],"backlink":[]}},{"id":"trait.md","value":{"title":"trait","path":"trait.md","outlink":[],"backlink":[]}},{"id":"custom_types/structs.md","value":{"title":"structs","path":"custom_types/structs.md","outlink":[],"backlink":[]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"generics/phantom/testcase_units.md","target":"scope/borrow.md"},{"source":"generics/phantom/testcase_units.md","target":"generics/bounds.md"},{"source":"generics/phantom/testcase_units.md","target":"custom_types/enum.md"},{"source":"generics/phantom/testcase_units.md","target":"fn/methods.md"},{"source":"generics/phantom/testcase_units.md","target":"trait/ops.md"},{"source":"generics/phantom/testcase_units.md","target":"scope/borrow/ref.md"},{"source":"generics/phantom/testcase_units.md","target":"trait.md"},{"source":"generics/phantom/testcase_units.md","target":"custom_types/structs.md"},{"source":"SUMMARY.md","target":"generics/phantom/testcase_units.md"}]}}}');export{b as comp,g as data};
