[...new Array(6)].map((e,t)=>`[vp-content] h${t+1}`).join(",");const{entries:$}=Object,{fromEntries:st}=Object,nt="ENTRIES",D="KEYS",W="VALUES",_="";class S{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=b(this._path);if(b(s)===_)return{done:!1,value:this.result()};const n=t.get(b(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=b(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>b(t)).filter(t=>t!==_).join("")}value(){return b(this._path).node.get(_)}result(){switch(this._type){case W:return this.value();case D:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const b=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(typeof t!="string")return n;const o=t.length+1,r=o+s,i=new Uint8Array(r*o).fill(s+1);for(let c=0;c<o;++c)i[c]=c;for(let c=1;c<r;++c)i[c*o]=c;return q(e,t,s,n,i,1,o,""),n},q=(e,t,s,n,o,r,i,c)=>{const l=r*i;t:for(const u of e.keys())if(u===_){const h=o[l-1];h<=s&&n.set(c,[e.get(u),h])}else{let h=r;for(let f=0;f<u.length;++f,++h){const m=u[f],g=i*h,y=g-i;let d=o[g];const a=Math.max(0,h-s-1),w=Math.min(i-1,h+s);for(let p=a;p<w;++p){const O=m!==t[p],C=o[y+p]+ +O,k=o[y+p+1]+1,x=o[g+p]+1,v=o[g+p+1]=Math.min(C,k,x);v<d&&(d=v)}if(d>s)continue t}q(e.get(u),t,s,n,o,h,i,c+u)}};class z{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=I(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,r]=L(n);for(const i of o.keys())if(i!==_&&i.startsWith(r)){const c=new Map;return c.set(i.slice(r.length),o.get(i)),new z(c,t)}}return new z(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,rt(this._tree,t)}entries(){return new S(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=F(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){return F(this._tree,t)?.has(_)??!1}keys(){return new S(this,D)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,E(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=E(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=E(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new S(this,W)}[Symbol.iterator](){return this.entries()}static from(t){const s=new z;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return z.from(Object.entries(t))}}const I=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),I(e.get(n),t.slice(n.length),s);return s.push([e,t]),I(void 0,"",s)},F=(e,t)=>{if(t.length===0||!e)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return F(e.get(s),t.slice(s.length))},E=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const r of e.keys())if(r!==_&&t[n]===r[0]){const i=Math.min(s-n,r.length);let c=1;for(;c<i&&t[n+c]===r[c];)++c;const l=e.get(r);if(c===r.length)e=l;else{const u=new Map;u.set(r.slice(c),l),e.set(t.slice(n,n+c),u),e.delete(r),e=u}n+=c;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},rt=(e,t)=>{const[s,n]=I(e,t);if(s!==void 0){if(s.delete(_),s.size===0)A(n);else if(s.size===1){const[o,r]=s.entries().next().value;R(n,o,r)}}},A=e=>{if(e.length===0)return;const[t,s]=L(e);if(t.delete(s),t.size===0)A(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&R(e.slice(0,-1),n,o)}},R=(e,t,s)=>{if(e.length===0)return;const[n,o]=L(e);n.set(o+t,s),n.delete(o)},L=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},ct=/[\n\r\p{Z}\p{P}]+/u,j="or",N="and",ut="and_not",ht=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},B=({score:e},{score:t})=>t-e,lt=()=>new Map,M=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,H={[j]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:r,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,r)}}return e},[N]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:r,terms:i,match:c}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+r,terms:o.terms,match:Object.assign(o.match,c)})}return s},[ut]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,r)=>{const{k:i,b:c,d:l}=r;return Math.log(1+(s-t+.5)/(t+.5))*(l+e*(i+1)/(e+i*(1-c+c*n/o)))},at=e=>(t,s,n)=>({term:t,fuzzy:typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy??!1,prefix:typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0,termBoost:typeof e.boostTerm=="function"?e.boostTerm(t,s,n):1}),J=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){J(e,s,t,n);return}const o=e._index.fetch(n,lt),r=o.get(t),i=r?.get(s);!r||typeof i>"u"?J(e,s,t,n):i<=1?r.size<=1?o.delete(t):r.delete(s):r.set(s,i-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},gt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(ct),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{console?.[e]?.(t)},autoVacuum:!0},Y={combineWith:j,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},pt={combineWith:N,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},K={minDirtFactor:.1,minDirtCount:20},yt={..._t,...K},U=Symbol("*"),wt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,r]of e._documentIds){const i=n.boostDocument?n.boostDocument(r,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},Q=(e,t=j)=>{if(e.length===0)return new Map;const s=t.toLowerCase();if(!(s in H))throw new Error(`Invalid combination operator: ${t}`);return e.reduce(H[s])},T=(e,t,s,n,o,r,i,c,l,u=new Map)=>{if(r==null)return u;for(const h of Object.keys(i)){const f=i[h],m=e._fieldIds[h],g=r.get(m);if(g==null)continue;let y=g.size;const d=e._avgFieldLength[m];for(const a of g.keys()){if(!e._documentIds.has(a)){ft(e,m,a,s),y-=1;continue}const w=c?c(e._documentIds.get(a),s,e._storedFields.get(a)):1;if(!w)continue;const p=g.get(a),O=e._fieldLength.get(a)[m],C=dt(p,y,e._documentCount,O,d,l),k=n*o*f*w*C,x=u.get(a);if(x){x.score+=k,ht(x.terms,t);const v=G(x.match,s);v?v.push(h):x.match[s]=[h]}else u.set(a,{score:k,terms:[t],match:{[s]:[h]}})}}return u},xt=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields??e._options.fields).reduce((d,a)=>({...d,[a]:G(n.boost,a)||1}),{}),{boostDocument:r,weights:i,maxFuzzy:c,bm25:l}=n,{fuzzy:u,prefix:h}={...Y.weights,...i},f=e._index.get(t.term),m=T(e,t.term,t.term,1,t.termBoost,f,o,r,l);let g,y;if(t.prefix&&(g=e._index.atPrefix(t.term)),t.fuzzy){const d=t.fuzzy===!0?.2:t.fuzzy,a=d<1?Math.min(c,Math.round(t.term.length*d)):d;a&&(y=e._index.fuzzyGet(t.term,a))}if(g)for(const[d,a]of g){const w=d.length-t.term.length;if(!w)continue;y?.delete(d);const p=h*d.length/(d.length+.3*w);T(e,t.term,d,p,t.termBoost,a,o,r,l,m)}if(y)for(const d of y.keys()){const[a,w]=y.get(d);if(!w)continue;const p=u*d.length/(d.length+w);T(e,t.term,d,p,t.termBoost,a,o,r,l,m)}return m},X=(e,t,s={})=>{if(t===U)return wt(e,s);if(typeof t!="string"){const h={...s,...t,queries:void 0},f=t.queries.map(m=>X(e,m,h));return Q(f,h.combineWith)}const{tokenize:n,processTerm:o,searchOptions:r}=e._options,i={tokenize:n,processTerm:o,...r,...s},{tokenize:c,processTerm:l}=i,u=c(t).flatMap(h=>l(h)).filter(h=>!!h).map(at(i)).map(h=>xt(e,h,i));return Q(u,i.combineWith)},Z=(e,t,s={})=>{const{searchOptions:n}=e._options,o={...n,...s},r=X(e,t,s),i=[];for(const[c,{score:l,terms:u,match:h}]of r){const f=u.length||1,m={id:e._documentIds.get(c),score:l*f,terms:Object.keys(h),queryTerms:u,match:h};Object.assign(m,e._storedFields.get(c)),(o.filter==null||o.filter(m))&&i.push(m)}return t===U&&o.boostDocument==null||i.sort(B),i},zt=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:r,terms:i}of Z(e,t,s)){const c=i.join(" "),l=n.get(c);l!=null?(l.score+=r,l.count+=1):n.set(c,{score:r,terms:i,count:1})}const o=[];for(const[r,{score:i,terms:c,count:l}]of n)o.push({suggestion:r,terms:c,score:i/l});return o.sort(B),o};class bt{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(!t?.fields)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...gt,...t,autoVacuum:s,searchOptions:{...Y,...t.searchOptions},autoSuggestOptions:{...pt,...t.autoSuggestOptions}},this._index=new z,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=K,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[r,i]of n)o[r]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,version:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const vt=e=>new bt(e),kt=({documentCount:e,nextId:t,fieldIds:s,averageFieldLength:n,dirtCount:o,version:r},i)=>{if(r!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const c=vt(i);return c._documentCount=e,c._nextId=t,c._idToShortId=new Map,c._fieldIds=s,c._avgFieldLength=n,c._dirtCount=o??0,c._index=new z,c},It=(e,t)=>{const{index:s,documentIds:n,fieldLength:o,storedFields:r}=e,i=kt(e,t);i._documentIds=M(n),i._fieldLength=M(o),i._storedFields=M(r);for(const[c,l]of i._documentIds)i._idToShortId.set(l,c);for(const[c,l]of s){const u=new Map;for(const h of Object.keys(l))u.set(parseInt(h,10),M(l[h]));i._index.set(c,u)}return i},V=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let r=0,i=0;const c=(u,h=!1)=>{let f;i===0?f=u.length>20?`… ${u.slice(-20)}`:u:h?f=u.length+i>100?`${u.slice(0,100-i)}… `:u:f=u.length>20?`${u.slice(0,20)} … ${u.slice(-20)}`:u,f&&o.push(f),i+=f.length,h||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let l=s.indexOf(n,r);if(l===-1)return null;for(;l>=0;){const u=l+n.length;if(c(e.slice(r,l)),r=u,i>100)break;l=s.indexOf(n,r)}return i<100&&c(e.slice(r),!0),o},Mt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),Ot=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),tt=(e,t,s={})=>{const n={};return Z(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:r,terms:i,score:c}=o,l=r.includes("@"),u=r.includes("#"),[h,f]=r.split(/[#@]/),m=Number(h),g=i.sort((d,a)=>d.length-a.length).filter((d,a)=>i.slice(a+1).every(w=>!w.includes(d))),{contents:y}=n[m]??={title:"",contents:[]};if(l)y.push([{type:"customField",id:m,index:f,display:g.map(d=>o.c.map(a=>V(a,d))).flat().filter(d=>d!==null)},c]);else{const d=g.map(a=>V(o.h,a)).filter(a=>a!==null);if(d.length&&y.push([{type:u?"heading":"title",id:m,...u&&{anchor:f},display:d},c]),"t"in o&&o.t)for(const a of o.t){const w=g.map(p=>V(a,p)).filter(p=>p!==null);w.length&&y.push([{type:"text",id:m,...u&&{anchor:f},display:w},c])}}}),$(n).sort(([,o],[,r])=>"max"==="total"?Mt(o,r):Ot(o,r)).map(([o,{title:r,contents:i}])=>{if(!r){const c=it(t,o);c&&(r=c.h)}return{title:r,contents:i.map(([c])=>c)}})},et=(e,t,s={})=>{const n=zt(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},Ct=st($(JSON.parse("{\"/\":{\"documentCount\":360,\"nextId\":360,\"documentIds\":{\"0\":\"0\",\"1\":\"1\",\"2\":\"2\",\"3\":\"3\",\"4\":\"4\",\"5\":\"5\",\"6\":\"6\",\"7\":\"7\",\"8\":\"8\",\"9\":\"9\",\"10\":\"10\",\"11\":\"11\",\"12\":\"11#参见\",\"13\":\"12\",\"14\":\"12#动手试一试\",\"15\":\"13\",\"16\":\"14\",\"17\":\"15\",\"18\":\"16\",\"19\":\"17\",\"20\":\"17#标量类型-scalar-type\",\"21\":\"17#复合类型-compound-type\",\"22\":\"17#参见\",\"23\":\"18\",\"24\":\"19\",\"25\":\"19#参见\",\"26\":\"20\",\"27\":\"20#参见\",\"28\":\"21\",\"29\":\"21#参见\",\"30\":\"22\",\"31\":\"23\",\"32\":\"24\",\"33\":\"24#原始指针\",\"34\":\"24#调用不安全函数\",\"35\":\"25\",\"36\":\"26\",\"37\":\"26#参见\",\"38\":\"27\",\"39\":\"28\",\"40\":\"29\",\"41\":\"30\",\"42\":\"30#怎么使用构建脚本\",\"43\":\"31\",\"44\":\"32\",\"45\":\"33\",\"46\":\"34\",\"47\":\"34#from\",\"48\":\"34#into\",\"49\":\"35\",\"50\":\"35#tostring\",\"51\":\"35#解析字符串\",\"52\":\"36\",\"53\":\"37\",\"54\":\"38\",\"55\":\"39\",\"56\":\"39#参见\",\"57\":\"40\",\"58\":\"40#类型别名\",\"59\":\"40#参见\",\"60\":\"41\",\"61\":\"41#动手试一试\",\"62\":\"41#参见\",\"63\":\"42\",\"64\":\"42#使用-filter-map-忽略失败的项\",\"65\":\"42#使用-collect-使整个操作失败\",\"66\":\"42#使用-partition-收集所有合法的值与错误\",\"67\":\"43\",\"68\":\"44\",\"69\":\"45\",\"70\":\"46\",\"71\":\"47\",\"72\":\"47#for-与区间\",\"73\":\"47#for-与迭代器\",\"74\":\"47#参见\",\"75\":\"48\",\"76\":\"49\",\"77\":\"49#参见\",\"78\":\"50\",\"79\":\"51\",\"80\":\"52\",\"81\":\"53\",\"82\":\"53#参见\",\"83\":\"54\",\"84\":\"55\",\"85\":\"56\",\"86\":\"57\",\"87\":\"58\",\"88\":\"58#参见\",\"89\":\"59\",\"90\":\"59#参见\",\"91\":\"60\",\"92\":\"60#参见\",\"93\":\"61\",\"94\":\"61#参见\",\"95\":\"62\",\"96\":\"62#参见\",\"97\":\"63\",\"98\":\"63#参见\",\"99\":\"64\",\"100\":\"64#see-also\",\"101\":\"65\",\"102\":\"65#参见\",\"103\":\"66\",\"104\":\"66#参见\",\"105\":\"67\",\"106\":\"67#参见\",\"107\":\"68\",\"108\":\"68#动手试一试\",\"109\":\"68#参见\",\"110\":\"69\",\"111\":\"70\",\"112\":\"71\",\"113\":\"72\",\"114\":\"73\",\"115\":\"74\",\"116\":\"75\",\"117\":\"76\",\"118\":\"76#文档注释\",\"119\":\"76#文档属性\",\"120\":\"76#inline\",\"121\":\"76#no-inline\",\"122\":\"76#hidden\",\"123\":\"76#参见\",\"124\":\"77\",\"125\":\"77#在-mdbook-使用\",\"126\":\"77#在文档中使用\",\"127\":\"77#参见\",\"128\":\"78\",\"129\":\"79\",\"130\":\"79#参见\",\"131\":\"80\",\"132\":\"81\",\"133\":\"82\",\"134\":\"83\",\"135\":\"84\",\"136\":\"85\",\"137\":\"85#动手试一试\",\"138\":\"86\",\"139\":\"87\",\"140\":\"88\",\"141\":\"89\",\"142\":\"89#析构函数\",\"143\":\"89#参见\",\"144\":\"90\",\"145\":\"91\",\"146\":\"92\",\"147\":\"93\",\"148\":\"94\",\"149\":\"95\",\"150\":\"95#参见\",\"151\":\"96\",\"152\":\"97\",\"153\":\"97#字面量与转义字符\",\"154\":\"98\",\"155\":\"99\",\"156\":\"99#标准库\",\"157\":\"99#crate\",\"158\":\"100\",\"159\":\"101\",\"160\":\"102\",\"161\":\"103\",\"162\":\"103#参见\",\"163\":\"104\",\"164\":\"105\",\"165\":\"105#参见\",\"166\":\"106\",\"167\":\"107\",\"168\":\"108\",\"169\":\"108#参见\",\"170\":\"109\",\"171\":\"109#文档测试的目的\",\"172\":\"109#参见\",\"173\":\"110\",\"174\":\"111\",\"175\":\"111#测试-panic\",\"176\":\"111#运行特定的测试\",\"177\":\"111#忽略测试\",\"178\":\"112\",\"179\":\"113\",\"180\":\"113#参见\",\"181\":\"114\",\"182\":\"114#参见\",\"183\":\"115\",\"184\":\"116\",\"185\":\"117\",\"186\":\"118\",\"187\":\"119\",\"188\":\"119#参见\",\"189\":\"120\",\"190\":\"120#参见\",\"191\":\"121\",\"192\":\"121#参见\",\"193\":\"122\",\"194\":\"123\",\"195\":\"124\",\"196\":\"125\",\"197\":\"126\",\"198\":\"127\",\"199\":\"128\",\"200\":\"129\",\"201\":\"130\",\"202\":\"130#参考\",\"203\":\"131\",\"204\":\"131#参见\",\"205\":\"132\",\"206\":\"132#参见\",\"207\":\"133\",\"208\":\"133#参见\",\"209\":\"134\",\"210\":\"135\",\"211\":\"136\",\"212\":\"136#参见\",\"213\":\"137\",\"214\":\"137#see-also\",\"215\":\"138\",\"216\":\"138#参见\",\"217\":\"139\",\"218\":\"139#参见\",\"219\":\"140\",\"220\":\"141\",\"221\":\"142\",\"222\":\"142#try-宏\",\"223\":\"143\",\"224\":\"143#参见\",\"225\":\"144\",\"226\":\"145\",\"227\":\"146\",\"228\":\"147\",\"229\":\"147#参见\",\"230\":\"148\",\"231\":\"149\",\"232\":\"149#参见\",\"233\":\"150\",\"234\":\"150#参见\",\"235\":\"151\",\"236\":\"151#参见\",\"237\":\"152\",\"238\":\"153\",\"239\":\"153#参见\",\"240\":\"154\",\"241\":\"154#参见\",\"242\":\"155\",\"243\":\"155#参见\",\"244\":\"156\",\"245\":\"156#参见\",\"246\":\"157\",\"247\":\"158\",\"248\":\"158#参见\",\"249\":\"159\",\"250\":\"159#参见\",\"251\":\"160\",\"252\":\"160#动手试一试\",\"253\":\"160#参见\",\"254\":\"161\",\"255\":\"161#参见\",\"256\":\"162\",\"257\":\"162#动手试一试\",\"258\":\"162#参见\",\"259\":\"163\",\"260\":\"164\",\"261\":\"165\",\"262\":\"165#参见\",\"263\":\"166\",\"264\":\"167\",\"265\":\"167#参见\",\"266\":\"168\",\"267\":\"168#参见\",\"268\":\"169\",\"269\":\"169#参见\",\"270\":\"170\",\"271\":\"170#参见\",\"272\":\"171\",\"273\":\"172\",\"274\":\"172#参见\",\"275\":\"173\",\"276\":\"173#参见\",\"277\":\"174\",\"278\":\"174#参见\",\"279\":\"175\",\"280\":\"175#参见\",\"281\":\"176\",\"282\":\"177\",\"283\":\"177#参见\",\"284\":\"178\",\"285\":\"179\",\"286\":\"180\",\"287\":\"181\",\"288\":\"182\",\"289\":\"183\",\"290\":\"184\",\"291\":\"185\",\"292\":\"186\",\"293\":\"187\",\"294\":\"187#作业\",\"295\":\"187#参见\",\"296\":\"188\",\"297\":\"188#参见\",\"298\":\"189\",\"299\":\"189#参见\",\"300\":\"190\",\"301\":\"190#参见\",\"302\":\"191\",\"303\":\"191#参见\",\"304\":\"192\",\"305\":\"192#参见\",\"306\":\"193\",\"307\":\"193#参见\",\"308\":\"194\",\"309\":\"194#参见\",\"310\":\"195\",\"311\":\"195#动手试一试\",\"312\":\"195#参见\",\"313\":\"196\",\"314\":\"197\",\"315\":\"198\",\"316\":\"199\",\"317\":\"200\",\"318\":\"201\",\"319\":\"202\",\"320\":\"203\",\"321\":\"204\",\"322\":\"205\",\"323\":\"206\",\"324\":\"207\",\"325\":\"208\",\"326\":\"209\",\"327\":\"210\",\"328\":\"211\",\"329\":\"212\",\"330\":\"213\",\"331\":\"214\",\"332\":\"215\",\"333\":\"216\",\"334\":\"217\",\"335\":\"218\",\"336\":\"219\",\"337\":\"220\",\"338\":\"221\",\"339\":\"222\",\"340\":\"223\",\"341\":\"224\",\"342\":\"225\",\"343\":\"226\",\"344\":\"227\",\"345\":\"228\",\"346\":\"229\",\"347\":\"230\",\"348\":\"231\",\"349\":\"232\",\"350\":\"233\",\"351\":\"234\",\"352\":\"235\",\"353\":\"236\",\"354\":\"237\",\"355\":\"238\",\"356\":\"239\",\"357\":\"240\",\"358\":\"241\",\"359\":\"242\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,225],\"1\":[1,43],\"2\":[1,18],\"3\":[1,5],\"4\":[1,17],\"5\":[1,38],\"6\":[1,16],\"7\":[1,63],\"8\":[1,47],\"9\":[1,9],\"10\":[1,71],\"11\":[1,125],\"12\":[2,1],\"13\":[2,42],\"14\":[1,14],\"15\":[2,139],\"16\":[4,67],\"17\":[1,17],\"18\":[1,22],\"19\":[1,5],\"20\":[4,50],\"21\":[4,71],\"22\":[2,6],\"23\":[1,12],\"24\":[1,28],\"25\":[2,3],\"26\":[1,12],\"27\":[2,3],\"28\":[1,13],\"29\":[1,4],\"30\":[2,75],\"31\":[1,13],\"32\":[1,25],\"33\":[1,22],\"34\":[1,40],\"35\":[1,46],\"36\":[1,35],\"37\":[2,5],\"38\":[1,53],\"39\":[3,27],\"40\":[1,49],\"41\":[1,40],\"42\":[1,46],\"43\":[1,35],\"44\":[1,132],\"45\":[1,74],\"46\":[3,14],\"47\":[1,44],\"48\":[1,41],\"49\":[3],\"50\":[1,44],\"51\":[1,37],\"52\":[3,57],\"53\":[1,39],\"54\":[1,42],\"55\":[1,66],\"56\":[2,4],\"57\":[1,93],\"58\":[1,40],\"59\":[2,7],\"60\":[1,95],\"61\":[2,17],\"62\":[2,3],\"63\":[2,27],\"64\":[2,29],\"65\":[2,38],\"66\":[2,36],\"67\":[1,63],\"68\":[3,110],\"69\":[1,27],\"70\":[2,79],\"71\":[2],\"72\":[2,47],\"73\":[2,67],\"74\":[2,1],\"75\":[2,48],\"76\":[2,140],\"77\":[2,4],\"78\":[2,36],\"79\":[2,61],\"80\":[2,39],\"81\":[2,75],\"82\":[2,4],\"83\":[1,87],\"84\":[1,97],\"85\":[1,83],\"86\":[1,120],\"87\":[1,38],\"88\":[2,1],\"89\":[1,101],\"90\":[2,5],\"91\":[1,89],\"92\":[2,3],\"93\":[1,49],\"94\":[2,4],\"95\":[1,49],\"96\":[2,4],\"97\":[1,42],\"98\":[2,4],\"99\":[3,43],\"100\":[3,1],\"101\":[1,80],\"102\":[2,4],\"103\":[2,69],\"104\":[2,5],\"105\":[1,62],\"106\":[2,1],\"107\":[1,172],\"108\":[1,30],\"109\":[2,8],\"110\":[1,83],\"111\":[3,112],\"112\":[3,48],\"113\":[1,42],\"114\":[1,44],\"115\":[1,8],\"116\":[1,43],\"117\":[1,14],\"118\":[1,72],\"119\":[1,6],\"120\":[1,12],\"121\":[1,14],\"122\":[1,18],\"123\":[2,10],\"124\":[1,7],\"125\":[2,23],\"126\":[1,17],\"127\":[2,4],\"128\":[1,56],\"129\":[1,59],\"130\":[2,3],\"131\":[3,56],\"132\":[2,36],\"133\":[1,84],\"134\":[1,88],\"135\":[1,99],\"136\":[1,99],\"137\":[1,36],\"138\":[1,84],\"139\":[1,67],\"140\":[1,81],\"141\":[1,128],\"142\":[1,34],\"143\":[2,1],\"144\":[2,45],\"145\":[2,86],\"146\":[2,132],\"147\":[2,71],\"148\":[2,125],\"149\":[2,79],\"150\":[2,4],\"151\":[2,86],\"152\":[1,99],\"153\":[1,182],\"154\":[2,115],\"155\":[1],\"156\":[1,33],\"157\":[1,11],\"158\":[1,76],\"159\":[1,76],\"160\":[4,25],\"161\":[1,114],\"162\":[2,2],\"163\":[1,48],\"164\":[1,89],\"165\":[1,4],\"166\":[1,49],\"167\":[1,52],\"168\":[1,46],\"169\":[1,3],\"170\":[1,85],\"171\":[1,68],\"172\":[1,4],\"173\":[1,79],\"174\":[1,99],\"175\":[2,60],\"176\":[1,28],\"177\":[1,41],\"178\":[1,71],\"179\":[1,96],\"180\":[1,1],\"181\":[2,68],\"182\":[2,6],\"183\":[1,65],\"184\":[4,79],\"185\":[2,109],\"186\":[1,130],\"187\":[1,82],\"188\":[2,2],\"189\":[2,52],\"190\":[2,7],\"191\":[1,59],\"192\":[2,1],\"193\":[1,104],\"194\":[1,51],\"195\":[1,79],\"196\":[1,30],\"197\":[1,28],\"198\":[1,24],\"199\":[1,47],\"200\":[1,32],\"201\":[2,44],\"202\":[2,1],\"203\":[2,54],\"204\":[2,3],\"205\":[2,100],\"206\":[2,3],\"207\":[3,105],\"208\":[2,4],\"209\":[1,130],\"210\":[4,65],\"211\":[2,126],\"212\":[2,4],\"213\":[1,118],\"214\":[3,4],\"215\":[3,97],\"216\":[2,7],\"217\":[2,97],\"218\":[2,5],\"219\":[3,79],\"220\":[1,61],\"221\":[2,56],\"222\":[1,48],\"223\":[3,68],\"224\":[2,2],\"225\":[3,112],\"226\":[1,33],\"227\":[3,27],\"228\":[1,85],\"229\":[2,4],\"230\":[1,5],\"231\":[1,42],\"232\":[2,1],\"233\":[1,59],\"234\":[2,5],\"235\":[1,148],\"236\":[2,5],\"237\":[2,2],\"238\":[1,42],\"239\":[2,4],\"240\":[1,130],\"241\":[2,7],\"242\":[1,49],\"243\":[2,7],\"244\":[1,88],\"245\":[2,3],\"246\":[1,97],\"247\":[2,53],\"248\":[2,6],\"249\":[2,125],\"250\":[2,14],\"251\":[1,115],\"252\":[1,24],\"253\":[2,2],\"254\":[3,110],\"255\":[2,6],\"256\":[3,167],\"257\":[1,19],\"258\":[2,8],\"259\":[1,59],\"260\":[1,32],\"261\":[1,79],\"262\":[2,1],\"263\":[2,75],\"264\":[1,38],\"265\":[2,1],\"266\":[1,102],\"267\":[2,3],\"268\":[1,78],\"269\":[2,1],\"270\":[1,73],\"271\":[2,4],\"272\":[1,48],\"273\":[1,34],\"274\":[2,1],\"275\":[1,69],\"276\":[2,3],\"277\":[1,50],\"278\":[2,1],\"279\":[1,32],\"280\":[2,1],\"281\":[1,24],\"282\":[1,52],\"283\":[2,1],\"284\":[1,110],\"285\":[2,115],\"286\":[2,83],\"287\":[1,74],\"288\":[2,144],\"289\":[2,76],\"290\":[1,72],\"291\":[1,91],\"292\":[1,45],\"293\":[3,178],\"294\":[1,9],\"295\":[2,12],\"296\":[1,77],\"297\":[2,5],\"298\":[1,115],\"299\":[2,2],\"300\":[2,45],\"301\":[2,3],\"302\":[1,30],\"303\":[2,3],\"304\":[1,46],\"305\":[2,1],\"306\":[2,95],\"307\":[2,4],\"308\":[2,81],\"309\":[2,4],\"310\":[2,98],\"311\":[2,9],\"312\":[2,7],\"313\":[1,3],\"314\":[1],\"315\":[1],\"316\":[1],\"317\":[1],\"318\":[1],\"319\":[2],\"320\":[1],\"321\":[2],\"322\":[1],\"323\":[1],\"324\":[1],\"325\":[1],\"326\":[1],\"327\":[1],\"328\":[1],\"329\":[1],\"330\":[1],\"331\":[2],\"332\":[1],\"333\":[1],\"334\":[1],\"335\":[2],\"336\":[1],\"337\":[1],\"338\":[3],\"339\":[2],\"340\":[1],\"341\":[1],\"342\":[1],\"343\":[1],\"344\":[2],\"345\":[1],\"346\":[1],\"347\":[1],\"348\":[1],\"349\":[1],\"350\":[1],\"351\":[1],\"352\":[1],\"353\":[1],\"354\":[1],\"355\":[1],\"356\":[1],\"357\":[1],\"358\":[2],\"359\":[2]},\"averageFieldLength\":[1.530555555555555,48.31192029927664],\"storedFields\":{\"0\":{\"h\":\"Summary\",\"t\":[\"简介\",\"Hello World\",\"注释\",\"格式化输出\",\"调试（debug）\",\"显示（display）\",\"测试实例：List\",\"格式化\",\"原生类型\",\"字面量和运算符\",\"元组\",\"数组和切片\",\"自定义类型\",\"结构体\",\"枚举\",\"使用 use\",\"C 风格用法\",\"测试实例：链表\",\"常量\",\"变量绑定\",\"可变变量\",\"作用域和遮蔽\",\"变量先声明\",\"冻结\",\"类型系统\",\"类型转换\",\"字面量\",\"类型推断\",\"别名\",\"类型转换\",\"From 和 Into\",\"TryFrom 和 TryInto\",\"ToString 和 FromStr\",\"表达式\",\"流程控制\",\"if/else\",\"loop 循环\",\"嵌套循环和标签\",\"从 loop 循环返回\",\"while 循环\",\"for 循环和区间\",\"match 匹配\",\"解构\",\"元组\",\"数组/切片\",\"枚举\",\"指针和引用\",\"结构体\",\"卫语句\",\"绑定\",\"if let\",\"while let\",\"函数\",\"方法\",\"闭包\",\"捕获\",\"作为输入参数\",\"类型匿名\",\"输入函数\",\"作为输出参数\",\"std 中的例子\",\"Iterator::any\",\"Iterator::find\",\"高阶函数\",\"发散函数\",\"模块\",\"可见性\",\"结构体的可见性\",\"use 声明\",\"super 和 self\",\"文件分层\",\"crate\",\"库\",\"使用库\",\"cargo\",\"依赖\",\"约定规范\",\"测试\",\"构建脚本\",\"属性\",\"死代码 dead_code\",\"crate\",\"cfg\",\"自定义条件\",\"泛型\",\"函数\",\"实现\",\"trait\",\"约束\",\"测试实例：空约束\",\"多重约束\",\"where 子句\",\"newtype 惯用法\",\"关联项\",\"存在问题\",\"关联类型\",\"虚类型参数\",\"测试实例：单位检查\",\"作用域规则\",\"RAII\",\"所有权和移动\",\"可变性\",\"部分移动\",\"借用\",\"可变性\",\"别名使用\",\"ref 模式\",\"生命周期\",\"显式标注\",\"函数\",\"方法\",\"结构体\",\"trait\",\"约束\",\"强制转换\",\"static\",\"省略\",\"特质 trait\",\"派生\",\"使用 dyn 返回 trait\",\"运算符重载\",\"Drop\",\"Iterator\",\"impl Trait\",\"Clone\",\"父 trait\",\"消除重叠 trait\",\"使用 macro_rules! 来创建宏\",\"语法\",\"指示符\",\"重载\",\"重复\",\"DRY (不写重复代码)\",\"DSL (领域专用语言)\",\"可变参数接口\",\"错误处理\",\"panic\",\"Option 和 unwrap\",\"使用 ? 解开 Option\",\"组合算子：map\",\"组合算子：and_then\",\"结果 Result\",\"Result 的 map\",\"给 Result 取别名\",\"提前返回\",\"引入 ?\",\"处理多种错误类型\",\"从 Option 中取出 Result\",\"定义一种错误类型\",\"把错误 “装箱”\",\"? 的其他用法\",\"包裹错误\",\"遍历 Result\",\"标准库类型\",\"箱子、栈和堆\",\"动态数组 vector\",\"字符串 String\",\"选项 Option\",\"结果 Result\",\"? 用法\",\"panic!\",\"散列表 HashMap\",\"更改或自定义关键字类型\",\"散列集 HashSet\",\"引用计数 Rc\",\"共享引用计数 Arc\",\"标准库更多介绍\",\"线程\",\"测试实例：map-reduce\",\"通道\",\"路径\",\"文件输入输出（I/O）\",\"打开文件 open\",\"创建文件 create\",\"读取行 read lines\",\"子进程\",\"管道\",\"等待\",\"文件系统操作\",\"程序参数\",\"参数解析\",\"外部语言函数接口\",\"测试\",\"单元测试\",\"文档测试\",\"集成测试\",\"开发依赖\",\"不安全操作\",\"兼容性\",\"原始标志符\",\"补充\",\"文档\",\"Playpen\"]},\"1\":{\"h\":\"属性\",\"t\":[\"属性是应用于某些模块、crate 或项的元数据（metadata）。这元数据可以用来：\",\"[设置 crate 名称、版本和类型（二进制文件或库）][crate]\",\"禁用 lint （警告）\",\"启用编译器的特性（宏、全局导入（glob import）等）\",\"链接到一个非 Rust 语言的库\",\"标记函数作为单元测试\",\"标记函数作为基准测试的某个部分\",\"当属性作用于整个 crate 时，它们的语法为 #![crate_attribute]，当它们用于模块或项时，语法为 #[item_attribute]（注意少了感叹号 !）。\",\"属性可以接受参数，有不同的语法形式：\",\"#[attribute = \\\"value\\\"]\",\"#[attribute(key = \\\"value\\\")]\",\"#[attribute(value)]\",\"属性可以多个值，它们可以分开到多行中：\",\"#[attribute(value, value2)] #[attribute(value, value2, value3, value4, value5)]\"]},\"2\":{\"h\":\"cargo\",\"t\":[\"cargo 是官方的 Rust 包管理工具。 它有很多非常有用的功能来提高代码质量和开发人员的开发效率！ 这些功能包括：\",\"依赖管理和与 crates.io（官方 Rust 包注册服务）集成\",\"方便的单元测试\",\"方便的基准测试\",\"本章将介绍一些快速入门的基础知识，不过你可以在 cargo 官方手册中找到详细内容。\"]},\"3\":{\"h\":\"兼容性\",\"t\":[\"Rust 语言正在快速发展，因此尽管努力确保尽可能向前兼容，但仍可能出现某些兼容性问题。\",\"原始标识符\"]},\"4\":{\"h\":\"类型转换\",\"t\":[\"Rust 使用 trait 解决类型之间的转换问题。最一般的转换会用到 From 和 Into 两个 trait。不过，即便常见的情况也可能会用到特别的 trait，尤其是从 String 转换到别的类型，以及把别的类型转换到 String 时。\"]},\"5\":{\"h\":\"crate\",\"t\":[\"crate（中文有 “包，包装箱” 之意）是 Rust 的编译单元。当调用 rustc some_file.rs 时，some_file.rs 被当作 crate 文件。如果 some_file.rs 里面含有 mod 声明，那么模块文件的内容将在编译之前被插入 crate 文件的相应声明处。换句话说，模块不会单独被编译，只有 crate 才会被编译。\",\"crate 可以编译成二进制可执行文件（binary）或库文件（library）。默认情况下，rustc 将从 crate 产生二进制可执行文件。这种行为可以通过 rustc 的选项 --crate-type 重载。\"]},\"6\":{\"h\":\"自定义类型\",\"t\":[\"Rust 自定义数据类型主要是通过下面这两个关键字来创建：\",\"struct： 定义一个结构体（structure）\",\"enum： 定义一个枚举类型（enumeration）\",\"而常量（constant）可以通过 const 和 static 关键字来创建。\"]},\"7\":{\"h\":\"错误处理\",\"t\":[\"错误处理（error handling）是处理可能发生的失败情况的过程。例如读取一个文件时失败了，如果继续使用这个无效的输入，那显然是有问题的。注意到并且显式地处理这种错误可以避免程序的其他部分产生潜在的问题。\",\"在 Rust 中有多种处理错误的方式，在接下来的小节中会一一介绍。它们多少有些区别，使用场景也不尽相同。总的来说：\",\"显式的 panic 主要用于测试，以及处理不可恢复的错误。在原型开发中这很有用，比如 用来测试还没有实现的函数，不过这时使用 unimplemented 更能表达意图。另外在 测试中，panic 是一种显式地失败（fail）的好方法。\",\"Option 类型是为了值是可选的、或者缺少值并不是错误的情况准备的。比如说寻找 父目录时，/ 和 C: 这样的目录就没有父目录，这应当并不是一个错误。当处理Option 时，unwrap 可用于原型开发，也可以用于能够确定 Option 中一定有值 的情形。然而 expect 更有用，因为它允许你指定一条错误信息，以免万一还是出现 了错误。\",\"当错误有可能发生，且应当由调用者处理时，使用 Result。你也可以 unwrap 然后 使用 expect，但是除了在测试或者原型开发中，请不要这样做。\",\"有关错误处理的更多内容，可参考官方文档的错误处理的章节。\"]},\"8\":{\"h\":\"表达式\",\"t\":[\"Rust 程序（大部分）由一系列语句构成：\",\"fn main() { // 语句 // 语句 // 语句 }\",\"Rust 有多种语句。最普遍的语句类型有两种：一种是声明绑定变量，另一种是表达式带上英文分号(😉：\",\"fn main() { // 变量绑定 let x = 5; // 表达式; x; x + 1; 15; }\",\"代码块也是表达式，所以它们可以用作赋值中的值。代码块中的最后一个表达式将赋给适当的表达式，例如局部变量。但是，如果代码块的最后一个表达式结尾处有分号，则返回值为 ()（译注：代码块中的最后一个语句是代码块中实际执行的最后一个语句，而不一定是代码块中最后一行的语句）。\",\"fn main() { let x = 5u32; let y = { let x_squared = x * x; let x_cube = x_squared * x; // 将此表达式赋给 `y` x_cube + x_squared + x }; let z = { // 分号结束了这个表达式，于是将 `()` 赋给 `z` 2 * x; }; println!(\\\"x is {:?}\\\", x); println!(\\\"y is {:?}\\\", y); println!(\\\"z is {:?}\\\", z); }\"]},\"9\":{\"h\":\"流程控制\",\"t\":[\"任何编程语言都包含的一个必要部分就是改变控制流程：if/else，for 等。让我们谈谈 Rust 语言中的这部分内容。\"]},\"10\":{\"h\":\"函数\",\"t\":[\"函数（function）使用 fn 关键字来声明。函数的参数需要标注类型，就和变量一样，如果函数返回一个值，返回类型必须在箭头 -> 之后指定。\",\"函数最后的表达式将作为返回值。也可以在函数内使用 return 语句来提前返一个值，甚至可以在循环或 if 内部使用。\",\"让我们使用函数来重写 FizzBuzz 程序吧！\",\"// 和 C/C++ 不一样，Rust 的函数定义位置是没有限制的 fn main() { // 我们可以在这里使用函数，后面再定义它 fizzbuzz_to(100); } // 一个返回布尔值的函数 fn is_divisible_by(lhs: u32, rhs: u32) -> bool { // 边界情况，提前返回 if rhs == 0 { return false; } // 这是一个表达式，可以不用 `return` 关键字 lhs % rhs == 0 } // 一个 “不” 返回值的函数。实际上会返回一个单元类型 `()`。 fn fizzbuzz(n: u32) -> () { if is_divisible_by(n, 15) { println!(\\\"fizzbuzz\\\"); } else if is_divisible_by(n, 3) { println!(\\\"fizz\\\"); } else if is_divisible_by(n, 5) { println!(\\\"buzz\\\"); } else { println!(\\\"{}\\\", n); } } // 当函数返回 `()` 时，函数签名可以省略返回类型 fn fizzbuzz_to(n: u32) { for n in 1..=n { fizzbuzz(n); } }\"]},\"11\":{\"h\":\"泛型\",\"t\":[\"泛型（generic）是关于泛化类型和函数功能，以扩大其适用范围的话题。泛型极大地减少了代码的重复，但它自身的语法很要求细心。也就是说，采用泛型意味着仔细地指定泛型类型具体化时，什么样的具体类型是合法的。泛型最简单和常用的用法是用于类型参数。\",\"译注：定义泛型类型或泛型函数之类的东西时，我们会用 <A> 或者 <T> 这类标记 作为类型的代号，就像函数的形参一样。在使用时，为把 <A>、<T> 具体化，我们 会把类型说明像实参一样使用，像是 <i32> 这样。这两种把（泛型的或具体的）类型 当作参数的用法就是类型参数。\",\"泛型的类型参数是使用尖括号和大驼峰命名的名称：<Aaa, Bbb, ...> 来指定的。泛型类型参数一般用 <T> 来表示。在 Rust 中，“泛型的” 除了表示类型，还表示可以接受一个或多个泛型类型参数 <T> 的任何内容。任何用泛型类型参数表示的类型都是泛型，其他的类型都是具体（非泛型）类型。\",\"例如定义一个名为 foo 的 泛型函数，它可接受类型为 T 的任何参数 arg：\",\"fn foo<T>(arg: T) { ... }\",\"因为我们使用了泛型类型参数 <T>，所以这里的 (arg: T) 中的 T 就是泛型类型。即使 T 在之前被定义为 struct，这里的 T 仍然代表泛型。\",\"下面例子展示了泛型语法的使用：\",\"// 一个具体类型 `A`。 struct A; // 在定义类型 `Single` 时，第一次使用类型 `A` 之前没有写 `<A>`。 // 因此，`Single` 是个具体类型，`A` 取上面的定义。 struct Single(A); // ^ 这里是 `Single` 对类型 `A` 的第一次使用。 // 此处 `<T>` 在第一次使用 `T` 前出现，所以 `SingleGen` 是一个泛型类型。 // 因为 `T` 是泛型的，所以它可以是任何类型，包括在上面定义的具体类型 `A`。 struct SingleGen<T>(T); fn main() { // `Single` 是具体类型，并且显式地使用类型 `A`。 let _s = Single(A); // 创建一个 `SingleGen<char>` 类型的变量 `_char`，并令其值为 `SingleGen('a')` // 这里的 `SingleGen` 的类型参数是显式指定的。 let _char: SingleGen<char> = SingleGen('a'); // `SingleGen` 的类型参数也可以隐式地指定。 let _t = SingleGen(A); // 使用在上面定义的 `A`。 let _i32 = SingleGen(6); // 使用 `i32` 类型。 let _char = SingleGen('a'); // 使用 `char`。 }\"]},\"12\":{\"h\":\"参见：\",\"t\":[\"struct\"]},\"13\":{\"h\":\"Hello World\",\"t\":[\"这是传统的 Hello World 程序的源码。\",\"// 这是注释内容，将会被编译器忽略掉 // 可以单击那边的按钮 \\\"Run\\\" 来测试这段代码 -> // 若想用键盘操作，可以使用快捷键 \\\"Ctrl + Enter\\\" 来运行 // 这段代码支持编辑，你可以自由地修改代码！ // 通过单击 \\\"Reset\\\" 按钮可以使代码恢复到初始状态 -> // 这是主函数 fn main() { // 调用编译生成的可执行文件时，这里的语句将被运行。 // 将文本打印到控制台 println!(\\\"Hello World!\\\"); }\",\"println! 是一个宏（macros），可以将文本输出到控制台（console）。\",\"使用 Rust 的编译器 rustc 可以从源程序生成可执行文件：\",\"$ rustc hello.rs\",\"使用 rustc 编译后将得到可执行文件 hello。\",\"$ ./hello Hello World!\"]},\"14\":{\"h\":\"动手试一试\",\"t\":[\"单击上面的 \\\"Run\\\" 按钮并观察输出结果。然后增加一行代码，再一次使用宏 println!，得到下面结果：\",\"Hello World! I'm a Rustacean!\"]},\"15\":{\"h\":\"通过例子学 Rust\",\"t\":[\"中文翻译注（Chinese translation of the Rust By Example）：\",\"👉 查看更多 Rust 官方文档中英文双语教程，包括双语版《Rust 程序设计语言》（出版书名为《Rust 权威指南》），本站还提供了 Rust 标准库中文版。\",\"《通过例子学 Rust》(Rust By Example 中文版)翻译自 Rust By Example，中文版最后更新时间：2022-1-26。查看此书的 Github 翻译项目和源码。\",\"本站支持文档中英文切换，点击页面右上角语言图标可切换到相同章节的英文页面，英文版每天都会自动同步一次官方的最新版本。\",\"若发现本页表达错误或帮助我们改进翻译，可点击右上角的编辑按钮打开本页对应源码文件进行编辑和修改，Rust 中文资源的开源组织发展离不开大家，感谢您的支持和帮助！\",\"Rust 是一门注重安全（safety）、速度（speed）和并发（concurrency）的现代系统编程语言。Rust 通过内存安全来实现以上目标，但不使用垃圾回收机制（garbage collection, GC）。\",\"《通过例子学 Rust》（Rust By Example, RBE）内容由一系列可运行的实例组成，通过这些例子阐明了各种 Rust 的概念和基本库。想获取这些例子外的更多内容，不要忘了安装 Rust 到本地并查阅官方标准库文档。另外为了满足您的好奇心，您还可以查阅本网站的源代码。\",\"现在让我们开始学习吧！\",\"Hello World - 从经典的 “Hello World” 程序开始学习。\",\"原生类型 - 学习有符号整型，无符号整型和其他原生类型。\",\"自定义类型 - 结构体 struct 和 枚举 enum。\",\"变量绑定 - 变量绑定，作用域，变量遮蔽。\",\"类型系统 - 学习改变和定义类型。\",\"类型转换 - 在不同类型之间进行转换，例如字符串、整数和浮点数。\",\"表达式 - 了解表达式以及如何使用。\",\"流程控制 - if/else，for，以及其他流程控制有关内容。\",\"函数 - 学习方法、闭包和高阶函数。\",\"模块 - 使用模块来组织代码。\",\"Crate - crate 是 Rust 中的编译单元。学习创建一个库。\",\"Cargo - 学习官方的 Rust 包管理工具的一些基本功能。\",\"属性 - 属性是应用于某些模块、crate 或项的元数据（metadata）。\",\"泛型 - 学习编写能够适用于多种类型参数的函数或数据类型。\",\"作用域规则 - 作用域在所有权（ownership）、借用（borrowing）和生命周期（lifetime）中起着重要作用。\",\"特性 trait - trait 是对未知类型（Self）定义的方法集。\",\"宏 - 宏是一种编写代码来编写其他代码的方法，这称为元编程（metaprogramming）。\",\"错误处理 - 学习 Rust 语言处理失败的方式。\",\"标准库类型 - 学习 std 标准库提供的一些自定义类型。\",\"标准库更多介绍 - 更多关于文件处理、线程的自定义类型。\",\"测试 - Rust 语言的各种测试手段。\",\"不安全操作 - 了解如何进入不安全操作块。\",\"兼容性 - 处理 Rust 的演变和潜在的兼容性问题。\",\"补充 - 文档和基准测试\"]},\"16\":{\"h\":\"使用 macro_rules! 来创建宏\",\"t\":[\"Rust 提供了一个强大的宏系统，可进行元编程（metaprogramming）。你已经在前面的章节中看到，宏看起来和函数很像，只不过名称末尾有一个感叹号 ! 。宏并不产生函数调用，而是展开成源码，并和程序的其余部分一起被编译。Rust 又有一点和 C 以及其他语言都不同，那就是 Rust 的宏会展开为抽象语法树（AST，abstract syntax tree），而不是像字符串预处理那样直接替换成代码，这样就不会产生无法预料的优先权错误。\",\"宏是通过 macro_rules! 宏来创建的。\",\"// 这是一个简单的宏，名为 `say_hello`。 macro_rules! say_hello { // `()` 表示此宏不接受任何参数。 () => { // 此宏将会展开成这个代码块里面的内容。 println!(\\\"Hello!\\\"); }; } fn main() { // 这个调用将会展开成 `println!(\\\"Hello!\\\");` say_hello!() }\",\"为什么宏是有用的？\",\"不写重复代码（DRY，Don't repeat yourself.）。很多时候你需要在一些地方针对不同 的类型实现类似的功能，这时常常可以使用宏来避免重复代码（稍后详述）。\",\"领域专用语言（DSL，domain-specific language）。宏允许你为特定的目的创造特定的 语法（稍后详述）。\",\"可变接口（variadic interface）。有时你需要能够接受不定数目参数的接口，比如println!，根据格式化字符串的不同，它需要接受任意多的参数（稍后详述）。\"]},\"17\":{\"h\":\"补充\",\"t\":[\"在软件工程中，有些主题和写程序并没有直接的关联，但它们为你提供了工具和基础设施支持，使得软件对每个人都变得更易用。这些主题包括：\",\"文档：通过附带的 rustdoc 生成库文档给用户。\",\"测试：为库创建测试套件，确保库准确地实现了你想要的功能。\",\"基准测试（benchmark）：对功能进行基准测试，保证其运行速度足够快。\"]},\"18\":{\"h\":\"模块\",\"t\":[\"Rust 提供了一套强大的模块（module）系统，可以将代码按层次分成多个逻辑单元（模块），并管理这些模块之间的可见性（公有（public）或私有（private））。\",\"模块是项（item）的集合，项可以是：函数，结构体，trait，impl 块，甚至其它模块。\"]},\"19\":{\"h\":\"原生类型\",\"t\":[\"Rust 提供了多种原生类型（primitives），包括：\"]},\"20\":{\"h\":\"标量类型（scalar type）\",\"t\":[\"有符号整数（signed integers）：i8、i16、i32、i64、i128 和 isize（指针宽度）\",\"无符号整数（unsigned integers）： u8、u16、u32、u64、u128 和 usize（指针宽度）\",\"浮点数（floating point）： f32、f64\",\"char（字符）：单个 Unicode 字符，如 'a'，'α' 和 '∞'（每个都是 4 字节）\",\"bool（布尔型）：只能是 true 或 false\",\"单元类型（unit type）：()。其唯一可能的值就是 () 这个空元组\",\"尽管单元类型的值是个元组，它却并不被认为是复合类型，因为并不包含多个值。\"]},\"21\":{\"h\":\"复合类型（compound type）\",\"t\":[\"数组（array）：如 [1, 2, 3]\",\"元组（tuple）：如 (1, true)\",\"变量都能够显式地给出类型说明（type annotation）。数字还可以通过后缀（suffix）或默认方式来声明类型。整型默认为 i32 类型，浮点型默认为 f64类型。注意 Rust 还可以根据上下文来推断（infer）类型（译注：比如一个未声明类型整数和 i64 的整数相加，则该整数会自动推断为 i64 类型。仅当根据环境无法推断时，才按默认方式取整型数值为 i32，浮点数值为 f64）。\",\"fn main() { // 变量可以给出类型说明。 let logical: bool = true; let a_float: f64 = 1.0; // 常规说明 let an_integer = 5i32; // 后缀说明 // 否则会按默认方式决定类型。 let default_float = 3.0; // `f64` let default_integer = 7; // `i32` // 类型也可根据上下文自动推断。 let mut inferred_type = 12; // 根据下一行的赋值推断为 i64 类型 inferred_type = 4294967296i64; // 可变的（mutable）变量，其值可以改变。 let mut mutable = 12; // Mutable `i32` mutable = 21; // 报错！变量的类型并不能改变。 mutable = true; // 但可以用遮蔽（shadow）来覆盖前面的变量。 let mutable = true; }\"]},\"22\":{\"h\":\"参见：\",\"t\":[\"std 库、mut、类型推断 和 变量遮蔽\"]},\"23\":{\"h\":\"作用域规则\",\"t\":[\"作用域在所有权（ownership）、借用（borrow）和生命周期（lifetime）中起着重要作用。也就是说，作用域告诉编译器什么时候借用是合法的、什么时候资源可以释放、以及变量何时被创建或销毁。\"]},\"24\":{\"h\":\"标准库类型\",\"t\":[\"标准库提供了很多自定义类型，在原生类型基础上进行了大量扩充。这是部分自定义类型：\",\"可增长的 String（字符串），如: \\\"hello world\\\"\",\"可增长的向量（vector）: [1, 2, 3]\",\"选项类型（optional types）: Option<i32>\",\"错误处理类型（error handling types）: Result<i32, i32>\",\"堆分配的指针（heap allocated pointers）: Box<i32>\"]},\"25\":{\"h\":\"参见：\",\"t\":[\"原生类型 和 标准库\"]},\"26\":{\"h\":\"标准库更多介绍\",\"t\":[\"标准库也提供了很多其他类型来支持某些功能，例如：\",\"线程（Threads）\",\"信道（Channels）\",\"文件输入输出（File I/O）\",\"这些内容在原生类型之外进行了有效扩充。\"]},\"27\":{\"h\":\"参见：\",\"t\":[\"原生类型 和 标准库类型\"]},\"28\":{\"h\":\"测试\",\"t\":[\"Rust 是一门非常重视正确性的语言，这门语言本身就提供了对编写软件测试的支持。\",\"测试有三种风格：\",\"[单元][unit]测试。\",\"[文档][doc]测试。\",\"[集成][integration]测试。\",\"Rust 也支持在测试中指定额外的依赖：\"]},\"29\":{\"h\":\"参见\",\"t\":[\"TRPL 中关于测试的章节\",\"API 指导原则中关于文档测试的部分\"]},\"30\":{\"h\":\"特质 trait\",\"t\":[\"trait 是对未知类型 Self 定义的方法集。该类型也可以访问同一个 trait 中定义的其他方法。\",\"对任何数据类型都可以实现 trait。在下面例子中，我们定义了包含一系列方法的 Animal。然后针对 Sheep 数据类型实现 Animaltrait，因而 Sheep 的实例可以使用 Animal 中的所有方法。\",\"struct Sheep { naked: bool, name: &'static str } trait Animal { // 关联函数签名；`Self` 表示实现者类型（implementor type）。 fn new(name: &'static str) -> Self; // 方法签名；这些方法将返回一个字符串。 fn name(&self) -> &'static str; fn noise(&self) -> &'static str; // trait 可以提供默认的方法定义。 fn talk(&self) { println!(\\\"{} says {}\\\", self.name(), self.noise()); } } impl Sheep { fn is_naked(&self) -> bool { self.naked } fn shear(&mut self) { if self.is_naked() { // 实现者可以使用它的 trait 方法。 println!(\\\"{} is already naked...\\\", self.name()); } else { println!(\\\"{} gets a haircut!\\\", self.name); self.naked = true; } } } // 对 `Sheep` 实现 `Animal` trait。 impl Animal for Sheep { // `Self` 是实现者类型：`Sheep`。 fn new(name: &'static str) -> Sheep { Sheep { name: name, naked: false } } fn name(&self) -> &'static str { self.name } fn noise(&self) -> &'static str { if self.is_naked() { \\\"baaaaah?\\\" } else { \\\"baaaaah!\\\" } } // 默认 trait 方法可以重载。 fn talk(&self) { // 例如我们可以增加一些安静的沉思。 println!(\\\"{} pauses briefly... {}\\\", self.name, self.noise()); } } fn main() { // 这种情况需要类型标注。 let mut dolly: Sheep = Animal::new(\\\"Dolly\\\"); // 试一试 ^ 移除类型标注。 dolly.talk(); dolly.shear(); dolly.talk(); }\"]},\"31\":{\"h\":\"类型系统\",\"t\":[\"Rust 提供了多种机制，用于改变或定义原生类型和用户定义类型。接下来会讲到：\",\"原生类型的类型转换（cast）。\",\"指定字面量的类型。\",\"使用类型推断（type inference）。\",\"给类型取别名（alias）。\"]},\"32\":{\"h\":\"不安全操作\",\"t\":[\"在本章一开始，我们借用官方文档的一句话，“在整个代码库（code base，指构建一个软件系统所使用的全部代码）中，要尽可能减少不安全代码的量”。记住这句话，接着我们进入学习！在 Rust 中，不安全代码块用于避开编译器的保护策略；具体地说，不安全代码块主要用于四件事情：\",\"解引用裸指针\",\"通过 FFI 调用函数（这已经在之前的章节介绍过了）\",\"调用不安全的函数\",\"内联汇编（inline assembly）\"]},\"33\":{\"h\":\"原始指针\",\"t\":[\"原始指针（raw pointer，裸指针）* 和引用 &T 有类似的功能，但引用总是安全的，因为借用检查器保证了它指向一个有效的数据。解引用一个裸指针只能通过不安全代码块执行。\",\"fn main() { let raw_p: *const u32 = &10; unsafe { assert!(*raw_p == 10); } }\"]},\"34\":{\"h\":\"调用不安全函数\",\"t\":[\"一些函数可以声明为不安全的（unsafe），这意味着在使用它时保证正确性不再是编译器的责任，而是程序员的。一个例子就是 std::slice::from_raw_parts，向它传入指向第一个元素的指针和长度参数，它会创建一个切片。\",\"use std::slice; fn main() { let some_vector = vec![1, 2, 3, 4]; let pointer = some_vector.as_ptr(); let length = some_vector.len(); unsafe { let my_slice: &[u32] = slice::from_raw_parts(pointer, length); assert_eq!(some_vector.as_slice(), my_slice); } }\",\"slice::from_raw_parts 假设传入的指针指向有效的内存，且被指向的内存具有正确的数据类型，我们必须满足这一假设，否则程序的行为是未定义的（undefined），于是我们就不能预测会发生些什么了。\"]},\"35\":{\"h\":\"变量绑定\",\"t\":[\"Rust 通过静态类型确保类型安全。变量绑定可以在声明时说明类型，不过在多数情况下，编译器能够从上下文推导出变量的类型，从而大大减少了类型说明的工作。\",\"使用 let 绑定操作可以将值（比如字面量）绑定（bind）到变量。\",\"fn main() { let an_integer = 1u32; let a_boolean = true; let unit = (); // 将 `an_integer` 复制到 `copied_integer` let copied_integer = an_integer; println!(\\\"An integer: {:?}\\\", copied_integer); println!(\\\"A boolean: {:?}\\\", a_boolean); println!(\\\"Meet the unit value: {:?}\\\", unit); // 编译器会对未使用的变量绑定产生警告；可以给变量名加上下划线前缀来消除警告。 let _unused_variable = 3u32; let noisy_unused_variable = 2u32; // 改正 ^ 在变量名前加上下划线以消除警告 }\"]},\"36\":{\"h\":\"cfg\",\"t\":[\"条件编译可能通过两种不同的操作符实现：\",\"cfg 属性：在属性位置中使用 #[cfg(...)]\",\"cfg! 宏：在布尔表达式中使用 cfg!(...)\",\"两种形式使用的参数语法都相同。\",\"// 这个函数仅当目标系统是 Linux 的时候才会编译 #[cfg(target_os = \\\"linux\\\")] fn are_you_on_linux() { println!(\\\"You are running linux!\\\") } // 而这个函数仅当目标系统 **不是** Linux 时才会编译 #[cfg(not(target_os = \\\"linux\\\"))] fn are_you_on_linux() { println!(\\\"You are *not* running linux!\\\") } fn main() { are_you_on_linux(); println!(\\\"Are you sure?\\\"); if cfg!(target_os = \\\"linux\\\") { println!(\\\"Yes. It's definitely linux!\\\"); } else { println!(\\\"Yes. It's definitely *not* linux!\\\"); } }\"]},\"37\":{\"h\":\"参见：\",\"t\":[\"引用, cfg!, 和 宏.\"]},\"38\":{\"h\":\"crate\",\"t\":[\"crate_type 属性可以告知编译器 crate 是一个二进制的可执行文件还是一个库（甚至是哪种类型的库），crate_name 属性可以设定 crate 的名称。\",\"不过，一定要注意在使用 cargo 时，这两种类型时都没有作用。由于大多数 Rust 工程都使用 cargo，这意味着 crate_type 和 crate_name 的作用事实上很有限。\",\"// 这个 crate 是一个库文件 #![crate_type = \\\"lib\\\"] // 库的名称为 “rary” #![crate_name = \\\"rary\\\"] pub fn public_function() { println!(\\\"called rary's `public_function()`\\\"); } fn private_function() { println!(\\\"called rary's `private_function()`\\\"); } pub fn indirect_access() { print!(\\\"called rary's `indirect_access()`, that\\\\n> \\\"); private_function(); }\",\"当用到 crate_type 属性时，就不再需要给 rustc 命令加上 --crate-type 标记。\",\"$ rustc lib.rs $ ls lib* library.rlib\"]},\"39\":{\"h\":\"死代码 dead_code\",\"t\":[\"编译器提供了 dead_code（死代码，无效代码）lint，这会对未使用的函数产生警告。可以用一个属性来禁用这个 lint。\",\"fn used_function() {} // `#[allow(dead_code)]` 属性可以禁用 `dead_code` lint #[allow(dead_code)] fn unused_function() {} fn noisy_unused_function() {} // 改正 ^ 增加一个属性来消除警告 fn main() { used_function(); }\",\"注意在实际程序中，需要将死代码清除掉。由于本书的例子是交互性的，因而其中需要允许一些死代码的出现。\"]},\"40\":{\"h\":\"原始标志符\",\"t\":[\"与许多编程语言一样，Rust 拥有“关键字”的概念。 这些标识符对语言有特定意义，所以不能在变量名、函数名和其他位置使用它们。 原始标识符允许你使用通常不允许的关键字。 当 Rust 引入新关键字时，使用旧版 Rust 的库拥有与新版本中引入的关键字同名的变量或函数，这一点就特别有用。\",\"举个例子，使用 2015 版 Rust 编译的 crate foo，它导出一个名为 try 的函数。 此关键字（try）在 2018 版本的新功能中保留下来，因此如果没有原始标识符，我们将无法命名该功能。\",\"extern crate foo; fn main() { foo::try(); }\",\"将得到如下错误：\",\"error: expected identifier, found keyword `try` --> src/main.rs:4:4 | 4 | foo::try(); | ^^^ expected identifier, found keyword\",\"使用原始标志符重写上述代码：\",\"extern crate foo; fn main() { foo::r#try(); }\"]},\"41\":{\"h\":\"构建脚本\",\"t\":[\"有时使用 cargo 正常构建还是不够的。也许你的 crate 在 cargo 成功编译之前需要一些先决条件，比如代码生成或者需要编译的一些本地代码。为了解决这个问题，我们构建了 cargo 可以运行的脚本。\",\"要向包中添加构建脚本，可以在 Cargo.toml 中指定它，如下所示：\",\"[package] ... build = \\\"build.rs\\\"\",\"跟默认情况不同，这里 cargo 将在项目目录中优先查找 build.rs 文件。（本句采用意译，英文原文为：Otherwise Cargo will look for a build.rs file in the project directory by default.）\"]},\"42\":{\"h\":\"怎么使用构建脚本\",\"t\":[\"构建脚本只是另一个 Rust 文件，此文件将在编译包中的任何其他内容之前，优先进行编译和调用。 因此，此文件可实现满足 crate 的先决条件。\",\"cargo 通过此处指定的可以使用的环境变量为脚本提供输入。（英文原文：Cargo provides the script with inputs via environment variables specified here that can be used.）\",\"此脚本通过 stdout （标准输出）提供输出。打印的所有行都写入到 target/debug/build/<pkg>/output。另外，以 cargo: 为前缀的行将由 cargo 直接解析，因此可用于定义包编译的参数。\",\"有关进一步的说明和示例，请阅读 cargo 规定说明文档。\"]},\"43\":{\"h\":\"约定规范\",\"t\":[\"在上一小节中，我们看到了以下目录层次结构：\",\"foo ├── Cargo.toml └── src └── main.rs\",\"假设我们要在同一个项目中有两个二进制可执行文件。 那要怎样做呢？\",\"很显然，cargo 支持这一点。正如我们之前看到的，默认二进制名称是 main，但可以通过将文件放在 bin/ 目录中来添加其他二进制可执行文件：\",\"foo ├── Cargo.toml └── src ├── main.rs └── bin └── my_other_bin.rs\",\"为了使得 cargo 只编译或运行这个二进制可执行文件，我们只需给 cargo 增加一个参数 --bin my_other_bin，其中 my_other_bin 是我们想要使用的二进制可执行文件的名称。\",\"除了可添加其他二进制可执行文件外，cargo 还支持更多功能，如基准测试，测试和示例。\",\"在下一节中，我们将更仔细地学习测试的内容。\"]},\"44\":{\"h\":\"依赖\",\"t\":[\"大多数程序都会依赖于某些库。如果你曾经手动管理过库依赖，那么你就知道这会带来的极大的痛苦。幸运的是，Rust 的生态链标配 cargo 工具！cargo 可以管理项目的依赖关系。\",\"下面创建一个新的 Rust 项目：\",\"# 二进制可执行文件 cargo new foo # 或者库 cargo new --lib foo\",\"对于本章的其余部分，我们选定创建的都是二进制可执行文件而不是库，但所有的概念都是相同的。\",\"完成上述命令后，将看到如下内容：\",\"foo ├── Cargo.toml └── src └── main.rs\",\"main.rs 是新项目的入口源文件——这里没什么新东西。 Cargo.toml 是本项目（foo）的 cargo 的配置文件。 浏览 Cargo.toml 文件，将看到类似以下的的内容：\",\"[package] name = \\\"foo\\\" version = \\\"0.1.0\\\" authors = [\\\"mark\\\"] [dependencies]\",\"package 下面的 name 字段表明项目的名称。 如果您发布 crate（后面将做更多介绍），那么 crates.io 将使用此字段标明的名称。 这也是编译时输出的二进制可执行文件的名称。\",\"version 字段是使用语义版本控制（Semantic Versioning）的 crate 版本号。\",\"authors 字段表明发布 crate 时的作者列表。\",\"dependencies 这部分可以让你为项目添加依赖。\",\"举个例子，假设我们希望程序有一个很棒的命令行界面（command-line interface，CLI））。 你可以在 crates.io（官方的 Rust 包注册服务）上找到很多很棒的 Rust 包。其中一个受欢迎的包是 clap（译注：一个命令行参数的解析器）。在撰写本文时，[clap] 最新发布的版本为 2.27.1。要在程序中添加依赖，我们可以很简单地在 Cargo.toml 文件中的 dependencies 项后面将以下内容添加进来 ：clap = \\\"2.27.1\\\"。当然，在 main.rs 文件中写上 extern crate clap，就和平常一样。 就是这样！你就可以在程序中开始使用 clap 了。\",\"cargo 还支持其他类型的依赖。 下面是一个简单的示例：\",\"[package] name = \\\"foo\\\" version = \\\"0.1.0\\\" authors = [\\\"mark\\\"] [dependencies] clap = \\\"2.27.1\\\" # 来自 crates.io rand = { git = \\\"https://github.com/rust-lang-nursery/rand\\\" } # 来自网上的仓库 bar = { path = \\\"../bar\\\" } # 来自本地文件系统的路径\",\"cargo 不仅仅是一个包依赖管理器。Cargo.toml 的所有可用配置选项都列在 格式规范中。\",\"要构建我们的项目，我们可以在项目目录中的任何位置（包括子目录！）执行 cargo build。我们也可以执行 cargo run 来构建和运行。请注意，这些命令将处理所有依赖，在需要时下载 crate，并构建所有内容，包括 crate。（请注意，它只重新构建尚未构建的内容，这和 make 类似）。\",\"瞧！这里的所有都和 cargo 有关！\"]},\"45\":{\"h\":\"测试\",\"t\":[\"我们知道测试是任何软件不可缺少的一部分！Rust 对单元和集成测试提供一流的支持（参见《Rust 程序设计语言》中的关于测试的章节）。\",\"通过上面链接的关于测试章节，我们看到了如何编写单元测试和集成测试。在代码目录组织上，我们可以将单元测试放在需要测试的模块中，并将集成测试放在源码中 tests/ 目录中：\",\"foo ├── Cargo.toml ├── src │ └── main.rs └── tests ├── my_test.rs └── my_other_test.rs\",\"tests 目录下的每个文件都是一个单独的集成测试。\",\"cargo 很自然地提供了一种便捷的方法来运行所有测试！\",\"cargo test\",\"你将会看到像这样的输出：\",\"$ cargo test Compiling blah v0.1.0 (file:///nobackup/blah) Finished dev [unoptimized + debuginfo] target(s) in 0.89 secs Running target/debug/deps/blah-d3b32b97275ec472 running 3 tests test test_bar ... ok test test_baz ... ok test test_foo_bar ... ok test test_foo ... ok test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\",\"你还可以运行如下测试，其中名称匹配一个模式：\",\"cargo test test_foo\",\"$ cargo test test_foo Compiling blah v0.1.0 (file:///nobackup/blah) Finished dev [unoptimized + debuginfo] target(s) in 0.35 secs Running target/debug/deps/blah-d3b32b97275ec472 running 2 tests test test_foo ... ok test test_foo_bar ... ok test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out\",\"需要注意的一点是：cargo 可能同时进行多项测试，因此请确保它们不会相互竞争。例如，如果它们都输出到文件，则应该将它们写入不同的文件。\"]},\"46\":{\"h\":\"From 和 Into\",\"t\":[\"From 和 Into 两个 trait 是内部相关联的，实际上这是它们实现的一部分。如果我们能够从类型 B 得到类型 A，那么很容易相信我们也能够把类型 A 转换为类型 B。\"]},\"47\":{\"h\":\"\",\"t\":[\"From trait 允许一种类型定义 “怎么根据另一种类型生成自己”，因此它提供了一种类型转换的简单机制。在标准库中有无数 From 的实现，规定原生类型及其他常见类型的转换功能。\",\"比如，可以很容易地把 str 转换成 String：\",\"let my_str = \\\"hello\\\"; let my_string = String::from(my_str);\",\"也可以为我们自己的类型定义转换机制：\",\"use std::convert::From; #[derive(Debug)] struct Number { value: i32, } impl From<i32> for Number { fn from(item: i32) -> Self { Number { value: item } } } fn main() { let num = Number::from(30); println!(\\\"My number is {:?}\\\", num); }\"]},\"48\":{\"h\":\"\",\"t\":[\"Into trait 就是把 From trait 倒过来而已。也就是说，如果你为你的类型实现了 From，那么同时你也就免费获得了 Into。\",\"使用 Into trait 通常要求指明要转换到的类型，因为编译器大多数时候不能推断它。不过考虑到我们免费获得了 Into，这点代价不值一提。\",\"use std::convert::Into; #[derive(Debug)] struct Number { value: i32, } impl Into<Number> for i32 { fn into(self) -> Number { Number { value: self } } } fn main() { let int = 5; // 试试删除类型注释 let num: Number = int.into(); println!(\\\"My number is {:?}\\\", num); }\"]},\"49\":{\"h\":\"ToString 和 FromStr\"},\"50\":{\"h\":\"\",\"t\":[\"要把任何类型转换成 String，只需要实现那个类型的 ToString trait。然而不要直接这么做，您应该实现fmt::Display trait，它会自动提供 ToString，并且还可以用来打印类型，就像 print! 一节中讨论的那样。\",\"use std::fmt; struct Circle { radius: i32 } impl fmt::Display for Circle { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { write!(f, \\\"Circle of radius {}\\\", self.radius) } } fn main() { let circle = Circle { radius: 6 }; println!(\\\"{}\\\", circle.to_string()); }\",\"译注：一个实现 ToString 的例子\",\"use std::string::ToString; struct Circle { radius: i32 } impl ToString for Circle { fn to_string(&self) -> String { format!(\\\"Circle of radius {:?}\\\", self.radius) } } fn main() { let circle = Circle { radius: 6 }; println!(\\\"{}\\\", circle.to_string()); }\"]},\"51\":{\"h\":\"解析字符串\",\"t\":[\"我们经常需要把字符串转成数字。完成这项工作的标准手段是用 parse 函数。我们得提供要转换到的类型，这可以通过使用类型推断，或者用 “涡轮鱼” 语法（turbo fish，<>）实现。\",\"只要对目标类型实现了 FromStr trait，就可以用 parse 把字符串转换成目标类型。 标准库中已经给无数种类型实现了 FromStr。如果要转换到用户定义类型，只要手动实现FromStr 就行。\",\"fn main() { let parsed: i32 = \\\"5\\\".parse().unwrap(); let turbo_parsed = \\\"10\\\".parse::<i32>().unwrap(); let sum = parsed + turbo_parsed; println!{\\\"Sum: {:?}\\\", sum}; }\"]},\"52\":{\"h\":\"TryFrom and TryInto\",\"t\":[\"类似于 From 和 Into，TryFrom 和 TryInto 是类型转换的通用 trait。不同于 From/Into 的是，TryFrom 和 TryInto trait 用于易出错的转换，也正因如此，其返回值是 Result 型。\",\"use std::convert::TryFrom; use std::convert::TryInto; #[derive(Debug, PartialEq)] struct EvenNumber(i32); impl TryFrom<i32> for EvenNumber { type Error = (); fn try_from(value: i32) -> Result<Self, Self::Error> { if value % 2 == 0 { Ok(EvenNumber(value)) } else { Err(()) } } } fn main() { // TryFrom assert_eq!(EvenNumber::try_from(8), Ok(EvenNumber(8))); assert_eq!(EvenNumber::try_from(5), Err(())); // TryInto let result: Result<EvenNumber, ()> = 8i32.try_into(); assert_eq!(result, Ok(EvenNumber(8))); let result: Result<EvenNumber, ()> = 5i32.try_into(); assert_eq!(result, Err(())); }\"]},\"53\":{\"h\":\"库\",\"t\":[\"让我们创建一个库，然后看看如何把它链接到另一个 crate。\",\"pub fn public_function() { println!(\\\"called rary's `public_function()`\\\"); } fn private_function() { println!(\\\"called rary's `private_function()`\\\"); } pub fn indirect_access() { print!(\\\"called rary's `indirect_access()`, that\\\\n> \\\"); private_function(); }\",\"$ rustc --crate-type=lib rary.rs $ ls lib* library.rlib\",\"默认情况下，库会使用 crate 文件的名字，前面加上 “lib” 前缀，但这个默认名称可以使用 crate_name 属性 覆盖。\"]},\"54\":{\"h\":\"使用库\",\"t\":[\"要将一个 crate 链接到上节新建的库，可以使用 rustc 的 --extern 选项。然后将所有的物件导入到与库名相同的模块下。此模块的操作通常与任何其他模块相同。\",\"// extern crate rary; // 在 Rust 2015 版或更早版本需要这个导入语句 fn main() { rary::public_function(); // 报错！ `private_function` 是私有的 //rary::private_function(); rary::indirect_access(); }\",\"# library.rlib 是已编译好的库的路径，这里假设它在同一目录下： $ rustc executable.rs --extern rary=library.rlib --edition=2018 && ./executable called rary's `public_function()` called rary's `indirect_access()`, that > called rary's `private_function()`\"]},\"55\":{\"h\":\"常量\",\"t\":[\"Rust 有两种常量，可以在任意作用域声明，包括全局作用域。它们都需要显式的类型声明：\",\"const：不可改变的值（通常使用这种）。\",\"static：具有 'static 生命周期的，可以是可变的变量（译注：须使用static mut 关键字）。\",\"有个特例就是 \\\"string\\\" 字面量。它可以不经改动就被赋给一个 static 变量，因为它的类型标记：&'static str 就包含了所要求的生命周期 'static。其他的引用类型都必须特地声明，使之拥有 'static 生命周期。这两种引用类型的差异似乎也无关紧要，因为无论如何，static 变量都得显式地声明。\",\"// 全局变量是在所有其他作用域之外声明的。 static LANGUAGE: &'static str = \\\"Rust\\\"; const THRESHOLD: i32 = 10; fn is_big(n: i32) -> bool { // 在一般函数中访问常量 n > THRESHOLD } fn main() { let n = 16; // 在 main 函数（主函数）中访问常量 println!(\\\"This is {}\\\", LANGUAGE); println!(\\\"The threshold is {}\\\", THRESHOLD); println!(\\\"{} is {}\\\", n, if is_big(n) { \\\"big\\\" } else { \\\"small\\\" }); // 报错！不能修改一个 `const` 常量。 THRESHOLD = 5; // 改正 ^ 注释掉此行 }\"]},\"56\":{\"h\":\"参见：\",\"t\":[\"const/static RFC,'static 生命周期\"]},\"57\":{\"h\":\"枚举\",\"t\":[\"enum 关键字允许创建一个从数个不同取值中选其一的枚举类型（enumeration）。任何一个在 struct 中合法的取值在 enum 中也合法。\",\"// 该属性用于隐藏对未使用代码的警告。 #![allow(dead_code)] // 创建一个 `enum`（枚举）来对 web 事件分类。注意变量名和类型共同指定了 `enum` // 取值的种类：`PageLoad` 不等于 `PageUnload`，`KeyPress(char)` 不等于 // `Paste(String)`。各个取值不同，互相独立。 enum WebEvent { // 一个 `enum` 可以是单元结构体（称为 `unit-like` 或 `unit`）， PageLoad, PageUnload, // 或者一个元组结构体， KeyPress(char), Paste(String), // 或者一个普通的结构体。 Click { x: i64, y: i64 } } // 此函数将一个 `WebEvent` enum 作为参数，无返回值。 fn inspect(event: WebEvent) { match event { WebEvent::PageLoad => println!(\\\"page loaded\\\"), WebEvent::PageUnload => println!(\\\"page unloaded\\\"), // 从 `enum` 里解构出 `c`。 WebEvent::KeyPress(c) => println!(\\\"pressed '{}'.\\\", c), WebEvent::Paste(s) => println!(\\\"pasted \\\\\\\"{}\\\\\\\".\\\", s), // 把 `Click` 解构给 `x` and `y`。 WebEvent::Click { x, y } => { println!(\\\"clicked at x={}, y={}.\\\", x, y); }, } } fn main() { let pressed = WebEvent::KeyPress('x'); // `to_owned()` 从一个字符串切片中创建一个具有所有权的 `String`。 let pasted = WebEvent::Paste(\\\"my text\\\".to_owned()); let click = WebEvent::Click { x: 20, y: 80 }; let load = WebEvent::PageLoad; let unload = WebEvent::PageUnload; inspect(pressed); inspect(pasted); inspect(click); inspect(load); inspect(unload); }\"]},\"58\":{\"h\":\"类型别名\",\"t\":[\"若使用类型别名，则可以通过其别名引用每个枚举变量。当枚举的名称太长或者太一般化，且你想要对其重命名，那么这对你会有所帮助。\",\"enum VeryVerboseEnumOfThingsToDoWithNumbers { Add, Subtract, } // 创建一个类型别名 type Operations = VeryVerboseEnumOfThingsToDoWithNumbers; fn main() { // 我们可以通过别名引用每个枚举变量，避免使用又长又不方便的枚举名字 let x = Operations::Add; }\",\"最常见的情况就是在 impl 块中使用 Self 别名。\",\"enum VeryVerboseEnumOfThingsToDoWithNumbers { Add, Subtract, } impl VeryVerboseEnumOfThingsToDoWithNumbers { fn run(&self, x: i32, y: i32) -> i32 { match self { Self::Add => x + y, Self::Subtract => x - y, } } }\",\"该功能已在 Rust 中稳定下来， 可以阅读 stabilization report 来了解更多有关枚举和类型别名的知识。\"]},\"59\":{\"h\":\"参见：\",\"t\":[\"match, fn, 和 String, “类型别名枚举变量” 的 RFC\"]},\"60\":{\"h\":\"结构体\",\"t\":[\"结构体（structure，缩写成 struct）有 3 种类型，使用 struct 关键字来创建：\",\"元组结构体（tuple struct），事实上就是具名元组而已。\",\"经典的 C 语言风格结构体（C struct）。\",\"单元结构体（unit struct），不带字段，在泛型中很有用。\",\"#[derive(Debug)] struct Person { name: String, age: u8, } // 单元结构体 struct Unit; // 元组结构体 struct Pair(i32, f32); // 带有两个字段的结构体 struct Point { x: f32, y: f32, } // 结构体可以作为另一个结构体的字段 #[allow(dead_code)] struct Rectangle { // 可以在空间中给定左上角和右下角在空间中的位置来指定矩形。 top_left: Point, bottom_right: Point, } fn main() { // 使用简单的写法初始化字段，并创建结构体 let name = String::from(\\\"Peter\\\"); let age = 27; let peter = Person { name, age }; // 以 Debug 方式打印结构体 println!(\\\"{:?}\\\", peter); // 实例化结构体 `Point` let point: Point = Point { x: 10.3, y: 0.4 }; // 访问 point 的字段 println!(\\\"point coordinates: ({}, {})\\\", point.x, point.y); // 使用结构体更新语法创建新的 point， // 这样可以用到之前的 point 的字段 let bottom_right = Point { x: 5.2, ..point }; // `bottom_right.y` 与 `point.y` 一样，因为这个字段就是从 `point` 中来的 println!(\\\"second point: ({}, {})\\\", bottom_right.x, bottom_right.y); // 使用 `let` 绑定来解构 point let Point { x: left_edge, y: top_edge } = point; let _rectangle = Rectangle { // 结构体的实例化也是一个表达式 top_left: Point { x: left_edge, y: top_edge }, bottom_right: bottom_right, }; // 实例化一个单元结构体 let _unit = Unit; // 实例化一个元组结构体 let pair = Pair(1, 0.1); // 访问元组结构体的字段 println!(\\\"pair contains {:?} and {:?}\\\", pair.0, pair.1); // 解构一个元组结构体 let Pair(integer, decimal) = pair; println!(\\\"pair contains {:?} and {:?}\\\", integer, decimal); }\"]},\"61\":{\"h\":\"动手试一试:\",\"t\":[\"增加一个计算 Rectangle （长方形）面积的函数 rect_area（尝试使用嵌套的解构方式）。\",\"增加一个函数 square，接受的参数是一个 Point 和一个 f32，并返回一个 Rectangle（长方形），其左上角位于该点上，长和宽都对应于 f32。\"]},\"62\":{\"h\":\"参见:\",\"t\":[\"属性 和 解构\"]},\"63\":{\"h\":\"遍历 Result\",\"t\":[\"Iter::map 操作可能失败，比如：\",\"fn main() { let strings = vec![\\\"tofu\\\", \\\"93\\\", \\\"18\\\"]; let numbers: Vec<_> = strings .into_iter() .map(|s| s.parse::<i32>()) .collect(); println!(\\\"Results: {:?}\\\", numbers); }\",\"我们来看一些处理这种问题的策略：\"]},\"64\":{\"h\":\"使用 忽略失败的项\",\"t\":[\"filter_map 会调用一个函数，过滤掉为 None 的所有结果。\",\"fn main() { let strings = vec![\\\"tofu\\\", \\\"93\\\", \\\"18\\\"]; let numbers: Vec<_> = strings .into_iter() .filter_map(|s| s.parse::<i32>().ok()) .collect(); println!(\\\"Results: {:?}\\\", numbers); }\"]},\"65\":{\"h\":\"使用 使整个操作失败\",\"t\":[\"Result 实现了 FromIter，因此结果的向量（Vec<Result<T, E>>）可以被转换成结果包裹着向量（Result<Vec<T>, E>）。一旦找到一个 Result::Err ，遍历就被终止。\",\"fn main() { let strings = vec![\\\"tofu\\\", \\\"93\\\", \\\"18\\\"]; let numbers: Result<Vec<_>, _> = strings .into_iter() .map(|s| s.parse::<i32>()) .collect(); println!(\\\"Results: {:?}\\\", numbers); }\",\"同样的技巧可以对 Option 使用。\"]},\"66\":{\"h\":\"使用 收集所有合法的值与错误\",\"t\":[\"fn main() { let strings = vec![\\\"tofu\\\", \\\"93\\\", \\\"18\\\"]; let (numbers, errors): (Vec<_>, Vec<_>) = strings .into_iter() .map(|s| s.parse::<i32>()) .partition(Result::is_ok); println!(\\\"Numbers: {:?}\\\", numbers); println!(\\\"Errors: {:?}\\\", errors); }\",\"当你看着这些结果时，你会发现所有东西还在 Result 中保存着。要取出它们，需要一些模板化的代码。\",\"fn main() { let strings = vec![\\\"tofu\\\", \\\"93\\\", \\\"18\\\"]; let (numbers, errors): (Vec<_>, Vec<_>) = strings .into_iter() .map(|s| s.parse::<i32>()) .partition(Result::is_ok); let numbers: Vec<_> = numbers.into_iter().map(Result::unwrap).collect(); let errors: Vec<_> = errors.into_iter().map(Result::unwrap_err).collect(); println!(\\\"Numbers: {:?}\\\", numbers); println!(\\\"Errors: {:?}\\\", errors); }\"]},\"67\":{\"h\":\"处理多种错误类型\",\"t\":[\"前面出现的例子都是很方便的情况；都是 Result 和其他 Result 交互，还有 Option 和其他 Option 交互。\",\"有时 Option 需要和 Result 进行交互，或是 Result<T, Error1> 需要和Result<T, Error2> 进行交互。在这类情况下，我们想要以一种方式来管理不同的错误类型，使得它们可组合且易于交互。\",\"在下面代码中，unwrap 的两个实例生成了不同的错误类型。Vec::first 返回一个Option，而 parse::<i32> 返回一个 Result<i32, ParseIntError>：\",\"fn double_first(vec: Vec<&str>) -> i32 { let first = vec.first().unwrap(); // 生成错误 1 2 * first.parse::<i32>().unwrap() // 生成错误 2 } fn main() { let numbers = vec![\\\"42\\\", \\\"93\\\", \\\"18\\\"]; let empty = vec![]; let strings = vec![\\\"tofu\\\", \\\"93\\\", \\\"18\\\"]; println!(\\\"The first doubled is {}\\\", double_first(numbers)); println!(\\\"The first doubled is {}\\\", double_first(empty)); // 错误1：输入 vector 为空 println!(\\\"The first doubled is {}\\\", double_first(strings)); // 错误2：此元素不能解析成数字 }\",\"在下面几节中，我们会看到处理这类问题的几种策略。\"]},\"68\":{\"h\":\"Option 和 unwrap\",\"t\":[\"上个例子展示了如何主动地引入程序失败（program failure）。当公主收到蛇这件不合适的礼物时，我们就让程序 panic。但是，如果公主期待收到礼物，却没收到呢？这同样是一件糟糕的事情，所以我们要想办法来解决这个问题！\",\"我们可以检查空字符串（\\\"\\\"），就像处理蛇那样。但既然我们在用 Rust，不如让编译器辨别没有礼物的情况。\",\"在标准库（std）中有个叫做 Option<T>（option 中文意思是 “选项”）的枚举类型，用于有 “不存在” 的可能性的情况。它表现为以下两个 “option”（选项）中的一个：\",\"Some(T)：找到一个属于 T 类型的元素\",\"None：找不到相应元素\",\"这些选项可以通过 match 显式地处理，或使用 unwrap 隐式地处理。隐式处理要么返回 Some 内部的元素，要么就 panic。\",\"请注意，手动使用 expect 方法自定义 panic 信息是可能的，但相比显式处理，unwrap 的输出仍显得不太有意义。在下面例子中，显式处理将举出更受控制的结果，同时如果需要的话，仍然可以使程序 panic。\",\"// 平民（commoner）们见多识广，收到什么礼物都能应对。 // 所有礼物都显式地使用 `match` 来处理。 fn give_commoner(gift: Option<&str>) { // 指出每种情况下的做法。 match gift { Some(\\\"snake\\\") => println!(\\\"Yuck! I'm throwing that snake in a fire.\\\"), Some(inner) => println!(\\\"{}? How nice.\\\", inner), None => println!(\\\"No gift? Oh well.\\\"), } } // 养在深闺人未识的公主见到蛇就会 `panic`（恐慌）。 // 这里所有的礼物都使用 `unwrap` 隐式地处理。 fn give_princess(gift: Option<&str>) { // `unwrap` 在接收到 `None` 时将返回 `panic`。 let inside = gift.unwrap(); if inside == \\\"snake\\\" { panic!(\\\"AAAaaaaa!!!!\\\"); } println!(\\\"I love {}s!!!!!\\\", inside); } fn main() { let food = Some(\\\"chicken\\\"); let snake = Some(\\\"snake\\\"); let void = None; give_commoner(food); give_commoner(snake); give_commoner(void); let bird = Some(\\\"robin\\\"); let nothing = None; give_princess(bird); give_princess(nothing); }\"]},\"69\":{\"h\":\"panic\",\"t\":[\"我们将要看到的最简单的错误处理机制就是 panic。它会打印一个错误消息，开始回退（unwind）任务，且通常会退出程序。这里我们显式地在错误条件下调用 panic：\",\"fn give_princess(gift: &str) { // 公主讨厌蛇，所以如果公主表示厌恶的话我们要停止！ if gift == \\\"snake\\\" { panic!(\\\"AAAaaaaa!!!!\\\"); } println!(\\\"I love {}s!!!!!\\\", gift); } fn main() { give_princess(\\\"teddy bear\\\"); give_princess(\\\"snake\\\"); }\"]},\"70\":{\"h\":\"结果 Result\",\"t\":[\"Result 是 Option 类型的更丰富的版本，描述的是可能的错误而不是可能的不存在。\",\"也就是说，Result<T，E> 可以有两个结果的其中一个：\",\"Ok<T>：找到 T 元素\",\"Err<E>：找到 E 元素，E 即表示错误的类型。\",\"按照约定，预期结果是 “Ok”，而意外结果是 “Err”。\",\"Result 有很多类似 Option 的方法。例如 unwrap()，它要么举出元素T，要么就 panic。 对于事件的处理，Result 和 Option 有很多相同的组合算子。\",\"在使用 Rust 时，你可能会遇到返回 Result 类型的方法，例如 parse() 方法。它并不是总能把字符串解析成指定的类型，所以 parse() 返回一个Result 表示可能的失败。\",\"我们来看看当 parse() 字符串成功和失败时会发生什么：\",\"fn multiply(first_number_str: &str, second_number_str: &str) -> i32 { // 我们试着用 `unwrap()` 把数字放出来。它会咬我们一口吗？ let first_number = first_number_str.parse::<i32>().unwrap(); let second_number = second_number_str.parse::<i32>().unwrap(); first_number * second_number } fn main() { let twenty = multiply(\\\"10\\\", \\\"2\\\"); println!(\\\"double is {}\\\", twenty); let tt = multiply(\\\"t\\\", \\\"2\\\"); println!(\\\"double is {}\\\", tt); }\",\"在失败的情况下，parse() 产生一个错误，留给 unwrap() 来解包并产生 panic。另外，panic 会退出我们的程序，并提供一个让人很不爽的错误消息。\",\"为了改善错误消息的质量，我们应该更具体地了解返回类型并考虑显式地处理错误。\"]},\"71\":{\"h\":\"for 循环\"},\"72\":{\"h\":\"for 与区间\",\"t\":[\"for in 结构可以遍历一个 Iterator（迭代器）。创建迭代器的一个最简单的方法是使用区间标记 a..b。这会生成从 a（包含此值） 到 b（不含此值）的，步长为 1 的一系列值。\",\"让我们使用 for 代替 while 来写 FizzBuzz 程序。\",\"fn main() { // `n` 将在每次迭代中分别取 1, 2, ..., 100 for n in 1..101 { if n % 15 == 0 { println!(\\\"fizzbuzz\\\"); } else if n % 3 == 0 { println!(\\\"fizz\\\"); } else if n % 5 == 0 { println!(\\\"buzz\\\"); } else { println!(\\\"{}\\\", n); } } }\",\"或者，可以使用a..=b表示两端都包含在内的范围。上面的代码可以写成：\",\"fn main() { // `n` 将在每次迭代中分别取 1, 2, ..., 100 for n in 1..=100 { if n % 15 == 0 { println!(\\\"fizzbuzz\\\"); } else if n % 3 == 0 { println!(\\\"fizz\\\"); } else if n % 5 == 0 { println!(\\\"buzz\\\"); } else { println!(\\\"{}\\\", n); } } }\"]},\"73\":{\"h\":\"for 与迭代器\",\"t\":[\"for in 结构能以几种方式与 Iterator 互动。在 迭代器 trait 一节将会谈到，如果没有特别指定，for 循环会对给出的集合应用 into_iter 函数，把它转换成一个迭代器。这并不是把集合变成迭代器的唯一方法，其他的方法有 iter 和iter_mut 函数。\",\"这三个函数会以不同的方式返回集合中的数据。\",\"iter - 在每次迭代中借用集合中的一个元素。这样集合本身不会被改变，循环之后仍可以使用。\",\"fn main() { let names = vec![\\\"Bob\\\", \\\"Frank\\\", \\\"Ferris\\\"]; for name in names.iter() { match name { &\\\"Ferris\\\" => println!(\\\"There is a rustacean among us!\\\"), _ => println!(\\\"Hello {}\\\", name), } } }\",\"译注：Ferris 是 Rust 的非官方吉祥物。\",\"into_iter - 会消耗集合。在每次迭代中，集合中的数据本身会被提供。一旦集合被消耗了，之后就无法再使用了，因为它已经在循环中被 “移除”（move）了。\",\"fn main() { let names = vec![\\\"Bob\\\", \\\"Frank\\\", \\\"Ferris\\\"]; for name in names.into_iter() { match name { \\\"Ferris\\\" => println!(\\\"There is a rustacean among us!\\\"), _ => println!(\\\"Hello {}\\\", name), } } }\",\"iter_mut - 可变地（mutably）借用集合中的每个元素，从而允许集合被就地修改。\",\"fn main() { let mut names = vec![\\\"Bob\\\", \\\"Frank\\\", \\\"Ferris\\\"]; for name in names.iter_mut() { *name = match name { &mut \\\"Ferris\\\" => \\\"There is a rustacean among us!\\\", _ => \\\"Hello\\\", } } println!(\\\"names: {:?}\\\", names); }\",\"在上面这些代码中，注意 match 的分支中所写的类型不同，这是不同迭代方式的关键区别。因为类型不同，能够执行的操作当然也不同。\"]},\"74\":{\"h\":\"参见：\",\"t\":[\"Iterator\"]},\"75\":{\"h\":\"if/else\",\"t\":[\"if-else 分支判断和其他语言类似。不同的是，Rust 语言中的布尔判断条件不必使用小括号包裹，且每个条件后面都跟着一个代码块。if-else 条件选择是一个表达式，并且所有分支都必须返回相同的类型。\",\"fn main() { let n = 5; if n < 0 { print!(\\\"{} is negative\\\", n); } else if n > 0 { print!(\\\"{} is positive\\\", n); } else { print!(\\\"{} is zero\\\", n); } let big_n = if n < 10 && n > -10 { println!(\\\", and is a small number, increase ten-fold\\\"); // 这个表达式返回一个 `i32` 类型。 10 * n } else { println!(\\\", and is a big number, half the number\\\"); // 这个表达式也必须返回一个 `i32` 类型。 n / 2 // 试一试 ^ 试着加上一个分号来结束这条表达式。 }; // ^ 不要忘记在这里加上一个分号！所有的 `let` 绑定都需要它。 println!(\\\"{} -> {}\\\", n, big_n); }\"]},\"76\":{\"h\":\"if let\",\"t\":[\"在一些场合下，用 match 匹配枚举类型并不优雅。比如：\",\"// 将 `optional` 定为 `Option<i32>` 类型 let optional = Some(7); match optional { Some(i) => { println!(\\\"This is a really long string and `{:?}`\\\", i); // ^ 行首需要 2 层缩进。这里从 optional 中解构出 `i`。 // 译注：正确的缩进是好的，但并不是 “不缩进就不能运行” 这个意思。 }, _ => {}, // ^ 必须有，因为 `match` 需要覆盖全部情况。不觉得这行很多余吗？ };\",\"if let 在这样的场合要简洁得多，并且允许指明数种失败情形下的选项：\",\"fn main() { // 全部都是 `Option<i32>` 类型 let number = Some(7); let letter: Option<i32> = None; let emoticon: Option<i32> = None; // `if let` 结构读作：若 `let` 将 `number` 解构成 `Some(i)`，则执行 // 语句块（`{}`） if let Some(i) = number { println!(\\\"Matched {:?}!\\\", i); } // 如果要指明失败情形，就使用 else： if let Some(i) = letter { println!(\\\"Matched {:?}!\\\", i); } else { // 解构失败。切换到失败情形。 println!(\\\"Didn't match a number. Let's go with a letter!\\\"); }; // 提供另一种失败情况下的条件。 let i_like_letters = false; if let Some(i) = emoticon { println!(\\\"Matched {:?}!\\\", i); // 解构失败。使用 `else if` 来判断是否满足上面提供的条件。 } else if i_like_letters { println!(\\\"Didn't match a number. Let's go with a letter!\\\"); } else { // 条件的值为 false。于是以下是默认的分支： println!(\\\"I don't like letters. Let's go with an emoticon :)!\\\"); }; }\",\"同样，可以用 if let 匹配任何枚举值：\",\"// 以这个 enum 类型为例 enum Foo { Bar, Baz, Qux(u32) } fn main() { // 创建变量 let a = Foo::Bar; let b = Foo::Baz; let c = Foo::Qux(100); // 变量 a 匹配到了 Foo::Bar if let Foo::Bar = a { println!(\\\"a is foobar\\\"); } // 变量 b 没有匹配到 Foo::Bar，因此什么也不会打印。 if let Foo::Bar = b { println!(\\\"b is foobar\\\"); } // 变量 c 匹配到了 Foo::Qux，它带有一个值，就和上面例子中的 Some() 类似。 if let Foo::Qux(value) = c { println!(\\\"c is {}\\\", value); } }\",\"另一个好处是：if let 允许匹配枚举非参数化的变量，即枚举未注明 #[derive(PartialEq)]，我们也没有为其实现 PartialEq。在这种情况下，通常 if Foo::Bar==a 会出错，因为此类枚举的实例不具有可比性。但是，if let 是可行的。\",\"你想挑战一下吗？使用 if let修复以下示例：\",\"// 该枚举故意未注明 `#[derive(PartialEq)]`， // 并且也没为其实现 `PartialEq`。这就是为什么下面比较 `Foo::Bar==a` 会失败的原因。 enum Foo {Bar} fn main() { let a = Foo::Bar; // 变量匹配 Foo::Bar if Foo::Bar == a { // ^-- 这就是编译时发现的错误。使用 `if let` 来替换它。 println!(\\\"a is foobar\\\"); } }\"]},\"77\":{\"h\":\"参见：\",\"t\":[\"枚举，Option，和相关的 RFC\"]},\"78\":{\"h\":\"loop 循环\",\"t\":[\"Rust 提供了 loop 关键字来表示一个无限循环。\",\"可以使用 break 语句在任何时候退出一个循环，还可以使用 continue 跳过循环体的剩余部分并开始下一轮循环。\",\"fn main() { let mut count = 0u32; println!(\\\"Let's count until infinity!\\\"); // 无限循环 loop { count += 1; if count == 3 { println!(\\\"three\\\"); // 跳过这次迭代的剩下内容 continue; } println!(\\\"{}\\\", count); if count == 5 { println!(\\\"OK, that's enough\\\"); // 退出循环 break; } } }\"]},\"79\":{\"h\":\"match 匹配\",\"t\":[\"Rust 通过 match 关键字来提供模式匹配，和 C 语言的 switch 用法类似。第一个匹配分支会被比对，并且所有可能的值都必须被覆盖。\",\"fn main() { let number = 13; // 试一试 ^ 将不同的值赋给 `number` println!(\\\"Tell me about {}\\\", number); match number { // 匹配单个值 1 => println!(\\\"One!\\\"), // 匹配多个值 2 | 3 | 5 | 7 | 11 => println!(\\\"This is a prime\\\"), // 试一试 ^ 将 13 添加到质数列表中 // 匹配一个闭区间范围 13..=19 => println!(\\\"A teen\\\"), // 处理其他情况 _ => println!(\\\"Ain't special\\\"), // 试一试 ^ 注释掉这个总括性的分支 } let boolean = true; // match 也是一个表达式 let binary = match boolean { // match 分支必须覆盖所有可能的值 false => 0, true => 1, // 试一试 ^ 将其中一条分支注释掉 }; println!(\\\"{} -> {}\\\", boolean, binary); }\"]},\"80\":{\"h\":\"while 循环\",\"t\":[\"while 关键字可以用作当型循环（当条件满足时循环）。\",\"让我们用 while 循环写一下臭名昭著的 FizzBuzz（译者补充：LeetCode 上的 FizzBuzz 问题描述） 程序。\",\"fn main() { // 计数器变量 let mut n = 1; // 当 `n` 小于 101 时循环 while n < 101 { if n % 15 == 0 { println!(\\\"fizzbuzz\\\"); } else if n % 3 == 0 { println!(\\\"fizz\\\"); } else if n % 5 == 0 { println!(\\\"buzz\\\"); } else { println!(\\\"{}\\\", n); } // 计数器值加 1 n += 1; } }\"]},\"81\":{\"h\":\"while let\",\"t\":[\"和 if let 类似，while let 也可以把别扭的 match 改写得好看一些。考虑下面这段使 i 不断增加的代码：\",\"// 将 `optional` 设为 `Option<i32>` 类型 let mut optional = Some(0); // 重复运行这个测试。 loop { match optional { // 如果 `optional` 解构成功，就执行下面语句块。 Some(i) => { if i > 9 { println!(\\\"Greater than 9, quit!\\\"); optional = None; } else { println!(\\\"`i` is `{:?}`. Try again.\\\", i); optional = Some(i + 1); } // ^ 需要三层缩进！ }, // 当解构失败时退出循环： _ => { break; } // ^ 为什么必须写这样的语句呢？肯定有更优雅的处理方式！ } }\",\"使用 while let 可以使这段代码变得更加优雅：\",\"fn main() { // 将 `optional` 设为 `Option<i32>` 类型 let mut optional = Some(0); // 这读作：当 `let` 将 `optional` 解构成 `Some(i)` 时，就 // 执行语句块（`{}`）。否则就 `break`。 while let Some(i) = optional { if i > 9 { println!(\\\"Greater than 9, quit!\\\"); optional = None; } else { println!(\\\"`i` is `{:?}`. Try again.\\\", i); optional = Some(i + 1); } // ^ 使用的缩进更少，并且不用显式地处理失败情况。 } // ^ `if let` 有可选的 `else`/`else if` 分句， // 而 `while let` 没有。 }\"]},\"82\":{\"h\":\"参见：\",\"t\":[\"枚举，Option，和相关的 RFC\"]},\"83\":{\"h\":\"闭包\",\"t\":[\"Rust 中的闭包（closure），也叫做 lambda 表达式或者 lambda，是一类能够捕获周围作用域中变量的函数。例如，一个可以捕获 x 变量的闭包如下：\",\"|val| val + x\",\"它们的语法和能力使它们在临时（on the fly）使用时相当方便。调用一个闭包和调用一个函数完全相同，不过调用闭包时，输入和返回类型两者都可以自动推导，而输入变量名必须指明。\",\"其他的特点包括：\",\"声明时使用 || 替代 () 将输入参数括起来。\",\"函数体定界符（{}）对于单个表达式是可选的，其他情况必须加上。\",\"有能力捕获外部环境的变量。\",\"fn main() { // 通过闭包和函数分别实现自增。 // 译注：下面这行是使用函数的实现 fn function (i: i32) -> i32 { i + 1 } // 闭包是匿名的，这里我们将它们绑定到引用。 // 类型标注和函数的一样，不过类型标注和使用 `{}` 来围住函数体都是可选的。 // 这些匿名函数（nameless function）被赋值给合适地命名的变量。 let closure_annotated = |i: i32| -> i32 { i + 1 }; let closure_inferred = |i | i + 1 ; // 译注：将闭包绑定到引用的说法可能不准。 // 据[语言参考](https://doc.rust-lang.org/beta/reference/types.html#closure-types) // 闭包表达式产生的类型就是 “闭包类型”，不属于引用类型，而且确实无法对上面两个 // `closure_xxx` 变量解引用。 let i = 1; // 调用函数和闭包。 println!(\\\"function: {}\\\", function(i)); println!(\\\"closure_annotated: {}\\\", closure_annotated(i)); println!(\\\"closure_inferred: {}\\\", closure_inferred(i)); // 没有参数的闭包，返回一个 `i32` 类型。 // 返回类型是自动推导的。 let one = || 1; println!(\\\"closure returning one: {}\\\", one()); }\"]},\"84\":{\"h\":\"发散函数\",\"t\":[\"发散函数（diverging function）绝不会返回。 它们使用 ! 标记，这是一个空类型。\",\"fn foo() -> ! { panic!(\\\"This call never returns.\\\"); }\",\"和所有其他类型相反，这个类型无法实例化，因为此类型可能具有的所有可能值的集合为空。 注意，它与 () 类型不同，后者只有一个可能的值。\",\"如下面例子，虽然返回值中没有信息，但此函数会照常返回。\",\"fn some_fn() { () } fn main() { let a: () = some_fn(); println!(\\\"This function returns and you can see this line.\\\") }\",\"下面这个函数相反，这个函数永远不会将控制内容返回给调用者。\",\"#![feature(never_type)] fn main() { let x: ! = panic!(\\\"This call never returns.\\\"); println!(\\\"You will never see this line!\\\"); }\",\"虽然这看起来像是一个抽象的概念，但实际上这非常有用且方便。这种类型的主要优点是它可以被转换为任何其他类型，从而可以在需要精确类型的地方使用，例如在 match 匹配分支。 这允许我们编写如下代码：\",\"fn main() { fn sum_odd_numbers(up_to: u32) -> u32 { let mut acc = 0; for i in 0..up_to { // 注意这个 match 表达式的返回值必须为 u32， // 因为 “addition” 变量是这个类型。 let addition: u32 = match i%2 == 1 { // “i” 变量的类型为 u32，这毫无问题。 true => i, // 另一方面，“continue” 表达式不返回 u32，但它仍然没有问题， // 因为它永远不会返回，因此不会违反匹配表达式的类型要求。 false => continue, }; acc += addition; } acc } println!(\\\"Sum of odd numbers up to 9 (excluding): {}\\\", sum_odd_numbers(9)); }\",\"这也是永远循环（如 loop {}）的函数（如网络服务器）或终止进程的函数（如 exit()）的返回类型。\"]},\"85\":{\"h\":\"高阶函数\",\"t\":[\"Rust 提供了高阶函数（Higher Order Function, HOF），指那些输入一个或多个函数，并且/或者产生一个更有用的函数的函数。HOF 和惰性迭代器（lazy iterator）给 Rust 带来了函数式（functional）编程的风格。\",\"fn is_odd(n: u32) -> bool { n % 2 == 1 } fn main() { println!(\\\"Find the sum of all the squared odd numbers under 1000\\\"); let upper = 1000; // 命令式（imperative）的写法 // 声明累加器变量 let mut acc = 0; // 迭代：0，1, 2, ... 到无穷大 for n in 0.. { // 数字的平方 let n_squared = n * n; if n_squared >= upper { // 若大于上限则退出循环 break; } else if is_odd(n_squared) { // 如果是奇数就计数 acc += n_squared; } } println!(\\\"imperative style: {}\\\", acc); // 函数式的写法 let sum_of_squared_odd_numbers: u32 = (0..).map(|n| n * n) // 所有自然数取平方 .take_while(|&n| n < upper) // 取小于上限的 .filter(|&n| is_odd(n)) // 取奇数 .fold(0, |sum, i| sum + i); // 最后加起来 println!(\\\"functional style: {}\\\", sum_of_squared_odd_numbers); }\",\"Option 和 迭代器 都实现了不少高阶函数。\"]},\"86\":{\"h\":\"方法\",\"t\":[\"方法（method）是依附于对象的函数。这些方法通过关键字 self 来访问对象中的数据和其他。方法在 impl 代码块中定义。\",\"struct Point { x: f64, y: f64, } // 实现的代码块，`Point` 的所有方法都在这里给出 impl Point { // 这是一个静态方法（static method） // 静态方法不需要被实例调用 // 这类方法一般用作构造器（constructor） fn origin() -> Point { Point { x: 0.0, y: 0.0 } } // 另外一个静态方法，需要两个参数： fn new(x: f64, y: f64) -> Point { Point { x: x, y: y } } } struct Rectangle { p1: Point, p2: Point, } impl Rectangle { // 这是一个实例方法（instance method） // `&self` 是 `self: &Self` 的语法糖（sugar），其中 `Self` 是方法调用者的 // 类型。在这个例子中 `Self` = `Rectangle` fn area(&self) -> f64 { // `self` 通过点运算符来访问结构体字段 let Point { x: x1, y: y1 } = self.p1; let Point { x: x2, y: y2 } = self.p2; // `abs` 是一个 `f64` 类型的方法，返回调用者的绝对值 ((x1 - x2) * (y1 - y2)).abs() } fn perimeter(&self) -> f64 { let Point { x: x1, y: y1 } = self.p1; let Point { x: x2, y: y2 } = self.p2; 2.0 * ((x1 - x2).abs() + (y1 - y2).abs()) } // 这个方法要求调用者是可变的 // `&mut self` 为 `self: &mut Self` 的语法糖 fn translate(&mut self, x: f64, y: f64) { self.p1.x += x; self.p2.x += x; self.p1.y += y; self.p2.y += y; } } // `Pair` 拥有资源：两个堆分配的整型 struct Pair(Box<i32>, Box<i32>); impl Pair { // 这个方法会 “消耗” 调用者的资源 // `self` 为 `self: Self` 的语法糖 fn destroy(self) { // 解构 `self` let Pair(first, second) = self; println!(\\\"Destroying Pair({}, {})\\\", first, second); // `first` 和 `second` 离开作用域后释放 } } fn main() { let rectangle = Rectangle { // 静态方法使用双冒号调用 p1: Point::origin(), p2: Point::new(3.0, 4.0), }; // 实例方法通过点运算符来调用 // 注意第一个参数 `&self` 是隐式传递的，亦即： // `rectangle.perimeter()` === `Rectangle::perimeter(&rectangle)` println!(\\\"Rectangle perimeter: {}\\\", rectangle.perimeter()); println!(\\\"Rectangle area: {}\\\", rectangle.area()); let mut square = Rectangle { p1: Point::origin(), p2: Point::new(1.0, 1.0), }; // 报错！ `rectangle` 是不可变的，但这方法需要一个可变对象 //rectangle.translate(1.0, 0.0); // 试一试 ^ 去掉此行的注释 // 正常运行！可变对象可以调用可变方法 square.translate(1.0, 1.0); let pair = Pair(Box::new(1), Box::new(2)); pair.destroy(); // 报错！前面的 `destroy` 调用 “消耗了” `pair` //pair.destroy(); // 试一试 ^ 将此行注释去掉 }\"]},\"87\":{\"h\":\"关联项\",\"t\":[\"“关联项”（associated item）指与多种类型的项有关的一组规则。它是 trait 泛型的扩展，允许在 trait 内部定义新的项。\",\"一个这样的项就叫做一个关联类型。当 trait 对于实现了它的容器类型是泛型的，关联项就提供了简单的使用方法。\",\"译注：“关联项”这个说法实际上只在 RFC 里出现了，官方的《The Rust Programming Language》第一版和第二版都只有“关联类型”的说法。如果觉得这里的说法很别扭的话 不要理会就是了。TRPL 对关联类型的定义是：“一种将类型占位符与 trait 联系起来的 做法，这样 trait 中的方法签名中就可以使用这些占位符类型。trait 的实现会指定在 该实现中那些占位符对应什么具体类型。”等看完这一节再回头看这个定义就很明白了。\"]},\"88\":{\"h\":\"参见：\",\"t\":[\"RFC\"]},\"89\":{\"h\":\"约束\",\"t\":[\"在使用泛型时，类型参数常常必须使用 trait 作为约束（bound）来明确规定类型应实现哪些功能。例如下面的例子用到了 Display trait 来打印，所以它用Display 来约束 T，也就是说 T必须实现 Display。\",\"// 定义一个函数 `printer`，接受一个类型为泛型 `T` 的参数， // 其中 `T` 必须实现 `Display` trait。 fn printer<T: Display>(t: T) { println!(\\\"{}\\\", t); }\",\"约束把泛型类型限制为符合约束的类型。请看：\",\"struct S<T: Display>(T); // 报错！`Vec<T>` 未实现 `Display`。此次泛型具体化失败。 let s = S(vec![1]);\",\"约束的另一个作用是泛型的实例可以访问作为约束的 trait 的方法。例如：\",\"// 这个 trait 用来实现打印标记：`{:?}`。 use std::fmt::Debug; trait HasArea { fn area(&self) -> f64; } impl HasArea for Rectangle { fn area(&self) -> f64 { self.length * self.height } } #[derive(Debug)] struct Rectangle { length: f64, height: f64 } #[allow(dead_code)] struct Triangle { length: f64, height: f64 } // 泛型 `T` 必须实现 `Debug` 。只要满足这点，无论什么类型 // 都可以让下面函数正常工作。 fn print_debug<T: Debug>(t: &T) { println!(\\\"{:?}\\\", t); } // `T` 必须实现 `HasArea`。任意符合该约束的泛型的实例 // 都可访问 `HasArea` 的 `area` 函数 fn area<T: HasArea>(t: &T) -> f64 { t.area() } fn main() { let rectangle = Rectangle { length: 3.0, height: 4.0 }; let _triangle = Triangle { length: 3.0, height: 4.0 }; print_debug(&rectangle); println!(\\\"Area: {}\\\", area(&rectangle)); //print_debug(&_triangle); //println!(\\\"Area: {}\\\", area(&_triangle)); // ^ 试一试：取消上述语句的注释。 // | 报错：未实现 `Debug` 或 `HasArea`。 }\",\"多说一句，某些情况下也可使用 where 分句来形成约束，这拥有更好的表现力。\"]},\"90\":{\"h\":\"参见：\",\"t\":[\"std::fmt, struct, 和 trait\"]},\"91\":{\"h\":\"函数\",\"t\":[\"同样的规则也适用于函数：在使用类型 T 前给出 <T>，那么 T 就变成了泛型。\",\"调用泛型函数有时需要显式地指明类型参量。这可能是因为调用了返回类型是泛型的函数，或者编译器没有足够的信息来推断类型参数。\",\"调用函数时，使用显式指定的类型参数会像是这样：fun::<A, B, ...>()。\",\"struct A; // 具体类型 `A`。 struct S(A); // 具体类型 `S`。 struct SGen<T>(T); // 泛型类型 `SGen`。 // 下面全部函数都得到了变量的所有权，并立即使之离开作用域，将变量释放。 // 定义一个函数 `reg_fn`，接受一个 `S` 类型的参数 `_s`。 // 因为没有 `<T>` 这样的泛型类型参数，所以这不是泛型函数。 fn reg_fn(_s: S) {} // 定义一个函数 `gen_spec_t`，接受一个 `SGen<A>` 类型的参数 `_s`。 // `SGen<>` 显式地接受了类型参数 `A`，且在 `gen_spec_t` 中，`A` 没有被用作 // 泛型类型参数，所以函数不是泛型的。 fn gen_spec_t(_s: SGen<A>) {} // 定义一个函数 `gen_spec_i32`，接受一个 `SGen<i32>` 类型的参数 `_s`。 // `SGen<>` 显式地接受了类型参量 `i32`，而 `i32` 是一个具体类型。 // 由于 `i32` 不是一个泛型类型，所以这个函数也不是泛型的。 fn gen_spec_i32(_s: SGen<i32>) {} // 定义一个函数 `generic`，接受一个 `SGen<T>` 类型的参数 `_s`。 // 因为 `SGen<T>` 之前有 `<T>`，所以这个函数是关于 `T` 的泛型函数。 fn generic<T>(_s: SGen<T>) {} fn main() { // 使用非泛型函数 reg_fn(S(A)); // 具体类型。 gen_spec_t(SGen(A)); // 隐式地指定类型参数 `A`。 gen_spec_i32(SGen(6)); // 隐式地指定类型参数 `i32`。 // 为 `generic()` 显式地指定类型参数 `char`。 generic::<char>(SGen('a')); // 为 `generic()` 隐式地指定类型参数 `char`。 generic(SGen('c')); }\"]},\"92\":{\"h\":\"参见：\",\"t\":[\"函数 和 structs\"]},\"93\":{\"h\":\"trait\",\"t\":[\"当然 trait 也可以是泛型的。我们在这里定义了一个 trait，它把 Droptrait 作为泛型方法实现了，可以 drop（丢弃）调用者本身和一个输入参数。\",\"// 不可复制的类型。 struct Empty; struct Null; // `T` 的泛型 trait。 trait DoubleDrop<T> { // 定义一个调用者的方法，接受一个额外的参数 `T`，但不对它做任何事。 fn double_drop(self, _: T); } // 对泛型的调用者类型 `U` 和任何泛型类型 `T` 实现 `DoubleDrop<T>` 。 impl<T, U> DoubleDrop<T> for U { // 此方法获得两个传入参数的所有权，并释放它们。 fn double_drop(self, _: T) {} } fn main() { let empty = Empty; let null = Null; // 释放 `empty` 和 `null`。 empty.double_drop(null); //empty; //null; // ^ 试一试：去掉这两行的注释。 }\"]},\"94\":{\"h\":\"参见：\",\"t\":[\"Drop, struct, 和 trait\"]},\"95\":{\"h\":\"实现\",\"t\":[\"和函数类似，impl 块要想实现泛型，也需要很仔细。\",\"struct S; // 具体类型 `S` struct GenericVal<T>(T,); // 泛型类型 `GenericVal` // GenericVal 的 `impl`，此处我们显式地指定了类型参数： impl GenericVal<f32> {} // 指定 `f32` 类型 impl GenericVal<S> {} // 指定为上面定义的 `S` // `<T>` 必须在类型之前写出来，以使类型 `T` 代表泛型。 impl <T> GenericVal<T> {}\",\"struct Val { val: f64 } struct GenVal<T>{ gen_val: T } // Val 的 `impl` impl Val { fn value(&self) -> &f64 { &self.val } } // GenVal 的 `impl`，指定 `T` 是泛型类型 impl <T> GenVal<T> { fn value(&self) -> &T { &self.gen_val } } fn main() { let x = Val { val: 3.0 }; let y = GenVal { gen_val: 3i32 }; println!(\\\"{}, {}\\\", x.value(), y.value()); }\"]},\"96\":{\"h\":\"参见：\",\"t\":[\"返回引用的函数, impl, 和 struct\"]},\"97\":{\"h\":\"多重约束\",\"t\":[\"多重约束（multiple bounds）可以用 + 连接。和平常一样，类型之间使用 , 隔开。\",\"use std::fmt::{Debug, Display}; fn compare_prints<T: Debug + Display>(t: &T) { println!(\\\"Debug: `{:?}`\\\", t); println!(\\\"Display: `{}`\\\", t); } fn compare_types<T: Debug, U: Debug>(t: &T, u: &U) { println!(\\\"t: `{:?}`\\\", t); println!(\\\"u: `{:?}`\\\", u); } fn main() { let string = \\\"words\\\"; let array = [1, 2, 3]; let vec = vec![1, 2, 3]; compare_prints(&string); //compare_prints(&array); // 试一试 ^ 将此行注释去掉。 compare_types(&array, &vec); }\"]},\"98\":{\"h\":\"参见：\",\"t\":[\"std::fmt 和 trait\"]},\"99\":{\"h\":\"new type 惯用法\",\"t\":[\"newtype 惯用法（译注：即为不同种类的数据分别定义新的类型）能保证在编译时，提供给程序的都是正确的类型。\",\"比如说，实现一个 “年龄认证” 函数，它要求输入必须是 Years 类型。\",\"struct Years(i64); struct Days(i64); impl Years { pub fn to_days(&self) -> Days { Days(self.0 * 365) } } impl Days { /// 舍去不满一年的部分 pub fn to_years(&self) -> Years { Years(self.0 / 365) } } fn old_enough(age: &Years) -> bool { age.0 >= 18 } fn main() { let age = Years(5); let age_days = age.to_days(); println!(\\\"Old enough {}\\\", old_enough(&age)); println!(\\\"Old enough {}\\\", old_enough(&age_days.to_years())); // println!(\\\"Old enough {}\\\", old_enough(&age_days)); }\",\"取消最后一行的注释，就可以发现提供给 old_enough 的必须是 Years 类型。\"]},\"100\":{\"h\":\"See also:\",\"t\":[\"structs\"]},\"101\":{\"h\":\"虚类型参数\",\"t\":[\"虚类型（phantom type）参数是一种在运行时不出现，而在（且仅在）编译时进行静态检查的类型参数。\",\"可以用额外的泛型类型参数指定数据类型，该类型可以充当标记，也可以供编译时类型检查使用。这些额外的参数没有存储值，也没有运行时行为。\",\"在下面例子中，我们使用 std 作为虚类型参数的类型，创建包含不同数据类型的元组。\",\"use std::marker::PhantomData; // 这个虚元组结构体对 `A` 是泛型的，并且带有隐藏参数 `B`。 #[derive(PartialEq)] // 允许这种类型进行相等测试（equality test）。 struct PhantomTuple<A, B>(A,PhantomData<B>); // 这个虚类型结构体对 `A` 是泛型的，并且带有隐藏参数 `B`。 #[derive(PartialEq)] // 允许这种类型进行相等测试。 struct PhantomStruct<A, B> { first: A, phantom: PhantomData<B> } // 注意：对于泛型 `A` 会分配存储空间，但 `B` 不会。 // 因此，`B` 不能参与运算。 fn main() { // 这里的 `f32` 和 `f64` 是隐藏参数。 // 被指定为 `<char, f32>` 的 `PhantomTuple` 类型。 let _tuple1: PhantomTuple<char, f32> = PhantomTuple('Q', PhantomData); // 被指定为 `<char, f64>` `PhantomTuple` 类型。 let _tuple2: PhantomTuple<char, f64> = PhantomTuple('Q', PhantomData); // 被指定为 `<char, f32>` 的类型。 let _struct1: PhantomStruct<char, f32> = PhantomStruct { first: 'Q', phantom: PhantomData, }; // 被指定为 `<char, f64>` 的类型。 let _struct2: PhantomStruct<char, f64> = PhantomStruct { first: 'Q', phantom: PhantomData, }; // 编译期错误！类型不匹配，所以这些值不能够比较： //println!(\\\"_tuple1 == _tuple2 yields: {}\\\", // _tuple1 == _tuple2); // 编译期错误！类型不匹配，所以这些值不能够比较： //println!(\\\"_struct1 == _struct2 yields: {}\\\", // _struct1 == _struct2); }\"]},\"102\":{\"h\":\"参见：\",\"t\":[\"Derive, 结构体, 和 元组结构体\"]},\"103\":{\"h\":\"where 分句\",\"t\":[\"约束也可以使用 where 分句来表达，它放在 { 的前面，而不需写在类型第一次出现之前。另外 where 从句可以用于任意类型的限定，而不局限于类型参数本身。\",\"where 在下面一些情况下很有用：\",\"当分别指定泛型的类型和约束会更清晰时：\",\"impl <A: TraitB + TraitC, D: TraitE + TraitF> MyTrait<A, D> for YourType {} // 使用 `where` 从句来表达约束 impl <A, D> MyTrait<A, D> for YourType where A: TraitB + TraitC, D: TraitE + TraitF {}\",\"当使用 where 从句比正常语法更有表现力时。本例中的 impl 如果不用where 从句，就无法直接表达。\",\"use std::fmt::Debug; trait PrintInOption { fn print_in_option(self); } // 这里需要一个 `where` 从句，否则就要表达成 `T: Debug`（这样意思就变了）， // 或者改用另一种间接的方法。 impl<T> PrintInOption for T where Option<T>: Debug { // 我们要将 `Option<T>: Debug` 作为约束，因为那是要打印的内容。 // 否则我们会给出错误的约束。 fn print_in_option(self) { println!(\\\"{:?}\\\", Some(self)); } } fn main() { let vec = vec![1, 2, 3]; vec.print_in_option(); }\"]},\"104\":{\"h\":\"参见：\",\"t\":[\"相关的 RFC、struct 和 trait\"]},\"105\":{\"h\":\"注释\",\"t\":[\"注释对任何程序都不可缺少，同样 Rust 支持几种不同的注释方式。\",\"普通注释，其内容将被编译器忽略掉： \",\"// 单行注释，注释内容直到行尾。\",\"/* 块注释，注释内容一直到结束分隔符。 */\",\"文档注释，其内容将被解析成 HTML 帮助文档： \",\"/// 为接下来的项生成帮助文档。\",\"//! 为注释所属于的项（译注：如 crate、模块或函数）生成帮助文档。\",\"fn main() { // 这是行注释的例子 // 注意有两个斜线在本行的开头 // 在这里面的所有内容都不会被编译器读取 // println!(\\\"Hello, world!\\\"); // 请运行一下，你看到结果了吗？现在请将上述语句的两条斜线删掉，并重新运行。 /* * 这是另外一种注释——块注释。一般而言，行注释是推荐的注释格式， * 不过块注释在临时注释大块代码特别有用。/* 块注释可以 /* 嵌套, */ */ * 所以只需很少按键就可注释掉这些 main() 函数中的行。/*/*/* 自己试试！*/*/*/ */ /* 注意，上面的例子中纵向都有 `*`，这只是一种风格，实际上这并不是必须的。 */ // 观察块注释是如何简单地对表达式进行修改的，行注释则不能这样。 // 删除注释分隔符将会改变结果。 let x = 5 + /* 90 + */ 5; println!(\\\"Is `x` 10 or 100? x = {}\\\", x); }\"]},\"106\":{\"h\":\"参见:\",\"t\":[\"文档注释\"]},\"107\":{\"h\":\"格式化输出\",\"t\":[\"打印操作由 std::fmt 里面所定义的一系列宏来处理，包括：\",\"format!：将格式化文本写到字符串。\",\"print!：与 format! 类似，但将文本输出到控制台（io::stdout）。\",\"println!: 与 print! 类似，但输出结果追加一个换行符。\",\"eprint!：与 print! 类似，但将文本输出到标准错误（io::stderr）。\",\"eprintln!：与 eprint! 类似，但输出结果追加一个换行符。\",\"这些宏都以相同的做法解析文本。有个额外优点是格式化的正确性会在编译时检查。\",\"fn main() { // 通常情况下，`{}` 会被任意变量内容所替换。 // 变量内容会转化成字符串。 println!(\\\"{} days\\\", 31); // 可以使用位置参数。 // 在 `{}` 中指定一个整数确定将替换哪个附加参数。 // 参数从紧接在格式字符串之后的 0 开始。 println!(\\\"{0}, this is {1}. {1}, this is {0}\\\", \\\"Alice\\\", \\\"Bob\\\"); // 可以使用命名参数。 println!(\\\"{subject} {verb} {object}\\\", object=\\\"the lazy dog\\\", subject=\\\"the quick brown fox\\\", verb=\\\"jumps over\\\"); // 通过在 `:` 后面指定格式字符，可以调用不同的格式。 println!(\\\"Base 10: {}\\\", 69420); // 69420 println!(\\\"Base 2 (binary): {:b}\\\", 69420); // 10000111100101100 println!(\\\"Base 8 (octal): {:o}\\\", 69420); // 207454 println!(\\\"Base 16 (hexadecimal): {:x}\\\", 69420); // 10f2c // 可以用指定的宽度对文本进行右对齐。 // 这将输出“ 1”。(四个空格和一个“1”，总宽度为5) println!(\\\"{number:>5}\\\", number=1); // 你可以在数字左边补 0， println!(\\\"{number:0>5}\\\", number=1); // 00001 // 在数字右边补零，下面语句输出 \\\"000001\\\"。 println!(\\\"{number:0<5}\\\", number=1); // 10000 // 可以通过添加 `$` 在格式说明符中使用命名参数。 println!(\\\"{number:0>width$}\\\", number=1, width=5); // println! 会检查使用到的参数数量是否正确。 println!(\\\"My name is {0}, {1} {0}\\\", \\\"Bond\\\"); // FIXME ^ 补上漏掉的参数：\\\"James\\\" // 只有实现了fmt::Display的类型才能使用'{}'进行格式化。 // 默认情况下，用户定义的类型不实现fmt::Display。 #[allow(dead_code)] // 禁用对未使用模块发出警告的' dead_code ' struct Structure(i32); // 这将不会编译，因为 `Structure` 没有实现 // 下面语句无法运行。 // println!(\\\"This struct `{}` won't print...\\\", Structure(3)); // TODO ^ 注释掉此行。 // 对于 Rust 1.58 及更高版本，你可以直接从周围变量捕获参数。 // 就像上面一样，这将输出“ 1”，4 个空格和 1 个“1”。 let number: f64 = 1.0; let width: usize = 5; println!(\\\"{number:>width$}\\\"); }\",\"std::fmt 包含多种 traits（特质）来控制文字显示，其中重要的两种 trait 的基本形式如下：\",\"fmt::Debug：使用 {:?} 标记。格式化文本以供调试使用。\",\"fmt::Display：使用 {} 标记。以更优雅和友好的风格来格式化文本。\",\"上例使用了 fmt::Display，因为标准库提供了那些类型的实现。若要打印自定义类型的文本，需要更多的步骤。\",\"实现 fmt::Display 特性会自动实现 ToString 特征，它允许我们将类型 convert 为 String。\",\"在第 43 行中，#[allow(dead_code)] 是一个 attribute，只适用于它后面的模块。\"]},\"108\":{\"h\":\"动手试一试\",\"t\":[\"改正上面代码中的错误（见 FIXME），使它可以没有错误地运行。\",\"尝试取消注释，输出结构体内容（见 TODO）。\",\"再用一个 println! 宏，通过控制显示的小数位数来打印：Pi is roughly 3.142（Pi 约等于 3.142）。为了达到练习目的，使用 let pi = 3.141592 作为 Pi 的近似值（提示：设置小数位的显示格式可以参考文档 std::fmt）。\"]},\"109\":{\"h\":\"参见：\",\"t\":[\"std::fmt, macros, struct, traits 和 dead_code\"]},\"110\":{\"h\":\"指示符\",\"t\":[\"宏的参数使用一个美元符号 $ 作为前缀，并使用一个指示符（designator）来注明类型：\",\"macro_rules! create_function { // 此宏接受一个 `ident` 指示符表示的参数，并创建一个名为 `$func_name` 的函数。 // `ident` 指示符用于变量名或函数名 ($func_name:ident) => { fn $func_name() { // `stringify!` 宏把 `ident` 转换成字符串。 println!(\\\"You called {:?}()\\\", stringify!($func_name)) } }; } // 借助上述宏来创建名为 `foo` 和 `bar` 的函数。 create_function!(foo); create_function!(bar); macro_rules! print_result { // 此宏接受一个 `expr` 类型的表达式，并将它作为字符串，连同其结果一起 // 打印出来。 // `expr` 指示符表示表达式。 ($expression:expr) => { // `stringify!` 把表达式*原样*转换成一个字符串。 println!(\\\"{:?} = {:?}\\\", stringify!($expression), $expression) }; } fn main() { foo(); bar(); print_result!(1u32 + 1); // 回想一下，代码块也是表达式！ print_result!({ let x = 1u32; x * x + 2 * x - 1 }); }\",\"这里列出全部指示符：\",\"block\",\"expr 用于表达式\",\"ident 用于变量名或函数名\",\"item\",\"literal 用于字面常量\",\"pat (模式pattern)\",\"path\",\"stmt (语句statement)\",\"tt (标记树token tree)\",\"ty (类型type)\",\"vis (可见性描述符)\",\"完整列表详见 Rust Reference。\"]},\"111\":{\"h\":\"DRY (不写重复代码)\",\"t\":[\"通过提取函数或测试集的公共部分，宏可以让你写出 DRY 的代码（DRY 是 Don't Repeat Yourself 的缩写，意思为 “不要写重复代码”）。这里给出一个例子，对 Vec<T> 实现并测试了关于 +=、*= 和 -= 等运算符。\",\"use std::ops::{Add, Mul, Sub}; macro_rules! assert_equal_len { // `tt`（token tree，标记树）指示符表示运算符和标记。 ($a:ident, $b: ident, $func:ident, $op:tt) => { assert!($a.len() == $b.len(), \\\"{:?}: dimension mismatch: {:?} {:?} {:?}\\\", stringify!($func), ($a.len(),), stringify!($op), ($b.len(),)); }; } macro_rules! op { ($func:ident, $bound:ident, $op:tt, $method:ident) => { fn $func<T: $bound<T, Output=T> + Copy>(xs: &mut Vec<T>, ys: &Vec<T>) { assert_equal_len!(xs, ys, $func, $op); for (x, y) in xs.iter_mut().zip(ys.iter()) { *x = $bound::$method(*x, *y); // *x = x.$method(*y); } } }; } // 实现 `add_assign`、`mul_assign` 和 `sub_assign` 等函数。 op!(add_assign, Add, +=, add); op!(mul_assign, Mul, *=, mul); op!(sub_assign, Sub, -=, sub); mod test { use std::iter; macro_rules! test { ($func: ident, $x:expr, $y:expr, $z:expr) => { #[test] fn $func() { for size in 0usize..10 { let mut x: Vec<_> = iter::repeat($x).take(size).collect(); let y: Vec<_> = iter::repeat($y).take(size).collect(); let z: Vec<_> = iter::repeat($z).take(size).collect(); super::$func(&mut x, &y); assert_eq!(x, z); } } } } // 测试 `add_assign`、`mul_assign` 和 `sub_assign` test!(add_assign, 1u32, 2u32, 3u32); test!(mul_assign, 2u32, 3u32, 6u32); test!(sub_assign, 3u32, 2u32, 1u32); }\",\"$ rustc --test dry.rs && ./dry running 3 tests test test::mul_assign ... ok test test::add_assign ... ok test test::sub_assign ... ok test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured\"]},\"112\":{\"h\":\"DSL（领域专用语言）\",\"t\":[\"DSL 是 Rust 的宏中集成的微型 “语言”。这种语言是完全合法的，因为宏系统会把它转换成普通的 Rust 语法树，它只不过看起来像是另一种语言而已。这就允许你为一些特定功能创造一套简洁直观的语法（当然是有限制的）。\",\"比如说我想要定义一套小的计算器 API，可以传给它表达式，它会把结果打印到控制台上。\",\"macro_rules! calculate { (eval $e:expr) => { { let val: usize = $e; // 强制类型为整型 println!(\\\"{} = {}\\\", stringify!{$e}, val); } }; } fn main() { calculate! { eval 1 + 2 // 看到了吧，`eval` 可并不是 Rust 的关键字！ } calculate! { eval (1 + 2) * (3 / 4) } }\",\"输出:\",\"1 + 2 = 3 (1 + 2) * (3 / 4) = 0\",\"这个例子非常简单，但是已经有很多利用宏开发的复杂接口了，比如lazy_static 和clap。\"]},\"113\":{\"h\":\"重载\",\"t\":[\"宏可以重载，从而接受不同的参数组合。在这方面，macro_rules! 的作用类似于匹配（match）代码块：\",\"// 根据你调用它的方式，`test!` 将以不同的方式来比较 `$left` 和 `$right`。 macro_rules! test { // 参数不需要使用逗号隔开。 // 参数可以任意组合！ ($left:expr; and $right:expr) => { println!(\\\"{:?} and {:?} is {:?}\\\", stringify!($left), stringify!($right), $left && $right) }; // ^ 每个分支都必须以分号结束。 ($left:expr; or $right:expr) => { println!(\\\"{:?} or {:?} is {:?}\\\", stringify!($left), stringify!($right), $left || $right) }; } fn main() { test!(1i32 + 1 == 2i32; and 2i32 * 2 == 4i32); test!(true; or false); }\"]},\"114\":{\"h\":\"重复\",\"t\":[\"宏在参数列表中可以使用 + 来表示一个参数可能出现一次或多次，使用 * 来表示该参数可能出现零次或多次。\",\"在下面例子中，把模式这样： $(...),+ 包围起来，就可以匹配一个或多个用逗号隔开的表达式。另外注意到，宏定义的最后一个分支可以不用分号作为结束。\",\"// `min!` 将求出任意数量的参数的最小值。 macro_rules! find_min { // 基本情形： ($x:expr) => ($x); // `$x` 后面跟着至少一个 `$y,` ($x:expr, $($y:expr),+) => ( // 对 `$x` 后面的 `$y` 们调用 `find_min!` std::cmp::min($x, find_min!($($y),+)) ) } fn main() { println!(\\\"{}\\\", find_min!(1u32)); println!(\\\"{}\\\", find_min!(1u32 + 2 , 2u32)); println!(\\\"{}\\\", find_min!(5u32, 2u32 * 3, 4u32)); }\"]},\"115\":{\"h\":\"语法\",\"t\":[\"在下面的小节中，我们将展示如何在 Rust 中定义宏。基本的概念有三个：\",\"[重复][repetition]\"]},\"116\":{\"h\":\"可变参数接口\",\"t\":[\"可变参数接口可以接受任意数目的参数。比如说 println 就可以，其参数的数目是由格式化字符串指定的。\",\"我们可以把之前的 calculate! 宏改写成可变参数接口：\",\"macro_rules! calculate { // 单个 `eval` 的模式 (eval $e:expr) => { { let val: usize = $e; // Force types to be integers println!(\\\"{} = {}\\\", stringify!{$e}, val); } }; // 递归地拆解多重的 `eval` (eval $e:expr, $(eval $es:expr),+) => {{ calculate! { eval $e } calculate! { $(eval $es),+ } }}; } fn main() { calculate! { // 妈妈快看，可变参数的 `calculate!`！ eval 1 + 2, eval 3 + 4, eval (2 * 3) + 1 } }\",\"输出：\",\"1 + 2 = 3 3 + 4 = 7 (2 * 3) + 1 = 7\"]},\"117\":{\"h\":\"文档\",\"t\":[\"用 cargo doc 构建文档到 target/doc。\",\"用 cargo test 运行所有测试（包括文档测试），用 cargo test --doc 仅运行文档测试。\",\"这些命令会恰当地按需调用 rustdoc（以及 rustc）。\"]},\"118\":{\"h\":\"文档注释\",\"t\":[\"文档注释对于需要文档的大型项目来说非常重要。当运行 rustdoc，文档注释就会编译成文档。它们使用 /// 标记，并支持 Markdown。\",\"#![crate_name = \\\"doc\\\"] /// 这里给出一个“人”的表示 pub struct Person { /// 一个人必须有名字（不管 Juliet 多讨厌她自己的名字）。 name: String, } impl Person { /// 返回具有指定名字的一个人 /// /// # 参数 /// /// * `name` - 字符串切片，代表人的名字 /// /// # 示例 /// /// ``` /// // 在文档注释中，你可以书写代码块 /// // 如果向 `rustdoc` 传递 --test 参数，它还会帮你测试注释文档中的代码！ /// use doc::Person; /// let person = Person::new(\\\"name\\\"); /// ``` pub fn new(name: &str) -> Person { Person { name: name.to_string(), } } /// 给一个友好的问候！ /// 对被叫到的 `Person` 说 \\\"Hello, [name]\\\" 。 pub fn hello(& self) { println!(\\\"Hello, {}!\\\", self.name); } } fn main() { let john = Person::new(\\\"John\\\"); john.hello(); }\",\"要运行测试，首先将代码构建为库，然后告诉 rustdoc 在哪里找到库，这样它就可以使每个文档中的程序链接到库：\",\"$ rustc doc.rs --crate-type lib $ rustdoc --test --extern doc=\\\"libdoc.rlib\\\" doc.rs\"]},\"119\":{\"h\":\"文档属性\",\"t\":[\"下面是一些使用 rustdoc 时最常使用的 #[doc] 属性的例子。\"]},\"120\":{\"h\":\"\",\"t\":[\"用于内联文档，而不是链接到单独的页面。\",\"#[doc(inline)] pub use bar::Bar; /// bar 的文档 mod bar { /// Bar 的文档 pub struct Bar; }\"]},\"121\":{\"h\":\"\",\"t\":[\"用于防止链接到单独的页面或其他位置。\",\"// 来自 libcore/prelude 的例子 #[doc(no_inline)] pub use crate::mem::drop;\"]},\"122\":{\"h\":\"\",\"t\":[\"使用此属性来告诉 rustdoc 不要包含此项到文档中：\",\"// 来自 futures-rs 库的例子 #[doc(hidden)] pub use self::async_await::*;\",\"对文档来说，rustdoc 被社区广泛采用。标准库文档也是用它生成的。\"]},\"123\":{\"h\":\"参见:\",\"t\":[\"[Is there any documentation style guide for comments? (reddit)][reddit]\"]},\"124\":{\"h\":\"Playpen\",\"t\":[\"Rust Playpen 是一个在线运行 Rust 代码的网络接口。现在该项目通常称为 Rust Playground。\"]},\"125\":{\"h\":\"在 使用\",\"t\":[\"在 mdbook 中，你可以让示例代码运行和编辑。\",\"fn main() { println!(\\\"Hello World!\\\"); }\",\"这使读者既可以运行你的代码示例，也可以对其进行修改和调整。此处的关键是将单词添加 editable 到代码块中，并用逗号分隔。\",\"```rust,editable //...将你的代码写在这里 ```\",\"此外，如果想要 mdbook 在构建和测试时跳过该代码，则可以添加 ignore。\",\"```rust,editable,ignore //...将你的代码写在这里 ```\"]},\"126\":{\"h\":\"在文档中使用\",\"t\":[\"可能你已经在某些 Rust 官方文档中注意到了一个名为 “Run” 的按钮，该按钮在 Rust Playground 的新选项卡中打开了代码示例。如果使用名为的 html_playground_url 的 #[doc] 属性，则启用此功能。\"]},\"127\":{\"h\":\"参见：\",\"t\":[\"[官方文档][rustdoc-book]\"]},\"128\":{\"h\":\"文件分层\",\"t\":[\"模块可以分配到文件/目录的层次结构中。让我们将《可见性》一节中的例子的代码拆分到多个文件中：\",\"$ tree . . |-- my | |-- inaccessible.rs | |-- mod.rs | `-- nested.rs `-- split.rs\",\"split.rs 的内容：\",\"// 此声明将会查找名为 `my.rs` 或 `my/mod.rs` 的文件，并将该文件的内容放到 // 此作用域中一个名为 `my` 的模块里面。 mod my; fn function() { println!(\\\"called `function()`\\\"); } fn main() { my::function(); function(); my::indirect_access(); my::nested::function(); }\",\"my/mod.rs 的内容：\",\"// 类似地，`mod inaccessible` 和 `mod nested` 将找到 `nested.rs` 和 // `inaccessible.rs` 文件，并在它们放到各自的模块中。 mod inaccessible; pub mod nested; pub fn function() { println!(\\\"called `my::function()`\\\"); } fn private_function() { println!(\\\"called `my::private_function()`\\\"); } pub fn indirect_access() { print!(\\\"called `my::indirect_access()`, that\\\\n> \\\"); private_function(); }\",\"my/nested.rs 的内容：\",\"pub fn function() { println!(\\\"called `my::nested::function()`\\\"); } #[allow(dead_code)] fn private_function() { println!(\\\"called `my::nested::private_function()`\\\"); }\",\"my/inaccessible.rs 的内容：\",\"#[allow(dead_code)] pub fn public_function() { println!(\\\"called `my::inaccessible::public_function()`\\\"); }\",\"我们看到代码仍然正常运行，就和前面的一样：\",\"$ rustc split.rs && ./split called `my::function()` called `function()` called `my::indirect_access()`, that > called `my::private_function()` called `my::nested::function()`\"]},\"129\":{\"h\":\"结构体的可见性\",\"t\":[\"结构体的字段也是一个可见性的层次。字段默认拥有私有的可见性，也可以加上 pub 修饰语来重载该行为。只有从结构体被定义的模块之外访问其字段时，这个可见性才会起作用，其意义是隐藏信息（即封装，encapsulation）。\",\"mod my { // 一个公有的结构体，带有一个公有的字段（类型为泛型 `T`） pub struct OpenBox<T> { pub contents: T, } // 一个公有的结构体，带有一个私有的字段（类型为泛型 `T`） #[allow(dead_code)] pub struct ClosedBox<T> { contents: T, } impl<T> ClosedBox<T> { // 一个公有的构造器方法 pub fn new(contents: T) -> ClosedBox<T> { ClosedBox { contents: contents, } } } } fn main() { // 带有公有字段的公有结构体，可以像平常一样构造 let open_box = my::OpenBox { contents: \\\"public information\\\" }; // 并且它们的字段可以正常访问到。 println!(\\\"The open box contains: {}\\\", open_box.contents); // 带有私有字段的公有结构体不能使用字段名来构造。 // 报错！`ClosedBox` 含有私有字段。 //let closed_box = my::ClosedBox { contents: \\\"classified information\\\" }; // 试一试 ^ 取消此行注释 // 不过带有私有字段的结构体可以使用公有的构造器来创建。 let _closed_box = my::ClosedBox::new(\\\"classified information\\\"); // 并且一个结构体中的私有字段不能访问到。 // 报错！`content` 字段是私有的。 //println!(\\\"The closed box contains: {}\\\", _closed_box.contents); // 试一试 ^ 取消此行注释 }\"]},\"130\":{\"h\":\"参见：\",\"t\":[\"泛型 和 方法\"]},\"131\":{\"h\":\"super 和 self\",\"t\":[\"可以在路径中使用 super （父级）和 self（自身）关键字，从而在访问项时消除歧义，以及防止不必要的路径硬编码。\",\"fn function() { println!(\\\"called `function()`\\\"); } mod cool { pub fn function() { println!(\\\"called `cool::function()`\\\"); } } mod my { fn function() { println!(\\\"called `my::function()`\\\"); } mod cool { pub fn function() { println!(\\\"called `my::cool::function()`\\\"); } } pub fn indirect_call() { // 让我们从这个作用域中访问所有名为 `function` 的函数！ print!(\\\"called `my::indirect_call()`, that\\\\n> \\\"); // `self` 关键字表示当前的模块作用域——在这个例子是 `my`。 // 调用 `self::function()` 和直接调用 `function()` 都得到相同的结果， // 因为他们表示相同的函数。 self::function(); function(); // 我们也可以使用 `self` 来访问 `my` 内部的另一个模块： self::cool::function(); // `super` 关键字表示父作用域（在 `my` 模块外面）。 super::function(); // 这将在 *crate* 作用域内绑定 `cool::function` 。 // 在这个例子中，crate 作用域是最外面的作用域。 { use crate::cool::function as root_function; root_function(); } } } fn main() { my::indirect_call(); }\"]},\"132\":{\"h\":\"use 声明\",\"t\":[\"use 声明可以将一个完整的路径绑定到一个新的名字，从而更容易访问。\",\"// 将 `deeply::nested::function` 路径绑定到 `other_function`。 use deeply::nested::function as other_function; fn function() { println!(\\\"called `function()`\\\"); } mod deeply { pub mod nested { pub fn function() { println!(\\\"called `deeply::nested::function()`\\\") } } } fn main() { // 更容易访问 `deeply::nested::funcion` other_function(); println!(\\\"Entering block\\\"); { // 这和 `use deeply::nested::function as function` 等价。 // 此 `function()` 将遮蔽外部的同名函数。 use deeply::nested::function; function(); // `use` 绑定拥有局部作用域。在这个例子中，`function()` // 的遮蔽只存在这个代码块中。 println!(\\\"Leaving block\\\"); } function(); }\"]},\"133\":{\"h\":\"可见性\",\"t\":[\"默认情况下，模块中的项拥有私有的可见性（private visibility），不过可以加上 pub 修饰语来重载这一行为。模块中只有公有的（public）项可以从模块外的作用域访问。\",\"// 一个名为 `my_mod` 的模块 mod my_mod { // 模块中的项默认具有私有的可见性 fn private_function() { println!(\\\"called `my_mod::private_function()`\\\"); } // 使用 `pub` 修饰语来改变默认可见性。 pub fn function() { println!(\\\"called `my_mod::function()`\\\"); } // 在同一模块中，项可以访问其它项，即使它是私有的。 pub fn indirect_access() { print!(\\\"called `my_mod::indirect_access()`, that\\\\n> \\\"); private_function(); } // 模块也可以嵌套 pub mod nested { pub fn function() { println!(\\\"called `my_mod::nested::function()`\\\"); } #[allow(dead_code)] fn private_function() { println!(\\\"called `my_mod::nested::private_function()`\\\"); } // 使用 `pub(in path)` 语法定义的函数只在给定的路径中可见。 // `path` 必须是父模块（parent module）或祖先模块（ancestor module） pub(in crate::my_mod) fn public_function_in_my_mod() { print!(\\\"called `my_mod::nested::public_function_in_my_mod()`, that\\\\n > \\\"); public_function_in_nested() } // 使用 `pub(self)` 语法定义的函数则只在当前模块中可见。 pub(self) fn public_function_in_nested() { println!(\\\"called `my_mod::nested::public_function_in_nested\\\"); } // 使用 `pub(super)` 语法定义的函数只在父模块中可见。 pub(super) fn public_function_in_super_mod() { println!(\\\"called my_mod::nested::public_function_in_super_mod\\\"); } } pub fn call_public_function_in_my_mod() { print!(\\\"called `my_mod::call_public_funcion_in_my_mod()`, that\\\\n> \\\"); nested::public_function_in_my_mod(); print!(\\\"> \\\"); nested::public_function_in_super_mod(); } // `pub(crate)` 使得函数只在当前 crate 中可见 pub(crate) fn public_function_in_crate() { println!(\\\"called `my_mod::public_function_in_crate()\\\"); } // 嵌套模块的可见性遵循相同的规则 mod private_nested { #[allow(dead_code)] pub fn function() { println!(\\\"called `my_mod::private_nested::function()`\\\"); } } } fn function() { println!(\\\"called `function()`\\\"); } fn main() { // 模块机制消除了相同名字的项之间的歧义。 function(); my_mod::function(); // 公有项，包括嵌套模块内的，都可以在父模块外部访问。 my_mod::indirect_access(); my_mod::nested::function(); my_mod::call_public_function_in_my_mod(); // pub(crate) 项可以在同一个 crate 中的任何地方访问 my_mod::public_function_in_crate(); // pub(in path) 项只能在指定的模块中访问 // 报错！函数 `public_function_in_my_mod` 是私有的 //my_mod::nested::public_function_in_my_mod(); // 试一试 ^ 取消该行的注释 // 模块的私有项不能直接访问，即便它是嵌套在公有模块内部的 // 报错！`private_function` 是私有的 //my_mod::private_function(); // 试一试 ^ 取消此行注释 // 报错！`private_function` 是私有的 //my_mod::nested::private_function(); // 试一试 ^ 取消此行的注释 // 报错！`private_nested` 是私有的 //my_mod::private_nested::function(); // 试一试 ^ 取消此行的注释 }\"]},\"134\":{\"h\":\"数组和切片\",\"t\":[\"数组（array）是一组拥有相同类型 T 的对象的集合，在内存中是连续存储的。数组使用中括号 [] 来创建，且它们的大小在编译时会被确定。数组的类型标记为 [T; length]（译注：T 为元素类型，length 表示数组大小）。\",\"切片（slice）类型和数组类似，但其大小在编译时是不确定的。相反，切片是一个双字对象（two-word object），第一个字是一个指向数据的指针，第二个字是切片的长度。这个 “字” 的宽度和 usize 相同，由处理器架构决定，比如在 x86-64 平台上就是 64 位。slice 可以用来借用数组的一部分。slice 的类型标记为 &[T]。\",\"use std::mem; // 此函数借用一个 slice fn analyze_slice(slice: &[i32]) { println!(\\\"first element of the slice: {}\\\", slice[0]); println!(\\\"the slice has {} elements\\\", slice.len()); } fn main() { // 定长数组（类型标记是多余的） let xs: [i32; 5] = [1, 2, 3, 4, 5]; // 所有元素可以初始化成相同的值 let ys: [i32; 500] = [0; 500]; // 下标从 0 开始 println!(\\\"first element of the array: {}\\\", xs[0]); println!(\\\"second element of the array: {}\\\", xs[1]); // `len` 返回数组的大小 println!(\\\"array size: {}\\\", xs.len()); // 数组是在栈中分配的 println!(\\\"array occupies {} bytes\\\", mem::size_of_val(&xs)); // 数组可以自动被借用成为 slice println!(\\\"borrow the whole array as a slice\\\"); analyze_slice(&xs); // slice 可以指向数组的一部分 println!(\\\"borrow a section of the array as a slice\\\"); analyze_slice(&ys[1 .. 4]); // 越界的下标会引发致命错误（panic） println!(\\\"{}\\\", xs[5]); }\"]},\"135\":{\"h\":\"字面量和运算符\",\"t\":[\"整数 1、浮点数 1.2、字符 'a'、字符串 \\\"abc\\\"、布尔值 true 和单元类型 () 可以用数字、文字或符号之类的 “字面量”（literal）来表示。\",\"另外，通过加前缀 0x、0o、0b，数字可以用十六进制、八进制或二进制记法表示。\",\"为了改善可读性，可以在数值字面量中插入下划线，比如：1_000 等同于 1000，0.000_001 等同于 0.000001。\",\"我们需要把字面量的类型告诉编译器。如前面学过的，我们使用 u32 后缀来表明字面量是一个 32 位无符号整数，i32 后缀表明字面量是一个 32 位有符号整数。\",\"Rust 提供了一系列的运算符（operator），它们的优先级和类 C 语言类似。（译注：类 C 语言包括 C/C++、Java、PHP 等语言）\",\"fn main() { // 整数相加 println!(\\\"1 + 2 = {}\\\", 1u32 + 2); // 整数相减 println!(\\\"1 - 2 = {}\\\", 1i32 - 2); // 试一试 ^ 尝试将 `1i32` 改为 `1u32`，体会为什么类型声明这么重要 // 短路求值的布尔逻辑 println!(\\\"true AND false is {}\\\", true && false); println!(\\\"true OR false is {}\\\", true || false); println!(\\\"NOT true is {}\\\", !true); // 位运算 println!(\\\"0011 AND 0101 is {:04b}\\\", 0b0011u32 & 0b0101); println!(\\\"0011 OR 0101 is {:04b}\\\", 0b0011u32 | 0b0101); println!(\\\"0011 XOR 0101 is {:04b}\\\", 0b0011u32 ^ 0b0101); println!(\\\"1 << 5 is {}\\\", 1u32 << 5); println!(\\\"0x80 >> 2 is 0x{:x}\\\", 0x80u32 >> 2); // 使用下划线改善数字的可读性！ println!(\\\"One million is written as {}\\\", 1_000_000u32); }\"]},\"136\":{\"h\":\"元组\",\"t\":[\"元组是一个可以包含各种类型值的组合。元组使用括号 () 来构造（construct），而每个元组自身又是一个类型标记为 (T1, T2, ...) 的值，其中 T1、T2 是每个元素的类型。函数可以使用元组来返回多个值，因为元组可以拥有任意多个值。\",\"// 元组可以充当函数的参数和返回值 fn reverse(pair: (i32, bool)) -> (bool, i32) { // 可以使用 `let` 把一个元组的成员绑定到一些变量 let (integer, boolean) = pair; (boolean, integer) } // 在 “动手试一试” 的练习中要用到下面这个结构体。 #[derive(Debug)] struct Matrix(f32, f32, f32, f32); fn main() { // 包含各种不同类型的元组 let long_tuple = (1u8, 2u16, 3u32, 4u64, -1i8, -2i16, -3i32, -4i64, 0.1f32, 0.2f64, 'a', true); // 通过元组的下标来访问具体的值 println!(\\\"long tuple first value: {}\\\", long_tuple.0); println!(\\\"long tuple second value: {}\\\", long_tuple.1); // 元组也可以充当元组的元素 let tuple_of_tuples = ((1u8, 2u16, 2u32), (4u64, -1i8), -2i16); // 元组可以打印 println!(\\\"tuple of tuples: {:?}\\\", tuple_of_tuples); // 但很长的元组无法打印 // let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13); // println!(\\\"too long tuple: {:?}\\\", too_long_tuple); // 试一试 ^ 取消上面两行的注释，阅读编译器给出的错误信息。 let pair = (1, true); println!(\\\"pair is {:?}\\\", pair); println!(\\\"the reversed pair is {:?}\\\", reverse(pair)); // 创建单元素元组需要一个额外的逗号，这是为了和被括号包含的字面量作区分。 println!(\\\"one element tuple: {:?}\\\", (5u32,)); println!(\\\"just an integer: {:?}\\\", (5u32)); // 元组可以被解构（deconstruct），从而将值绑定给变量 let tuple = (1, \\\"hello\\\", 4.5, true); let (a, b, c, d) = tuple; println!(\\\"{:?}, {:?}, {:?}, {:?}\\\", a, b, c, d); let matrix = Matrix(1.1, 1.2, 2.1, 2.2); println!(\\\"{:?}\\\", matrix) }\"]},\"137\":{\"h\":\"动手试一试\",\"t\":[\"复习：在上面的例子中给 Matrix 结构体 加上 fmt::Display trait，这样当你从 Debug 格式化 {:?} 切换到 Display 格式化 {} 时，会得到如下的输出：\",\"( 1.1 1.2 ) ( 2.1 2.2 )\",\"可以回顾之前学过的显示（display）的例子。\",\"以 reverse 函数作为样板，写一个 transpose 函数，它可以接受一个 Matrix 作为参数，并返回一个右上 - 左下对角线上的两元素交换后的 Matrix。举个例子：\",\"println!(\\\"Matrix:\\\\n{}\\\", matrix); println!(\\\"Transpose:\\\\n{}\\\", transpose(matrix));\",\"输出结果：\",\"Matrix: ( 1.1 1.2 ) ( 2.1 2.2 ) Transpose: ( 1.1 2.1 ) ( 1.2 2.2 )\"]},\"138\":{\"h\":\"借用\",\"t\":[\"多数情况下，我们更希望能访问数据，同时不取得其所有权。为实现这点，Rust 使用了借用（borrowing）机制。对象可以通过引用（&T）来传递，从而取代通过值（T）来传递。\",\"编译器（通过借用检查）静态地保证了引用总是指向有效的对象。也就是说，当存在引用指向一个对象时，该对象不能被销毁。\",\"// 此函数取得一个 box 的所有权并销毁它 fn eat_box_i32(boxed_i32: Box<i32>) { println!(\\\"Destroying box that contains {}\\\", boxed_i32); } // 此函数借用了一个 i32 类型 fn borrow_i32(borrowed_i32: &i32) { println!(\\\"This int is: {}\\\", borrowed_i32); } fn main() { // 创建一个装箱的 i32 类型，以及一个存在栈中的 i32 类型。 let boxed_i32 = Box::new(5_i32); let stacked_i32 = 6_i32; // 借用了 box 的内容，但没有取得所有权，所以 box 的内容之后可以再次借用。 // 译注：请注意函数自身就是一个作用域，因此下面两个函数运行完成以后， // 在函数中临时创建的引用也就不复存在了。 borrow_i32(&boxed_i32); borrow_i32(&stacked_i32); { // 取得一个对 box 中数据的引用 let _ref_to_i32: &i32 = &boxed_i32; // 报错！ // 当 `boxed_i32` 里面的值之后在作用域中被借用时，不能将其销毁。 eat_box_i32(boxed_i32); // 改正 ^ 注释掉此行 // 在 `_ref_to_i32` 里面的值被销毁后，尝试借用 `_ref_to_i32` //（译注：如果此处不借用，则在上一行的代码中，eat_box_i32(boxed_i32)可以将 `boxed_i32` 销毁。） borrow_i32(_ref_to_i32); // `_ref_to_i32` 离开作用域且不再被借用。 } // `boxed_i32` 现在可以将所有权交给 `eat_box_i32` 并被销毁。 //（译注：能够销毁是因为已经不存在对 `boxed_i32` 的引用） eat_box_i32(boxed_i32); }\"]},\"139\":{\"h\":\"生命周期\",\"t\":[\"生命周期（lifetime）是这样一种概念，编译器（中的借用检查器）用它来保证所有的借用都是有效的。确切地说，一个变量的生命周期在它创建的时候开始，在它销毁的时候结束。虽然生命周期和作用域经常被一起提到，但它们并不相同。\",\"例如考虑这种情况，我们通过 & 来借用一个变量。该借用拥有一个生命周期，此生命周期由它声明的位置决定。于是，只要该借用在出借者（lender）被销毁前结束，借用就是有效的。然而，借用的作用域则是由使用引用的位置决定的。\",\"在下面的例子和本章节剩下的内容里，我们将看到生命周期和作用域的联系与区别。\",\"译注：如果代码中的生命周期示意图乱掉了，请把它复制到任何编辑器中，用等宽字体查看。为避免中文的显示问题，下面一些注释没有翻译。\",\"// 下面使用连线来标注各个变量的创建和销毁，从而显示出生命周期。 // `i` 的生命周期最长，因为它的作用域完全覆盖了 `borrow1` 和 // `borrow2` 的。`borrow1` 和 `borrow2` 的周期没有关联， // 因为它们各不相交。 fn main() { let i = 3; // Lifetime for `i` starts. ────────────────┐ // │ { // │ let borrow1 = &i; // `borrow1` lifetime starts. ──┐│ // ││ println!(\\\"borrow1: {}\\\", borrow1); // ││ } // `borrow1 ends. ──────────────────────────────────┘│ // │ // │ { // │ let borrow2 = &i; // `borrow2` lifetime starts. ──┐│ // ││ println!(\\\"borrow2: {}\\\", borrow2); // ││ } // `borrow2` ends. ─────────────────────────────────┘│ // │ } // Lifetime ends. ─────────────────────────────────────┘\",\"注意到这里没有用到名称或类型来标注生命周期，这限制了生命周期的用法，在后面我们将会看到生命周期更强大的功能。\"]},\"140\":{\"h\":\"所有权和移动\",\"t\":[\"因为变量要负责释放它们拥有的资源，所以资源只能拥有一个所有者。这也防止了资源的重复释放。注意并非所有变量都拥有资源（例如引用）。\",\"在进行赋值（let x = y）或通过值来传递函数参数（foo(x)）的时候，资源的所有权（ownership）会发生转移。按照 Rust 的说法，这被称为资源的移动（move）。\",\"在移动资源之后，原来的所有者不能再被使用，这可避免悬挂指针（dangling pointer）的产生。\",\"// 此函数取得堆分配的内存的所有权 fn destroy_box(c: Box<i32>) { println!(\\\"Destroying a box that contains {}\\\", c); // `c` 被销毁且内存得到释放 } fn main() { // 栈分配的整型 let x = 5u32; // 将 `x` *复制*到 `y`——不存在资源移动 let y = x; // 两个值各自都可以使用 println!(\\\"x is {}, and y is {}\\\", x, y); // `a` 是一个指向堆分配的整数的指针 let a = Box::new(5i32); println!(\\\"a contains: {}\\\", a); // *移动* `a` 到 `b` let b = a; // 把 `a` 的指针地址（而非数据）复制到 `b`。现在两者都指向 // 同一个堆分配的数据，但是现在是 `b` 拥有它。 // 报错！`a` 不能访问数据，因为它不再拥有那部分堆上的内存。 //println!(\\\"a contains: {}\\\", a); // 试一试 ^ 去掉此行注释 // 此函数从 `b` 中取得堆分配的内存的所有权 destroy_box(b); // 此时堆内存已经被释放，这个操作会导致解引用已释放的内存，而这是编译器禁止的。 // 报错！和前面出错的原因一样。 //println!(\\\"b contains: {}\\\", b); // 试一试 ^ 去掉此行注释 }\"]},\"141\":{\"h\":\"RAII\",\"t\":[\"Rust 的变量不只是在栈中保存数据：它们也占有资源，比如 Box<T> 占有堆（heap）中的内存。Rust 强制实行 RAII（Resource Acquisition Is Initialization，资源获取即初始化），所以任何对象在离开作用域时，它的析构函数（destructor）就被调用，然后它占有的资源就被释放。\",\"这种行为避免了资源泄漏（resource leak），所以你再也不用手动释放内存或者担心内存泄漏（memory leak）！下面是个快速入门示例：\",\"// raii.rs fn create_box() { // 在堆上分配一个整型数据 let _box1 = Box::new(3i32); // `_box1` 在这里被销毁，内存得到释放 } fn main() { // 在堆上分配一个整型数据 let _box2 = Box::new(5i32); // 嵌套作用域： { // 在堆上分配一个整型数据 let _box3 = Box::new(4i32); // `_box3` 在这里被销毁，内存得到释放 } // 创建一大堆 box（只是因为好玩）。 // 完全不需要手动释放内存！ for _ in 0u32..1_000 { create_box(); } // `_box2` 在这里被销毁，内存得到释放 }\",\"当然我们可以使用 valgrind 对内存错误进行仔细检查：\",\"$ rustc raii.rs && valgrind ./raii ==26873== Memcheck, a memory error detector ==26873== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al. ==26873== Using Valgrind-3.9.0 and LibVEX; rerun with -h for copyright info ==26873== Command: ./raii ==26873== ==26873== ==26873== HEAP SUMMARY: ==26873== in use at exit: 0 bytes in 0 blocks ==26873== total heap usage: 1,013 allocs, 1,013 frees, 8,696 bytes allocated ==26873== ==26873== All heap blocks were freed -- no leaks are possible ==26873== ==26873== For counts of detected and suppressed errors, rerun with: -v ==26873== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 2 from 2)\",\"完全没有泄漏！\"]},\"142\":{\"h\":\"析构函数\",\"t\":[\"Rust 中的析构函数概念是通过 Drop trait 提供的。当资源离开作用域，就调用析构函数。你无需为每种类型都实现 Drop trait，只要为那些需要自己的析构函数逻辑的类型实现就可以了。\",\"运行下列例子，看看 Drop trait 是怎样工作的。当 main 函数中的变量离开作用域，自定义的析构函数就会被调用：\",\"struct ToDrop; impl Drop for ToDrop { fn drop(&mut self) { println!(\\\"ToDrop is being dropped\\\"); } } fn main() { let x = ToDrop; println!(\\\"Made a ToDrop!\\\"); }\"]},\"143\":{\"h\":\"参见：\",\"t\":[\"Box\"]},\"144\":{\"h\":\"共享引用计数 Arc\",\"t\":[\"当线程之间所有权需要共享时，可以使用Arc（共享引用计数，Atomic Reference Counted 缩写）可以使用。这个结构通过 Clone 实现可以为内存堆中的值的位置创建一个引用指针，同时增加引用计数器。由于它在线程之间共享所有权，因此当指向某个值的最后一个引用指针退出作用域时，该变量将被删除。\",\"use std::sync::Arc; use std::thread; fn main() { // 这个变量声明用来指定其值的地方。 let apple = Arc::new(\\\"the same apple\\\"); for _ in 0..10 { // 这里没有数值说明，因为它是一个指向内存堆中引用的指针。 let apple = Arc::clone(&apple); thread::spawn(move || { // 由于使用了Arc，线程可以使用分配在 `Arc` 变量指针位置的值来生成。 println!(\\\"{:?}\\\", apple); }); } }\"]},\"145\":{\"h\":\"箱子、栈和堆\",\"t\":[\"在 Rust 中，所有值默认都是栈分配的。通过创建 Box<T>，可以把值装箱（boxed）来使它在堆上分配。箱子（box，即 Box<T> 类型的实例）是一个智能指针，指向堆分配的 T 类型的值。当箱子离开作用域时，它的析构函数会被调用，内部的对象会被销毁，堆上分配的内存也会被释放。\",\"被装箱的值可以使用 * 运算符进行解引用；这会移除掉一层装箱。\",\"use std::mem; #[allow(dead_code)] #[derive(Debug, Clone, Copy)] struct Point { x: f64, y: f64, } #[allow(dead_code)] struct Rectangle { p1: Point, p2: Point, } fn origin() -> Point { Point { x: 0.0, y: 0.0 } } fn boxed_origin() -> Box<Point> { // 在堆上分配这个点（point），并返回一个指向它的指针 Box::new(Point { x: 0.0, y: 0.0 }) } fn main() { // （所有的类型标注都不是必需的） // 栈分配的变量 let point: Point = origin(); let rectangle: Rectangle = Rectangle { p1: origin(), p2: Point { x: 3.0, y: 4.0 } }; // 堆分配的 rectangle（矩形） let boxed_rectangle: Box<Rectangle> = Box::new(Rectangle { p1: origin(), p2: origin() }); // 函数的输出可以装箱 let boxed_point: Box<Point> = Box::new(origin()); // 两层装箱 let box_in_a_box: Box<Box<Point>> = Box::new(boxed_origin()); println!(\\\"Point occupies {} bytes in the stack\\\", mem::size_of_val(&point)); println!(\\\"Rectangle occupies {} bytes in the stack\\\", mem::size_of_val(&rectangle)); // box 的宽度就是指针宽度 println!(\\\"Boxed point occupies {} bytes in the stack\\\", mem::size_of_val(&boxed_point)); println!(\\\"Boxed rectangle occupies {} bytes in the stack\\\", mem::size_of_val(&boxed_rectangle)); println!(\\\"Boxed box occupies {} bytes in the stack\\\", mem::size_of_val(&box_in_a_box)); // 将包含在 `boxed_point` 中的数据复制到 `unboxed_point` let unboxed_point: Point = *boxed_point; println!(\\\"Unboxed point occupies {} bytes in the stack\\\", mem::size_of_val(&unboxed_point)); }\"]},\"146\":{\"h\":\"散列表 HashMap\",\"t\":[\"vector 通过整型下标来存储值，而 HashMap（散列表）通过键（key）来存储值。HashMap 的键可以是布尔型、整型、字符串，或任意实现了 Eq 和 Hash trait 的其他类型。在下一节将进一步介绍。\",\"和 vector 类似，HashMap 也是可增长的，但 HashMap 在占据了多余空间时还可以缩小自己。可以使用 HashMap::with_capacity(unit) 创建具有一定初始容量的 HashMap，也可以使用 HashMap::new() 来获得一个带有默认初始容量的 HashMap（这是推荐方式）。\",\"use std::collections::HashMap; fn call(number: &str) -> &str { match number { \\\"798-1364\\\" => \\\"We're sorry, the call cannot be completed as dialed. Please hang up and try again.\\\", \\\"645-7689\\\" => \\\"Hello, this is Mr. Awesome's Pizza. My name is Fred. What can I get for you today?\\\", _ => \\\"Hi! Who is this again?\\\" } } fn main() { let mut contacts = HashMap::new(); contacts.insert(\\\"Daniel\\\", \\\"798-1364\\\"); contacts.insert(\\\"Ashley\\\", \\\"645-7689\\\"); contacts.insert(\\\"Katie\\\", \\\"435-8291\\\"); contacts.insert(\\\"Robert\\\", \\\"956-1745\\\"); // 接受一个引用并返回 Option<&V> match contacts.get(&\\\"Daniel\\\") { Some(&number) => println!(\\\"Calling Daniel: {}\\\", call(number)), _ => println!(\\\"Don't have Daniel's number.\\\"), } // 如果被插入的值为新内容，那么 `HashMap::insert()` 返回 `None`， // 否则返回 `Some(value)` contacts.insert(\\\"Daniel\\\", \\\"164-6743\\\"); match contacts.get(&\\\"Ashley\\\") { Some(&number) => println!(\\\"Calling Ashley: {}\\\", call(number)), _ => println!(\\\"Don't have Ashley's number.\\\"), } contacts.remove(&(\\\"Ashley\\\")); // `HashMap::iter()` 返回一个迭代器，该迭代器以任意顺序举出 // (&'a key, &'a value) 对。 for (contact, &number) in contacts.iter() { println!(\\\"Calling {}: {}\\\", contact, call(number)); } }\",\"想要了解更多关于散列（hash）与散列表（hash map）（有时也称作 hash table）的工作原理，可以查看 Wikipedia 的散列表词条。\"]},\"147\":{\"h\":\"选项 Option\",\"t\":[\"有时候想要捕捉到程序某部分的失败信息，而不是调用 panic!；这可使用 Option 枚举类型来实现。\",\"Option<T> 有两个变量：\",\"None，表明失败或缺少值\",\"Some(value)，元组结构体，封装了一个 T 类型的值 value\",\"// 不会 `panic!` 的整数除法。 fn checked_division(dividend: i32, divisor: i32) -> Option<i32> { if divisor == 0 { // 失败表示成 `None` 取值 None } else { // 结果 Result 被包装到 `Some` 取值中 Some(dividend / divisor) } } // 此函数处理可能失败的除法 fn try_division(dividend: i32, divisor: i32) { // `Option` 值可以进行模式匹配，就和其他枚举类型一样 match checked_division(dividend, divisor) { None => println!(\\\"{} / {} failed!\\\", dividend, divisor), Some(quotient) => { println!(\\\"{} / {} = {}\\\", dividend, divisor, quotient) }, } } fn main() { try_division(4, 2); try_division(1, 0); // 绑定 `None` 到一个变量需要类型标注 let none: Option<i32> = None; let _equivalent_none = None::<i32>; let optional_float = Some(0f32); // 解包 `Some` 将取出被包装的值。 println!(\\\"{:?} unwraps to {:?}\\\", optional_float, optional_float.unwrap()); // 解包 `None` 将会引发 `panic!`。 println!(\\\"{:?} unwraps to {:?}\\\", none, none.unwrap()); }\"]},\"148\":{\"h\":\"panic!\",\"t\":[\"panic! 宏可用于产生一个 panic （恐慌），并开始回退（unwind）它的栈。在回退栈的同时，运行时将会释放该线程所拥有的所有资源，这是通过调用线程中所有对象的析构函数完成的。\",\"因为我们正在处理的程序只有一个线程，panic! 将会引发程序报告 panic 消息并退出。\",\"// 整型除法（/）的重新实现 fn division(dividend: i32, divisor: i32) -> i32 { if divisor == 0 { // 除以 0 会引发 panic panic!(\\\"division by zero\\\"); } else { dividend / divisor } } // `main` 任务 fn main() { // 堆分配的整数 let _x = Box::new(0i32); // 此操作将会引发一个任务失败 division(3, 0); println!(\\\"This point won't be reached!\\\"); // `_x` 应当会在此处被销毁 }\",\"可以看到，panic! 不会泄露内存：\",\"$ rustc panic.rs && valgrind ./panic ==4401== Memcheck, a memory error detector ==4401== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al. ==4401== Using Valgrind-3.10.0.SVN and LibVEX; rerun with -h for copyright info ==4401== Command: ./panic ==4401== thread '<main>' panicked at 'division by zero', panic.rs:5 ==4401== ==4401== HEAP SUMMARY: ==4401== in use at exit: 0 bytes in 0 blocks ==4401== total heap usage: 18 allocs, 18 frees, 1,648 bytes allocated ==4401== ==4401== All heap blocks were freed -- no leaks are possible ==4401== ==4401== For counts of detected and suppressed errors, rerun with: -v ==4401== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\"]},\"149\":{\"h\":\"引用计数 Rc\",\"t\":[\"当需要多个所有权时，可以使用 Rc（引用计数，Reference Counting 缩写）。Rc 跟踪引用的数量，这相当于包裹在 Rc 值的所有者的数量.\",\"每当克隆一个 Rc 时，Rc 的引用计数就会增加 1，而每当克隆得到的 Rc 退出作用域时，引用计数就会减少 1。当 Rc 的引用计数变为 0 时，这意味着已经没有所有者，Rc 和值两者都将被删除。\",\"克隆 Rc 从不执行深拷贝。克隆只创建另一个指向包裹值的指针，并增加计数。\",\"use std::rc::Rc; fn main() { let rc_examples = \\\"Rc examples\\\".to_string(); { println!(\\\"--- rc_a is created ---\\\"); let rc_a: Rc<String> = Rc::new(rc_examples); println!(\\\"Reference Count of rc_a: {}\\\", Rc::strong_count(&rc_a)); { println!(\\\"--- rc_a is cloned to rc_b ---\\\"); let rc_b: Rc<String> = Rc::clone(&rc_a); println!(\\\"Reference Count of rc_b: {}\\\", Rc::strong_count(&rc_b)); println!(\\\"Reference Count of rc_a: {}\\\", Rc::strong_count(&rc_a)); // 如果两者内部的值相等的话，则两个 `Rc` 相等。 println!(\\\"rc_a and rc_b are equal: {}\\\", rc_a.eq(&rc_b)); // 我们可以直接使用值的方法 println!(\\\"Length of the value inside rc_a: {}\\\", rc_a.len()); println!(\\\"Value of rc_b: {}\\\", rc_b); println!(\\\"--- rc_b is dropped out of scope ---\\\"); } println!(\\\"Reference Count of rc_a: {}\\\", Rc::strong_count(&rc_a)); println!(\\\"--- rc_a is dropped out of scope ---\\\"); } // 报错！`rc_examples` 已经移入 `rc_a`。 // 而且当 `rc_a` 被删时，`rc_examples` 也被一起删除。 // println!(\\\"rc_examples: {}\\\", rc_examples); // 试一试 ^ 注释掉此行代码 }\"]},\"150\":{\"h\":\"参见：\",\"t\":[\"std::rc 和 std。\"]},\"151\":{\"h\":\"结果 Result\",\"t\":[\"我们已经看到 Option 枚举类型可以用作可能失败的函数的返回值，其中返回 None 可以表明失败。但是有时要强调为什么一个操作会失败。为做到这点，我们提供了 Result 枚举类型。\",\"Result<T, E> 类型拥有两个取值：\",\"Ok(value) 表示操作成功，并包装操作返回的 value（value 拥有 T 类型）。\",\"Err(why)，表示操作失败，并包装 why，它（但愿）能够解释失败的原因（why 拥有 E 类型）。\",\"mod checked { // 我们想要捕获的数学 “错误” #[derive(Debug)] pub enum MathError { DivisionByZero, NegativeLogarithm, NegativeSquareRoot, } pub type MathResult = Result<f64, MathError>; pub fn div(x: f64, y: f64) -> MathResult { if y == 0.0 { // 此操作将会失败，那么（与其让程序崩溃）不如把失败的原因包装在 // `Err` 中并返回 Err(MathError::DivisionByZero) } else { // 此操作是有效的，返回包装在 `Ok` 中的结果 Ok(x / y) } } pub fn sqrt(x: f64) -> MathResult { if x < 0.0 { Err(MathError::NegativeSquareRoot) } else { Ok(x.sqrt()) } } pub fn ln(x: f64) -> MathResult { if x < 0.0 { Err(MathError::NegativeLogarithm) } else { Ok(x.ln()) } } } // `op(x, y)` === `sqrt(ln(x / y))` fn op(x: f64, y: f64) -> f64 { // 这是一个三层的 match 金字塔！ match checked::div(x, y) { Err(why) => panic!(\\\"{:?}\\\", why), Ok(ratio) => match checked::ln(ratio) { Err(why) => panic!(\\\"{:?}\\\", why), Ok(ln) => match checked::sqrt(ln) { Err(why) => panic!(\\\"{:?}\\\", why), Ok(sqrt) => sqrt, }, }, } } fn main() { // 这会失败吗？ println!(\\\"{}\\\", op(1.0, 10.0)); }\"]},\"152\":{\"h\":\"字符串\",\"t\":[\"Rust 中有两种字符串类型：String 和 &str。\",\"String 被存储为由字节组成的 vector（Vec<u8>），但保证了它一定是一个有效的 UTF-8 序列。String 是堆分配的，可增长的，且不是零结尾的（null terminated）。\",\"&str 是一个总是指向有效 UTF-8 序列的切片（&[u8]），并可用来查看 String 的内容，就如同 &[T] 是 Vec<T> 的全部或部分引用。\",\"fn main() { // （所有的类型标注都不是必需的） // 一个对只读内存中分配的字符串的引用 let pangram: &'static str = \\\"the quick brown fox jumps over the lazy dog\\\"; println!(\\\"Pangram: {}\\\", pangram); // 逆序迭代单词，这里并没有分配新的字符串 println!(\\\"Words in reverse\\\"); for word in pangram.split_whitespace().rev() { println!(\\\"> {}\\\", word); } // 复制字符到一个 vector，排序并移除重复值 let mut chars: Vec<char> = pangram.chars().collect(); chars.sort(); chars.dedup(); // 创建一个空的且可增长的 `String` let mut string = String::new(); for c in chars { // 在字符串的尾部插入一个字符 string.push(c); // 在字符串尾部插入一个字符串 string.push_str(\\\", \\\"); } // 这个缩短的字符串是原字符串的一个切片，所以没有执行新的分配操作 let chars_to_trim: &[char] = &[' ', ',']; let trimmed_str: &str = string.trim_matches(chars_to_trim); println!(\\\"Used characters: {}\\\", trimmed_str); // 堆分配一个字符串 let alice = String::from(\\\"I like dogs\\\"); // 分配新内存并存储修改过的字符串 let bob: String = alice.replace(\\\"dog\\\", \\\"cat\\\"); println!(\\\"Alice says: {}\\\", alice); println!(\\\"Bob says: {}\\\", bob); }\",\"更多 str/String 方法可以在 std::str 和 std::string 模块中找到。\"]},\"153\":{\"h\":\"字面量与转义字符\",\"t\":[\"书写含有特殊字符的字符串字面量有很多种方法。它们都会产生类似的 &str，所以最好选择最方便的写法。类似地，字节串（byte string）字面量也有多种写法，它们都会产生&[u8; N] 类型。\",\"通常特殊字符是使用反斜杠字符 \\\\ 来转义的，这样你就可以在字符串中写入各种各样的字符，甚至是不可打印的字符以及你不知道如何输入的字符。如果你需要反斜杠字符，再用另一个反斜杠来转义它就可以，像这样：\\\\\\\\。\",\"字面量中出现的字符串或字符定界符必须转义：\\\"\\\\\\\"\\\"、'\\\\''。\",\"fn main() { // 通过转义，可以用十六进制值来表示字节。 let byte_escape = \\\"I'm writing \\\\x52\\\\x75\\\\x73\\\\x74!\\\"; println!(\\\"What are you doing\\\\x3F (\\\\\\\\x3F means ?) {}\\\", byte_escape); // 也可以使用 Unicode 码位表示。 let unicode_codepoint = \\\"\\\\u{211D}\\\"; let character_name = \\\"\\\\\\\"DOUBLE-STRUCK CAPITAL R\\\\\\\"\\\"; println!(\\\"Unicode character {} (U+211D) is called {}\\\", unicode_codepoint, character_name ); let long_string = \\\"String literals can span multiple lines. The linebreak and indentation here ->\\\\ <- can be escaped too!\\\"; println!(\\\"{}\\\", long_string); }\",\"有时会有太多需要转义的字符，或者是直接原样写出会更便利。这时可以使用原始字符串（raw string）。\",\"fn main() { let raw_str = r\\\"Escapes don't work here: \\\\x3F \\\\u{211D}\\\"; println!(\\\"{}\\\", raw_str); // 如果你要在原始字符串中写引号，请在两边加一对 # let quotes = r#\\\"And then I said: \\\"There is no escape!\\\"\\\"#; println!(\\\"{}\\\", quotes); // 如果字符串中需要写 \\\"#，那就在定界符中使用更多的 #。 // 可使用的 # 的数目没有限制。 let longer_delimiter = r###\\\"A string with \\\"# in it. And even \\\"##!\\\"###; println!(\\\"{}\\\", longer_delimiter); }\",\"想要非 UTF-8 字符串（记住，&str 和 String 都必须是合法的 UTF-8 序列），或者需要一个字节数组，其中大部分是文本？请使用字节串（byte string）！\",\"use std::str; fn main() { // 注意这并不是一个 &str let bytestring: &[u8; 20] = b\\\"this is a bytestring\\\"; // 字节串没有实现 Display，所以它们的打印功能有些受限 println!(\\\"A bytestring: {:?}\\\", bytestring); // 字节串可以使用单字节的转义字符... let escaped = b\\\"\\\\x52\\\\x75\\\\x73\\\\x74 as bytes\\\"; // ...但不能使用 Unicode 转义字符 // let escaped = b\\\"\\\\u{211D} is not allowed\\\"; println!(\\\"Some escaped bytes: {:?}\\\", escaped); // 原始字节串和原始字符串的写法一样 let raw_bytestring = br\\\"\\\\u{211D} is not escaped here\\\"; println!(\\\"{:?}\\\", raw_bytestring); // 把字节串转换为 &str 可能失败 if let Ok(my_str) = str::from_utf8(raw_bytestring) { println!(\\\"And the same as text: '{}'\\\", my_str); } let quotes = br#\\\"You can also use \\\"fancier\\\" formatting, \\\\ like with normal raw strings\\\"#; // 字节串可以不使用 UTF-8 编码 let shift_jis = b\\\"\\\\x82\\\\xe6\\\\x82\\\\xa8\\\\x82\\\\xb1\\\\x82\\\"; // SHIFT-JIS 编码的 \\\"ようこそ\\\" // 但这样的话它们就无法转换成 &str 了 match str::from_utf8(shift_jis) { Ok(my_str) => println!(\\\"Conversion successful: '{}'\\\", my_str), Err(e) => println!(\\\"Conversion failed: {:?}\\\", e), }; }\",\"若需要在编码间转换，请使用 encoding crate。\",\"Rust 参考中的 Tokens 一章详细地列出了书写字符串字面量和转义字符的方法。\"]},\"154\":{\"h\":\"动态数组 vector\",\"t\":[\"vector 是大小可变的数组。和 slice（切片）类似，它们的大小在编译时是未知的，但它们可以随时扩大或缩小。一个 vector 使用 3 个词来表示：一个指向数据的指针，vector 的长度，还有它的容量。此容量指明了要为这个 vector 保留多少内存。vector 的长度只要小于该容量，就可以随意增长；当需要超过这个阈值时，会给 vector 重新分配一段更大的容量。\",\"fn main() { // 迭代器可以被收集到 vector 中 let collected_iterator: Vec<i32> = (0..10).collect(); println!(\\\"Collected (0..10) into: {:?}\\\", collected_iterator); // `vec!` 宏可用来初始化一个 vector let mut xs = vec![1i32, 2, 3]; println!(\\\"Initial vector: {:?}\\\", xs); // 在 vector 的尾部插入一个新的元素 println!(\\\"Push 4 into the vector\\\"); xs.push(4); println!(\\\"Vector: {:?}\\\", xs); // 报错！不可变 vector 不可增长 collected_iterator.push(0); // 改正 ^ 将此行注释掉 // `len` 方法获得一个 vector 的当前大小 println!(\\\"Vector size: {}\\\", xs.len()); // 下标使用中括号表示（从 0 开始） println!(\\\"Second element: {}\\\", xs[1]); // `pop` 移除 vector 的最后一个元素并将它返回 println!(\\\"Pop last element: {:?}\\\", xs.pop()); // 超出下标范围将抛出一个 panic println!(\\\"Fourth element: {}\\\", xs[3]); // 改正 ^ 注释掉此行 // 迭代一个 `Vector` 很容易 println!(\\\"Contents of xs:\\\"); for x in xs.iter() { println!(\\\"> {}\\\", x); } // 可以在迭代 `Vector` 的同时，使用独立变量（`i`）来记录迭代次数 for (i, x) in xs.iter().enumerate() { println!(\\\"In position {} we have value {}\\\", i, x); } // 多亏了 `iter_mut`，可变的 `Vector` 在迭代的同时，其中每个值都能被修改 for x in xs.iter_mut() { *x *= 3; } println!(\\\"Updated vector: {:?}\\\", xs); }\",\"更多 Vec 方法可以在 std::vec 模块中找到。\"]},\"155\":{\"h\":\"程序参数\"},\"156\":{\"h\":\"标准库\",\"t\":[\"命令行参数可使用 std::env::args 进行接收，这将返回一个迭代器，该迭代器会对每个参数举出一个字符串。\",\"use std::env; fn main() { let args: Vec<String> = env::args().collect(); // 第一个参数是调用本程序的路径 println!(\\\"My path is {}.\\\", args[0]); // 其余的参数是被传递给程序的命令行参数。 // 请这样调用程序： // $ ./args arg1 arg2 println!(\\\"I got {:?} arguments: {:?}.\\\", args.len() - 1, &args[1..]); }\",\"$ ./args 1 2 3 My path is ./args. I got 3 arguments: [\\\"1\\\", \\\"2\\\", \\\"3\\\"].\"]},\"157\":{\"h\":\"crate\",\"t\":[\"另外，也有很多 crate 提供了编写命令行应用的额外功能。Rust Cookbook 展示了使用最流行的命令行参数 crate，即 clap 的最佳实践。\"]},\"158\":{\"h\":\"通道\",\"t\":[\"Rust 为线程之间的通信提供了异步的通道（channel）。通道允许两个端点之间信息的单向流动：Sender（发送端） 和 Receiver（接收端）。\",\"use std::sync::mpsc::{Sender, Receiver}; use std::sync::mpsc; use std::thread; static NTHREADS: i32 = 3; fn main() { // 通道有两个端点：`Sender<T>` 和 `Receiver<T>`，其中 `T` 是要发送 // 的消息的类型（类型标注是可选的） let (tx, rx): (Sender<i32>, Receiver<i32>) = mpsc::channel(); for id in 0..NTHREADS { // sender 端可被复制 let thread_tx = tx.clone(); // 每个线程都将通过通道来发送它的 id thread::spawn(move || { // 被创建的线程取得 `thread_tx` 的所有权 // 每个线程都把消息放在通道的消息队列中 thread_tx.send(id).unwrap(); // 发送是一个非阻塞（non-blocking）操作，线程将在发送完消息后 // 会立即继续进行 println!(\\\"thread {} finished\\\", id); }); } // 所有消息都在此处被收集 let mut ids = Vec::with_capacity(NTHREADS as usize); for _ in 0..NTHREADS { // `recv` 方法从通道中拿到一个消息 // 若无可用消息的话，`recv` 将阻止当前线程 ids.push(rx.recv()); } // 显示消息被发送的次序 println!(\\\"{:?}\\\", ids); }\"]},\"159\":{\"h\":\"外部语言函数接口\",\"t\":[\"Rust 提供了到 C 语言库的外部语言函数接口（Foreign Function Interface，FFI）。外部语言函数必须在一个 extern 代码块中声明，且该代码块要带有一个包含库名称的 #[link] 属性。\",\"use std::fmt; // 这个 extern 代码块链接到 libm 库 #[link(name = \\\"m\\\")] extern { // 这个外部函数用于计算单精度复数的平方根 fn csqrtf(z: Complex) -> Complex; // 这个用来计算单精度复数的复变余弦 fn ccosf(z: Complex) -> Complex; } // 由于调用其他语言的函数被认为是不安全的，我们通常会给它们写一层安全的封装 fn cos(z: Complex) -> Complex { unsafe { ccosf(z) } } fn main() { // z = -1 + 0i let z = Complex { re: -1., im: 0. }; // 调用外部语言函数是不安全操作 let z_sqrt = unsafe { csqrtf(z) }; println!(\\\"the square root of {:?} is {:?}\\\", z, z_sqrt); // 调用不安全操作的安全的 API 封装 println!(\\\"cos({:?}) = {:?}\\\", z, cos(z)); } // 单精度复数的最简实现 #[repr(C)] #[derive(Clone, Copy)] struct Complex { re: f32, im: f32, } impl fmt::Debug for Complex { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { if self.im < 0. { write!(f, \\\"{}-{}i\\\", self.re, -self.im) } else { write!(f, \\\"{}+{}i\\\", self.re, self.im) } } }\"]},\"160\":{\"h\":\"文件输入输出（I/O）\",\"t\":[\"File 结构体表示一个被打开的文件（它包裹了一个文件描述符），并赋予了对所表示的文件的读写能力。\",\"由于在进行文件 I/O（输入/输出）操作时可能出现各种错误，因此 File 的所有方法都返回 io::Result<T> 类型，它是 Result<T, io::Error> 的别名。\",\"这使得所有 I/O 操作的失败都变成显式的。借助这点，程序员可以看到所有的失败路径，并被鼓励主动地处理这些情形。\"]},\"161\":{\"h\":\"文件系统操作\",\"t\":[\"std::io::fs 模块包含几个处理文件系统的函数。\",\"use std::fs; use std::fs::{File, OpenOptions}; use std::io; use std::io::prelude::*; use std::os::unix; use std::path::Path; // `% cat path` 的简单实现 fn cat(path: &Path) -> io::Result<String> { let mut f = File::open(path)?; let mut s = String::new(); match f.read_to_string(&mut s) { Ok(_) => Ok(s), Err(e) => Err(e), } } // `% echo s > path` 的简单实现 fn echo(s: &str, path: &Path) -> io::Result<()> { let mut f = File::create(path)?; f.write_all(s.as_bytes()) } // `% touch path` 的简单实现（忽略已存在的文件） fn touch(path: &Path) -> io::Result<()> { match OpenOptions::new().create(true).write(true).open(path) { Ok(_) => Ok(()), Err(e) => Err(e), } } fn main() { println!(\\\"`mkdir a`\\\"); // 创建一个目录，返回 `io::Result<()>` match fs::create_dir(\\\"a\\\") { Err(why) => println!(\\\"! {:?}\\\", why.kind()), Ok(_) => {}, } println!(\\\"`echo hello > a/b.txt`\\\"); // 前面的匹配可以用 `unwrap_or_else` 方法简化 echo(\\\"hello\\\", &Path::new(\\\"a/b.txt\\\")).unwrap_or_else(|why| { println!(\\\"! {:?}\\\", why.kind()); }); println!(\\\"`mkdir -p a/c/d`\\\"); // 递归地创建一个目录，返回 `io::Result<()>` fs::create_dir_all(\\\"a/c/d\\\").unwrap_or_else(|why| { println!(\\\"! {:?}\\\", why.kind()); }); println!(\\\"`touch a/c/e.txt`\\\"); touch(&Path::new(\\\"a/c/e.txt\\\")).unwrap_or_else(|why| { println!(\\\"! {:?}\\\", why.kind()); }); println!(\\\"`ln -s ../b.txt a/c/b.txt`\\\"); // 创建一个符号链接，返回 `io::Resutl<()>` if cfg!(target_family = \\\"unix\\\") { unix::fs::symlink(\\\"../b.txt\\\", \\\"a/c/b.txt\\\").unwrap_or_else(|why| { println!(\\\"! {:?}\\\", why.kind()); }); } println!(\\\"`cat a/c/b.txt`\\\"); match cat(&Path::new(\\\"a/c/b.txt\\\")) { Err(why) => println!(\\\"! {:?}\\\", why.kind()), Ok(s) => println!(\\\"> {}\\\", s), } println!(\\\"`ls a`\\\"); // 读取目录的内容，返回 `io::Result<Vec<Path>>` match fs::read_dir(\\\"a\\\") { Err(why) => println!(\\\"! {:?}\\\", why.kind()), Ok(paths) => for path in paths { println!(\\\"> {:?}\\\", path.unwrap().path()); }, } println!(\\\"`rm a/c/e.txt`\\\"); // 删除一个文件，返回 `io::Result<()>` fs::remove_file(\\\"a/c/e.txt\\\").unwrap_or_else(|why| { println!(\\\"! {:?}\\\", why.kind()); }); println!(\\\"`rmdir a/c/d`\\\"); // 移除一个空目录，返回 `io::Result<()>` fs::remove_dir(\\\"a/c/d\\\").unwrap_or_else(|why| { println!(\\\"! {:?}\\\", why.kind()); }); }\",\"下面是所期望的成功的输出：\",\"$ rustc fs.rs && ./fs `mkdir a` `echo hello > a/b.txt` `mkdir -p a/c/d` `touch a/c/e.txt` `ln -s ../b.txt a/c/b.txt` `cat a/c/b.txt` > hello `ls a` > \\\"a/b.txt\\\" > \\\"a/c\\\" `rm a/c/e.txt` `rmdir a/c/d`\",\"且 a 目录的最终状态为：\",\"$ tree a a |-- b.txt `-- c `-- b.txt -> ../b.txt 1 directory, 2 files\",\"另一种定义 cat 函数的方式是使用 ? 标记：\",\"fn cat(path: &Path) -> io::Result<String> { let mut f = File::open(path)?; let mut s = String::new(); f.read_to_string(&mut s)?; Ok(s) }\"]},\"162\":{\"h\":\"参见：\",\"t\":[\"cfg!\"]},\"163\":{\"h\":\"\",\"t\":[\"File 结构体表示一个被打开的文件（它装包了一个文件描述符），并赋予了针对底层文件的读和/或写能力。（原文：The File struct represents a file that has been opened (it wraps a file descriptor), and gives read and/or write access to the underlying file.）\",\"由于在进行文件 I/O（输入/输出）操作时很多情形都可能出现错误，因此所有的 File 方法都返回 io::Result<T> 类型，这是 Result<T, io::Error> 的别名。\",\"这使得所有 I/O 操作的失败都变成显式内容。借助这点，程序员可以看到所有的失败路径，并鼓励主动去处理这些情形。\"]},\"164\":{\"h\":\"路径\",\"t\":[\"Path 结构体代表了底层文件系统的文件路径。Path 分为两种：posix::Path，针对类 UNIX 系统；以及 windows::Path，针对 Windows。prelude 会选择并输出符合平台类型的 Path 种类。\",\"译注：prelude 是 Rust 自动地在每个程序中导入的一些通用的东西，这样我们就不必每写 一个程序就手动导入一番。\",\"Path 可从 OsStr 类型创建，并且它提供数种方法，用于获取路径指向的文件/目录的信息。\",\"注意 Path 在内部并不是用 UTF-8 字符串表示的，而是存储为若干字节（Vec<u8>）的 vector。因此，将 Path 转化成 &str 并非零开销的（free），且可能失败（因此它返回一个 Option）。\",\"use std::path::Path; fn main() { // 从 `&'static str` 创建一个 `Path` let path = Path::new(\\\".\\\"); // `display` 方法返回一个可显示（showable）的结构体 let display = path.display(); // `join` 使用操作系统特定的分隔符来合并路径到一个字节容器，并返回新的路径 let new_path = path.join(\\\"a\\\").join(\\\"b\\\"); // 将路径转换成一个字符串切片 match new_path.to_str() { None => panic!(\\\"new path is not a valid UTF-8 sequence\\\"), Some(s) => println!(\\\"new path is {}\\\", s), } }\",\"记得看看其他的 Path 方法（posix::Path 或 windows::Path 的），还有 Metadata 结构体类型。\"]},\"165\":{\"h\":\"参见\",\"t\":[\"OsStr 和 Metadata。\"]},\"166\":{\"h\":\"子进程\",\"t\":[\"process::Output 结构体表示已结束的子进程（child process）的输出，而process::Command 结构体是一个进程创建者（process builder）。\",\"use std::process::Command; fn main() { let output = Command::new(\\\"rustc\\\") .arg(\\\"--version\\\") .output().unwrap_or_else(|e| { panic!(\\\"failed to execute process: {}\\\", e) }); if output.status.success() { let s = String::from_utf8_lossy(&output.stdout); print!(\\\"rustc succeeded and stdout was:\\\\n{}\\\", s); } else { let s = String::from_utf8_lossy(&output.stderr); print!(\\\"rustc failed and stderr was:\\\\n{}\\\", s); } }\",\"（再试试上面的例子，给 rustc 命令传入一个错误的 flag）\"]},\"167\":{\"h\":\"线程\",\"t\":[\"Rust 通过 spawn 函数提供了创建本地操作系统（native OS）线程的机制，该函数的参数是一个通过值捕获变量的闭包（moving closure）。\",\"use std::thread; static NTHREADS: i32 = 10; // 这是主（`main`）线程 fn main() { // 提供一个 vector 来存放所创建的子线程（children）。 let mut children = vec![]; for i in 0..NTHREADS { // 启动（spin up）另一个线程 children.push(thread::spawn(move || { println!(\\\"this is thread number {}\\\", i) })); } for child in children { // 等待线程结束。返回一个结果。 let _ = child.join(); } }\",\"这些线程由操作系统调度（schedule）。\"]},\"168\":{\"h\":\"开发依赖\",\"t\":[\"有时仅在测试中才需要一些依赖（比如基准测试相关的）。这种依赖要写在 Cargo.toml 的 [dev-dependencies] 部分。这些依赖不会传播给其他依赖于这个包的包。\",\"比如说使用 pretty_assertions，这是扩展了标准的 assert! 宏的一个 crate。\",\"文件 Cargo.toml:\",\"# 这里省略了标准的 crate 数据 [dev-dependencies] pretty_assertions = \\\"1\\\"\",\"文件 src/lib.rs:\",\"pub fn add(a: i32, b: i32) -> i32 { a + b } #[cfg(test)] mod tests { use super::*; use pretty_assertions::assert_eq; // 仅用于测试, 不能在非测试代码中使用 #[test] fn test_add() { assert_eq!(add(2, 3), 5); } }\"]},\"169\":{\"h\":\"参见\",\"t\":[\"Cargo 文档中关于指定依赖的部分。\"]},\"170\":{\"h\":\"文档测试\",\"t\":[\"为 Rust 工程编写文档的主要方式是在源代码中写注释。文档注释使用 markdown 语法书写，支持代码块。Rust 很注重正确性，这些注释中的代码块也会被编译并且用作测试。\",\"/// 第一行是对函数的简短描述。 /// /// 接下来数行是详细文档。代码块用三个反引号开启，Rust 会隐式地在其中添加 /// `fn main()` 和 `extern crate <cratename>`。比如测试 `doccomments` crate： /// /// ``` /// let result = doccomments::add(2, 3); /// assert_eq!(result, 5); /// ``` pub fn add(a: i32, b: i32) -> i32 { a + b } /// 文档注释通常可能带有 \\\"Examples\\\"、\\\"Panics\\\" 和 \\\"Failures\\\" 这些部分。 /// /// 下面的函数将两数相除。 /// /// # Examples /// /// ``` /// let result = doccomments::div(10, 2); /// assert_eq!(result, 5); /// ``` /// /// # Panics /// /// 如果第二个参数是 0，函数将会 panic。 /// /// ```rust,should_panic /// // panics on division by zero /// doccomments::div(10, 0); /// ``` pub fn div(a: i32, b: i32) -> i32 { if b == 0 { panic!(\\\"Divide-by-zero error\\\"); } a / b }\",\"这些测试仍然可以通过 cargo test 执行：\",\"$ cargo test running 0 tests test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out Doc-tests doccomments running 3 tests test src/lib.rs - add (line 7) ... ok test src/lib.rs - div (line 21) ... ok test src/lib.rs - div (line 31) ... ok test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\"]},\"171\":{\"h\":\"文档测试的目的\",\"t\":[\"文档测试的主要目的是作为使用函数功能的例子，这是最重要的指导原则之一。文档测试应当可以作为完整的代码段被直接使用（很多用户会复制文档中的代码来用，所以例子要写得完善）。但使用 ? 符号会导致编译失败，因为 main 函数会返回 unit 类型。幸运的是，我们可以在文档中隐藏几行源代码：你可以写 fn try_main() -> Result<(), ErrorType> 这样的函数，把它隐藏起来，然后在隐藏的 main 中展开它。听起来很复杂？请看例子：\",\"/// 在文档测试中使用隐藏的 `try_main`。 /// /// ``` /// # // 被隐藏的行以 `#` 开始，但它们仍然会被编译！ /// # fn try_main() -> Result<(), String> { // 隐藏行包围了文档中显示的函数体 /// let res = try::try_div(10, 2)?; /// # Ok(()) // 从 try_main 返回 /// # } /// # fn main() { // 开始主函数，其中将展开 `try_main` 函数 /// # try_main().unwrap(); // 调用并展开 try_main，这样出错时测试会 panic /// # } /// ``` pub fn try_div(a: i32, b: i32) -> Result<i32, String> { if b == 0 { Err(String::from(\\\"Divide-by-zero\\\")) } else { Ok(a / b) } }\"]},\"172\":{\"h\":\"参见\",\"t\":[\"关于文档风格的 RFC505\",\"API 指导原则中关于文档的原则\"]},\"173\":{\"h\":\"集成测试\",\"t\":[\"单元测试一次仅能单独测试一个模块，这种测试是小规模的，并且能测试私有代码；集成测试是 crate 外部的测试，并且仅使用 crate 的公共接口，就像其他使用该 crate 的程序那样。集成测试的目的是检验你的库的各部分是否能够正确地协同工作。\",\"cargo 在与 src 同级别的 tests 目录寻找集成测试。\",\"文件 src/lib.rs：\",\"// 在一个叫做 'adder' 的 crate 中定义此函数。 pub fn add(a: i32, b: i32) -> i32 { a + b }\",\"包含测试的文件：tests/integration_test.rs：\",\" #[test] fn test_add() { assert_eq!(adder::add(3, 2), 5); }\",\"使用 cargo test 命令：\",\"$ cargo test running 0 tests test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out Running target/debug/deps/integration_test-bcd60824f5fbfe19 running 1 test test test_add ... ok test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out Doc-tests adder running 0 tests test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\",\"tests 目录中的每一个 Rust 源文件都被编译成一个单独的 crate。在集成测试中要想共享代码，一种方式是创建具有公用函数的模块，然后在测试中导入并使用它。\",\"文件 tests/common.rs:\",\"pub fn setup() { // 一些配置代码，比如创建文件/目录，开启服务器等等。 }\",\"包含测试的文件：tests/integration_test.rs\",\"// 导入共用模块。 mod common; #[test] fn test_add() { // 使用共用模块。 common::setup(); assert_eq!(adder::add(3, 2), 5); }\",\"带有共用代码的模块遵循和普通的模块一样的规则，所以完全可以把公共模块写在 tests/common/mod.rs 文件中。\"]},\"174\":{\"h\":\"单元测试\",\"t\":[\"测试（test）是这样一种 Rust 函数：它保证其他部分的代码按照所希望的行为正常运行。测试函数的函数体通常会进行一些配置，运行我们想要测试的代码，然后断言（assert）结果是不是我们所期望的。\",\"大多数单元测试都会被放到一个叫 tests 的、带有 #[cfg(test)] 属性的模块中，测试函数要加上 #[test] 属性。\",\"当测试函数中有什么东西 panic 了，测试就失败。有一些这方面的辅助宏：\",\"assert!(expression) - 如果表达式的值是 false 则 panic。\",\"assert_eq!(left, right) 和 assert_ne!(left, right) - 检验左右两边是否 相等/不等。\",\"pub fn add(a: i32, b: i32) -> i32 { a + b } // 这个加法函数写得很差，本例中我们会使它失败。 #[allow(dead_code)] fn bad_add(a: i32, b: i32) -> i32 { a - b } #[cfg(test)] mod tests { // 注意这个惯用法：在 tests 模块中，从外部作用域导入所有名字。 use super::*; #[test] fn test_add() { assert_eq!(add(1, 2), 3); } #[test] fn test_bad_add() { // 这个断言会导致测试失败。注意私有的函数也可以被测试！ assert_eq!(bad_add(1, 2), 3); } }\",\"可以使用 cargo test 来运行测试。\",\"$ cargo test running 2 tests test tests::test_bad_add ... FAILED test tests::test_add ... ok failures: ---- tests::test_bad_add stdout ---- thread 'tests::test_bad_add' panicked at 'assertion failed: `(left == right)` left: `-1`, right: `3`', src/lib.rs:21:8 note: Run with `RUST_BACKTRACE=1` for a backtrace. failures: tests::test_bad_add test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out\"]},\"175\":{\"h\":\"测试 panic\",\"t\":[\"一些函数应当在特定条件下 panic。为测试这种行为，请使用 #[should_panic] 属性。这个属性接受可选参数 expected = 以指定 panic 时的消息。如果你的函数能以多种方式 panic，这个属性就保证了你在测试的确实是所指定的 panic。\",\"pub fn divide_non_zero_result(a: u32, b: u32) -> u32 { if b == 0 { panic!(\\\"Divide-by-zero error\\\"); } else if a < b { panic!(\\\"Divide result is zero\\\"); } a / b } #[cfg(test)] mod tests { use super::*; #[test] fn test_divide() { assert_eq!(divide_non_zero_result(10, 2), 5); } #[test] #[should_panic] fn test_any_panic() { divide_non_zero_result(1, 0); } #[test] #[should_panic(expected = \\\"Divide result is zero\\\")] fn test_specific_panic() { divide_non_zero_result(1, 10); } }\",\"运行这些测试会输出：\",\"$ cargo test running 3 tests test tests::test_any_panic ... ok test tests::test_divide ... ok test tests::test_specific_panic ... ok test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out Doc-tests tmp-test-should-panic running 0 tests test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\"]},\"176\":{\"h\":\"运行特定的测试\",\"t\":[\"要运行特定的测试，只要把测试名称传给 cargo test 命令就可以了。\",\"$ cargo test test_any_panic running 1 test test tests::test_any_panic ... ok test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out Doc-tests tmp-test-should-panic running 0 tests test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\",\"要运行多个测试，可以仅指定测试名称中的一部分，用它来匹配所有要运行的测试。\",\"$ cargo test panic running 2 tests test tests::test_any_panic ... ok test tests::test_specific_panic ... ok test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out Doc-tests tmp-test-should-panic running 0 tests test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\"]},\"177\":{\"h\":\"忽略测试\",\"t\":[\"可以把属性 #[ignore] 赋予测试以排除某些测试，或者使用 cargo test -- --ignored 命令来运行它们。\",\"pub fn add(a: i32, b: i32) -> i32 { a + b } #[cfg(test)] mod tests { use super::*; #[test] fn test_add() { assert_eq!(add(2, 2), 4); } #[test] fn test_add_hundred() { assert_eq!(add(100, 2), 102); assert_eq!(add(2, 100), 102); } #[test] #[ignore] fn ignored_test() { assert_eq!(add(0, 0), 0); } }\",\"$ cargo test running 1 test test tests::ignored_test ... ignored test result: ok. 0 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out Doc-tests tmp-ignore running 0 tests test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out $ cargo test -- --ignored running 1 test test tests::ignored_test ... ok test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out Doc-tests tmp-ignore running 0 tests test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\"]},\"178\":{\"h\":\"Clone\",\"t\":[\"当处理资源时，默认的行为是在赋值或函数调用的同时将它们转移。但是我们有时候也需要把资源复制一份。\",\"Clone trait 正好帮助我们完成这任务。通常，我们可以使用由 Clone trait 定义的 .clone() 方法。\",\"// 不含资源的单元结构体 #[derive(Debug, Clone, Copy)] struct Nil; // 一个包含资源的结构体，它实现了 `Clone` trait #[derive(Clone, Debug)] struct Pair(Box<i32>, Box<i32>); fn main() { // 实例化 `Nil` let nil = Nil; // 复制 `Nil`，没有资源用于移动（move） let copied_nil = nil; // 两个 `Nil` 都可以独立使用 println!(\\\"original: {:?}\\\", nil); println!(\\\"copy: {:?}\\\", copied_nil); // 实例化 `Pair` let pair = Pair(Box::new(1), Box::new(2)); println!(\\\"original: {:?}\\\", pair); // 将 `pair` 绑定到 `moved_pair`，移动（move）了资源 let moved_pair = pair; println!(\\\"copy: {:?}\\\", moved_pair); // 报错！`pair` 已失去了它的资源。 //println!(\\\"original: {:?}\\\", pair); // 试一试 ^ 取消此行注释。 // 将 `moved_pair`（包括其资源）克隆到 `cloned_pair`。 let cloned_pair = moved_pair.clone(); // 使用 std::mem::drop 来销毁原始的 pair。 drop(moved_pair); // 报错！`moved_pair` 已被销毁。 //println!(\\\"copy: {:?}\\\", moved_pair); // 试一试 ^ 将此行注释掉。 // 由 .clone() 得来的结果仍然可用！ println!(\\\"clone: {:?}\\\", cloned_pair); }\"]},\"179\":{\"h\":\"派生\",\"t\":[\"通过 #[derive]属性，编译器能够提供某些 trait 的基本实现。如果需要更复杂的行为，这些 trait 也可以手动实现。\",\"下面是可以自动派生的 trait：\",\"比较 trait:Eq, PartialEq, Ord, PartialOrd\",\"Clone, 用来从 &T 创建副本 T。\",\"Copy，使类型具有 “复制语义”（copy semantics）而非 “移动语义”（move semantics）。\",\"Hash，从 &T 计算哈希值（hash）。\",\"Default, 创建数据类型的一个空实例。\",\"Debug，使用 {:?} formatter 来格式化一个值。\",\"// `Centimeters`，可以比较的元组结构体 #[derive(PartialEq, PartialOrd)] struct Centimeters(f64); // `Inches`，可以打印的元组结构体 #[derive(Debug)] struct Inches(i32); impl Inches { fn to_centimeters(&self) -> Centimeters { let &Inches(inches) = self; Centimeters(inches as f64 * 2.54) } } // `Seconds`，不带附加属性的元组结构体 struct Seconds(i32); fn main() { let _one_second = Seconds(1); // 报错：`Seconds` 不能打印；它没有实现 `Debug` trait //println!(\\\"One second looks like: {:?}\\\", _one_second); // 试一试 ^ 取消此行注释 // 报错：`Seconds`不能比较；它没有实现 `PartialEq` trait //let _this_is_true = (_one_second == _one_second); // 试一试 ^ 取消此行注释 let foot = Inches(12); println!(\\\"One foot equals {:?}\\\", foot); let meter = Centimeters(100.0); let cmp = if foot.to_centimeters() < meter { \\\"smaller\\\" } else { \\\"bigger\\\" }; println!(\\\"One foot is {} than one meter.\\\", cmp); }\"]},\"180\":{\"h\":\"参见\",\"t\":[\"derive\"]},\"181\":{\"h\":\"消除重叠 trait\",\"t\":[\"一个类型可以实现许多不同的 trait。如果两个 trait 都需要相同的名称怎么办？例如，许多 trait 可能拥有名为 get() 的方法。他们甚至可能有不同的返回类型！\",\"有个好消息：由于每个 trait 实现都有自己的 impl 块，因此很清楚您要实现哪个 trait 的 get 方法。\",\"何时需要调用这些方法呢？为了消除它们之间的歧义，我们必须使用完全限定语法（Fully Qualified Syntax）。\",\"trait UsernameWidget { // 从这个 widget 中获取选定的用户名 fn get(&self) -> String; } trait AgeWidget { // 从这个 widget 中获取选定的年龄 fn get(&self) -> u8; } // 同时具有 UsernameWidget 和 AgeWidget 的表单 struct Form { username: String, age: u8, } impl UsernameWidget for Form { fn get(&self) -> String { self.username.clone() } } impl AgeWidget for Form { fn get(&self) -> u8 { self.age } } fn main() { let form = Form{ username: \\\"rustacean\\\".to_owned(), age: 28, }; // 如果取消注释此行，则会收到一条错误消息，提示 “multiple `get` found”（找到了多个`get`）。 // 因为毕竟有多个名为 `get` 的方法。 // println!(\\\"{}\\\", form.get()); let username = <Form as UsernameWidget>::get(&form); assert_eq!(\\\"rustacean\\\".to_owned(), username); let age = <Form as AgeWidget>::get(&form); assert_eq!(28, age); }\"]},\"182\":{\"h\":\"参见：\",\"t\":[\"《Rust 程序设计语言》中关于“完全限定语法”的章节\"]},\"183\":{\"h\":\"Drop\",\"t\":[\"Drop trait 只有一个方法：drop，当对象离开作用域时会自动调用该方法。Drop trait 的主要作用是释放实现者的实例拥有的资源。\",\"Box，Vec，String，File，以及 Process 是一些实现了 Drop trait 来释放资源的类型。Drop trait 也可以为任何自定义数据类型手动实现。\",\"下面示例给 drop 函数增加了打印到控制台的功能，用于宣布它在什么时候被调用。\",\"struct Droppable { name: &'static str, } // 这个简单的 `drop` 实现添加了打印到控制台的功能。 impl Drop for Droppable { fn drop(&mut self) { println!(\\\"> Dropping {}\\\", self.name); } } fn main() { let _a = Droppable { name: \\\"a\\\" }; // 代码块 A { let _b = Droppable { name: \\\"b\\\" }; // 代码块 B { let _c = Droppable { name: \\\"c\\\" }; let _d = Droppable { name: \\\"d\\\" }; println!(\\\"Exiting block B\\\"); } println!(\\\"Just exited block B\\\"); println!(\\\"Exiting block A\\\"); } println!(\\\"Just exited block A\\\"); // 变量可以手动使用 `drop` 函数来销毁。 drop(_a); // 试一试 ^ 将此行注释掉。 println!(\\\"end of the main function\\\"); // `_a` *不会*在这里再次销毁，因为它已经被（手动）销毁。 }\"]},\"184\":{\"h\":\"使用 dyn 返回 trait\",\"t\":[\"Rust 编译器需要知道每个函数的返回类型需要多少空间。这意味着所有函数都必须返回一个具体类型。与其他语言不同，如果你有个像 Animal 那样的的 trait，则不能编写返回 Animal 的函数，因为其不同的实现将需要不同的内存量。\",\"但是，有一个简单的解决方法。相比于直接返回一个 trait 对象，我们的函数返回一个包含一些 Animal 的 Box。box 只是对堆中某些内存的引用。因为引用的大小是静态已知的，并且编译器可以保证引用指向已分配的堆 Animal，所以我们可以从函数中返回 trait！\",\"每当在堆上分配内存时，Rust 都会尝试尽可能明确。因此，如果你的函数以这种方式返回指向堆的 trait 指针，则需要使用 dyn 关键字编写返回类型，例如 Box<dyn Animal>。\",\"struct Sheep {} struct Cow {} trait Animal { // 实例方法签名 fn noise(&self) -> &'static str; } // 实现 `Sheep` 的 `Animal` trait。 impl Animal for Sheep { fn noise(&self) -> &'static str { \\\"baaaaah!\\\" } } // 实现 `Cow` 的 `Animal` trait。 impl Animal for Cow { fn noise(&self) -> &'static str { \\\"moooooo!\\\" } } // 返回一些实现 Animal 的结构体，但是在编译时我们不知道哪个结构体。 fn random_animal(random_number: f64) -> Box<dyn Animal> { if random_number < 0.5 { Box::new(Sheep {}) } else { Box::new(Cow {}) } } fn main() { let random_number = 0.234; let animal = random_animal(random_number); println!(\\\"You've randomly chosen an animal, and it says {}\\\", animal.noise()); }\"]},\"185\":{\"h\":\"impl Trait\",\"t\":[\"如果函数返回实现了 MyTrait 的类型，可以将其返回类型编写为 -> impl MyTrait。这可以大大简化你的类型签名！\",\"use std::iter; use std::vec::IntoIter; // 该函数组合了两个 `Vec <i32>` 并在其上返回一个迭代器。 // 看看它的返回类型多么复杂！ fn combine_vecs_explicit_return_type( v: Vec<i32>, u: Vec<i32>, ) -> iter::Cycle<iter::Chain<IntoIter<i32>, IntoIter<i32>>> { v.into_iter().chain(u.into_iter()).cycle() } // 这是完全相同的函数，但其返回类型使用 `impl Trait`。 // 看看它多么简单！ fn combine_vecs( v: Vec<i32>, u: Vec<i32>, ) -> impl Iterator<Item=i32> { v.into_iter().chain(u.into_iter()).cycle() } fn main() { let v1 = vec![1, 2, 3]; let v2 = vec![4, 5]; let mut v3 = combine_vecs(v1, v2); assert_eq!(Some(1), v3.next()); assert_eq!(Some(2), v3.next()); assert_eq!(Some(3), v3.next()); assert_eq!(Some(4), v3.next()); assert_eq!(Some(5), v3.next()); println!(\\\"all done\\\"); }\",\"更重要的是，某些 Rust 类型无法写出。例如，每个闭包都有自己未命名的具体类型。在使用 impl Trait 语法之前，必须在堆上进行分配才能返回闭包。但是现在你可以像下面这样静态地完成所有操作：\",\"// 返回一个将输入和 `y` 相加的函数 fn make_adder_function(y: i32) -> impl Fn(i32) -> i32 { let closure = move |x: i32| { x + y }; closure } fn main() { let plus_one = make_adder_function(1); assert_eq!(plus_one(2), 3); }\",\"您还可以使用 impl Trait 返回使用 map 或 filter 闭包的迭代器！这使得使用 map 和 filter 更容易。因为闭包类型没有名称，所以如果函数返回带闭包的迭代器，则无法写出显式的返回类型。但是有了 impl Trait，你就可以轻松地做到这一点：\",\"fn double_positives<'a>(numbers: &'a Vec<i32>) -> impl Iterator<Item = i32> + 'a { numbers .iter() .filter(|x| x > &&0) .map(|x| x * 2) }\"]},\"186\":{\"h\":\"Iterator\",\"t\":[\"Iterator trait 用来对集合（collection）类型（比如数组）实现迭代器。\",\"这个 trait 只需定义一个返回 next（下一个）元素的方法，这可手动在 impl 代码块中定义，或者自动定义（比如在数组或区间中）。\",\"为方便起见，for 结构会使用 .into_iter() 方法将一些集合类型转换为迭代器。\",\"下面例子展示了如何使用 Iterator trait 的方法，更多可用的方法可以看这里。\",\"struct Fibonacci { curr: u32, next: u32, } // 为 `Fibonacci`（斐波那契）实现 `Iterator`。 // `Iterator` trait 只需定义一个能返回 `next`（下一个）元素的方法。 impl Iterator for Fibonacci { type Item = u32; // 我们在这里使用 `.curr` 和 `.next` 来定义数列（sequence）。 // 返回类型为 `Option<T>`： // * 当 `Iterator` 结束时，返回 `None`。 // * 其他情况，返回被 `Some` 包裹（wrap）的下一个值。 fn next(&mut self) -> Option<u32> { let new_next = self.curr + self.next; self.curr = self.next; self.next = new_next; // 既然斐波那契数列不存在终点，那么 `Iterator` 将不可能 // 返回 `None`，而总是返回 `Some`。 Some(self.curr) } } // 返回一个斐波那契数列生成器 fn fibonacci() -> Fibonacci { Fibonacci { curr: 1, next: 1 } } fn main() { // `0..3` 是一个 `Iterator`，会产生：0、1 和 2。 let mut sequence = 0..3; println!(\\\"Four consecutive `next` calls on 0..3\\\"); println!(\\\"> {:?}\\\", sequence.next()); println!(\\\"> {:?}\\\", sequence.next()); println!(\\\"> {:?}\\\", sequence.next()); println!(\\\"> {:?}\\\", sequence.next()); // `for` 遍历 `Iterator` 直到返回 `None`， // 并且每个 `Some` 值都被解包（unwrap），然后绑定给一个变量（这里是 `i`）。 println!(\\\"Iterate through 0..3 using `for`\\\"); for i in 0..3 { println!(\\\"> {}\\\", i); } // `take(n)` 方法提取 `Iterator` 的前 `n` 项。 println!(\\\"The first four terms of the Fibonacci sequence are: \\\"); for i in fibonacci().take(4) { println!(\\\"> {}\\\", i); } // `skip(n)` 方法移除前 `n` 项，从而缩短了 `Iterator` 。 println!(\\\"The next four terms of the Fibonacci sequence are: \\\"); for i in fibonacci().skip(4).take(4) { println!(\\\"> {}\\\", i); } let array = [1u32, 3, 3, 7]; // `iter` 方法对数组/slice 产生一个 `Iterator`。 println!(\\\"Iterate the following array {:?}\\\", &array); for i in array.iter() { println!(\\\"> {}\\\", i); } }\"]},\"187\":{\"h\":\"运算符重载\",\"t\":[\"在 Rust 中，很多运算符可以通过 trait 来重载。也就是说，这些运算符可以根据它们的输入参数来完成不同的任务。这之所以可行，是因为运算符就是方法调用的语法糖。例如，a + b 中的 + 运算符会调用 add 方法（也就是 a.add(b)）。这个 add 方法是 Add trait 的一部分。因此，+ 运算符可以被任何 Add trait 的实现者使用。\",\"会重载运算符的 trait（比如 Add 这种）可以在这里查看。\",\"use std::ops; struct Foo; struct Bar; #[derive(Debug)] struct FooBar; #[derive(Debug)] struct BarFoo; // `std::ops::Add` trait 用来指明 `+` 的功能，这里我们实现 `Add<Bar>`，它是用于 // 把对象和 `Bar` 类型的右操作数（RHS）加起来的 `trait`。 // 下面的代码块实现了 `Foo + Bar = FooBar` 这样的运算。 impl ops::Add<Bar> for Foo { type Output = FooBar; fn add(self, _rhs: Bar) -> FooBar { println!(\\\"> Foo.add(Bar) was called\\\"); FooBar } } // 通过颠倒类型，我们实现了不服从交换律的加法。 // 这里我们实现 `Add<Foo>`，它是用于把对象和 `Foo` 类型的右操作数加起来的 trait。 // 下面的代码块实现了 `Bar + Foo = BarFoo` 这样的运算。 impl ops::Add<Foo> for Bar { type Output = BarFoo; fn add(self, _rhs: Foo) -> BarFoo { println!(\\\"> Bar.add(Foo) was called\\\"); BarFoo } } fn main() { println!(\\\"Foo + Bar = {:?}\\\", Foo + Bar); println!(\\\"Bar + Foo = {:?}\\\", Bar + Foo); }\"]},\"188\":{\"h\":\"参见：\",\"t\":[\"Add, 语法索引\"]},\"189\":{\"h\":\"父 trait\",\"t\":[\"Rust 没有“继承”，但是您可以将一个 trait 定义为另一个 trait 的超集（即父 trait）。例如：\",\"trait Person { fn name(&self) -> String; } // Person 是 Student 的父 trait。 // 实现 Student 需要你也 impl 了 Person。 trait Student: Person { fn university(&self) -> String; } trait Programmer { fn fav_language(&self) -> String; } // CompSciStudent (computer science student，计算机科学的学生) 是 Programmer 和 Student 两者的子类。 // 实现 CompSciStudent 需要你同时 impl 了两个父 trait。 trait CompSciStudent: Programmer + Student { fn git_username(&self) -> String; } fn comp_sci_student_greeting(student: &dyn CompSciStudent) -> String { format!( \\\"My name is {} and I attend {}. My favorite language is {}. My Git username is {}\\\", student.name(), student.university(), student.fav_language(), student.git_username() ) } fn main() {}\"]},\"190\":{\"h\":\"参见：\",\"t\":[\"《Rust 程序设计语言》的“父级 trait”章节\"]},\"191\":{\"h\":\"别名\",\"t\":[\"可以用 type 语句给已有的类型取个新的名字。类型的名字必须遵循驼峰命名法（像是CamelCase 这样），否则编译器将给出警告。原生类型是例外，比如：usize、f32，等等。\",\"// `NanoSecond` 是 `u64` 的新名字。 type NanoSecond = u64; type Inch = u64; // 通过这个属性屏蔽警告。 #[allow(non_camel_case_types)] type u64_t = u64; // 试一试 ^ 移除上面那个属性 fn main() { // `NanoSecond` = `Inch` = `u64_t` = `u64`. let nanoseconds: NanoSecond = 5 as u64_t; let inches: Inch = 2 as u64_t; // 注意类型别名*并不能*提供额外的类型安全，因为别名*并不是*新的类型。 println!(\\\"{} nanoseconds + {} inches = {} unit?\\\", nanoseconds, inches, nanoseconds + inches); }\",\"别名的主要用途是避免写出冗长的模板化代码（boilerplate code）。如 IoResult<T> 是 Result<T, IoError> 类型的别名。\"]},\"192\":{\"h\":\"参见:\",\"t\":[\"属性\"]},\"193\":{\"h\":\"类型转换\",\"t\":[\"Rust 不提供原生类型之间的隐式类型转换（coercion），但可以使用 as 关键字进行显式类型转换（casting）。\",\"整型之间的转换大体遵循 C 语言的惯例，除了 C 会产生未定义行为的情形。在 Rust 中所有整型转换都是定义良好的。\",\"// 不显示类型转换产生的溢出警告。 #![allow(overflowing_literals)] fn main() { let decimal = 65.4321_f32; // 错误！不提供隐式转换 let integer: u8 = decimal; // 改正 ^ 注释掉这一行 // 可以显式转换 let integer = decimal as u8; let character = integer as char; println!(\\\"Casting: {} -> {} -> {}\\\", decimal, integer, character); // 当把任何类型转换为无符号类型 T 时，会不断加上或减去 (std::T::MAX + 1) // 直到值位于新类型 T 的范围内。 // 1000 已经在 u16 的范围内 println!(\\\"1000 as a u16 is: {}\\\", 1000 as u16); // 1000 - 256 - 256 - 256 = 232 // 事实上的处理方式是：从最低有效位（LSB，least significant bits）开始保留 // 8 位，然后剩余位置，直到最高有效位（MSB，most significant bit）都被抛弃。 // 译注：MSB 就是二进制的最高位，LSB 就是二进制的最低位，按日常书写习惯就是 // 最左边一位和最右边一位。 println!(\\\"1000 as a u8 is : {}\\\", 1000 as u8); // -1 + 256 = 255 println!(\\\" -1 as a u8 is : {}\\\", (-1i8) as u8); // 对正数，这就和取模一样。 println!(\\\"1000 mod 256 is : {}\\\", 1000 % 256); // 当转换到有符号类型时，（位操作的）结果就和 “先转换到对应的无符号类型， // 如果 MSB 是 1，则该值为负” 是一样的。 // 当然如果数值已经在目标类型的范围内，就直接把它放进去。 println!(\\\" 128 as a i16 is: {}\\\", 128 as i16); // 128 转成 u8 还是 128，但转到 i8 相当于给 128 取八位的二进制补码，其值是： println!(\\\" 128 as a i8 is : {}\\\", 128 as i8); // 重复之前的例子 // 1000 as u8 -> 232 println!(\\\"1000 as a u8 is : {}\\\", 1000 as u8); // 232 的二进制补码是 -24 println!(\\\" 232 as a i8 is : {}\\\", 232 as i8); }\"]},\"194\":{\"h\":\"类型推断\",\"t\":[\"Rust 的类型推断引擎是很聪明的，它不只是在初始化时看看右值（r-value）的类型而已，它还会考察变量之后会怎样使用，借此推断类型。这是一个类型推导的进阶例子：\",\"fn main() { // 因为有类型说明，编译器知道 `elem` 的类型是 u8。 let elem = 5u8; // 创建一个空向量（vector，即不定长的，可以增长的数组）。 let mut vec = Vec::new(); // 现在编译器还不知道 `vec` 的具体类型，只知道它是某种东西构成的向量（`Vec<_>`） // 在向量中插入 `elem`。 vec.push(elem); // 啊哈！现在编译器知道 `vec` 是 u8 的向量了（`Vec<u8>`）。 // 试一试 ^ 注释掉 `vec.push(elem)` 这一行。 println!(\\\"{:?}\\\", vec); }\",\"没有必要写类型说明，编译器和程序员皆大欢喜！\"]},\"195\":{\"h\":\"字面量\",\"t\":[\"对数值字面量，只要把类型作为后缀加上去，就完成了类型说明。比如指定字面量 42 的类型是 i32，只需要写 42i32。\",\"无后缀的数值字面量，其类型取决于怎样使用它们。如果没有限制，编译器会对整数使用 i32，对浮点数使用 f64。\",\"fn main() { // 带后缀的字面量，其类型在初始化时已经知道了。 let x = 1u8; let y = 2u32; let z = 3f32; // 无后缀的字面量，其类型取决于如何使用它们。 let i = 1; let f = 1.0; // `size_of_val` 返回一个变量所占的字节数 println!(\\\"size of `x` in bytes: {}\\\", std::mem::size_of_val(&x)); println!(\\\"size of `y` in bytes: {}\\\", std::mem::size_of_val(&y)); println!(\\\"size of `z` in bytes: {}\\\", std::mem::size_of_val(&z)); println!(\\\"size of `i` in bytes: {}\\\", std::mem::size_of_val(&i)); println!(\\\"size of `f` in bytes: {}\\\", std::mem::size_of_val(&f)); }\",\"上面的代码使用了一些还没有讨论过的概念。心急的读者可以看看下面的简短解释：\",\"fun(&foo) 用传引用（pass by reference）的方式把变量传给函数，而非传值（pass by value，写法是 fun(foo)）。更多细节请看借用。\",\"std::mem::size_of_val 是一个函数，这里使用其完整路径（full path）调用。代码可以分成一些叫做模块（module）的逻辑单元。在本例中，size_of_val 函数是在 mem 模块中定义的，而 mem 模块又是在 stdcrate 中定义的。更多细节请看模块和crate.\"]},\"196\":{\"h\":\"变量先声明\",\"t\":[\"可以先声明（declare）变量绑定，后面才将它们初始化（initialize）。但是这种做法很少用，因为这样可能导致使用未初始化的变量。\",\"fn main() { // 声明一个变量绑定 let a_binding; { let x = 2; // 初始化一个绑定 a_binding = x * x; } println!(\\\"a binding: {}\\\", a_binding); let another_binding; // 报错！使用了未初始化的绑定 println!(\\\"another binding: {}\\\", another_binding); // 改正 ^ 注释掉此行 another_binding = 1; println!(\\\"another binding: {}\\\", another_binding); }\",\"编译器禁止使用未经初始化的变量，因为这会产生未定义行为（undefined behavior）。\"]},\"197\":{\"h\":\"冻结\",\"t\":[\"当数据被相同的名称不变地绑定时，它还会冻结（freeze）。在不可变绑定超出作用域之前，无法修改已冻结的数据：\",\"fn main() { let mut _mutable_integer = 7i32; { // 被不可变的 `_mutable_integer` 遮蔽 let _mutable_integer = _mutable_integer; // 报错！`_mutable_integer` 在本作用域被冻结 _mutable_integer = 50; // 改正 ^ 注释掉上面这行 // `_mutable_integer` 离开作用域 } // 正常运行！ `_mutable_integer` 在这个作用域没有冻结 _mutable_integer = 3; }\"]},\"198\":{\"h\":\"可变变量\",\"t\":[\"变量绑定默认是不可变的（immutable），但加上 mut 修饰语后变量就可以改变。\",\"fn main() { let _immutable_binding = 1; let mut mutable_binding = 1; println!(\\\"Before mutation: {}\\\", mutable_binding); // 正确代码 mutable_binding += 1; println!(\\\"After mutation: {}\\\", mutable_binding); // 错误！ _immutable_binding += 1; // 改正 ^ 将此行注释掉 }\",\"编译器会给出关于变量可变性的详细诊断信息。\"]},\"199\":{\"h\":\"作用域和遮蔽\",\"t\":[\"变量绑定有一个作用域（scope），它被限定只在一个代码块（block）中生存（live）。 代码块是一个被 {} 包围的语句集合。另外也允许变量遮蔽（variable shadowing）。\",\"fn main() { // 此绑定生存于 main 函数中 let long_lived_binding = 1; // 这是一个代码块，比 main 函数拥有更小的作用域 { // 此绑定只存在于本代码块 let short_lived_binding = 2; println!(\\\"inner short: {}\\\", short_lived_binding); // 此绑定*遮蔽*了外面的绑定 let long_lived_binding = 5_f32; println!(\\\"inner long: {}\\\", long_lived_binding); } // 代码块结束 // 报错！`short_lived_binding` 在此作用域上不存在 println!(\\\"outer short: {}\\\", short_lived_binding); // 改正 ^ 注释掉这行 println!(\\\"outer long: {}\\\", long_lived_binding); // 此绑定同样*遮蔽*了前面的绑定 let long_lived_binding = 'a'; println!(\\\"outer long: {}\\\", long_lived_binding); }\"]},\"200\":{\"h\":\"自定义条件\",\"t\":[\"有部分条件如 target_os 是由 rustc 隐式地提供的，但是自定义条件必须使用--cfg 标记来传给 rustc。\",\"#[cfg(some_condition)] fn conditional_function() { println!(\\\"condition met!\\\") } fn main() { conditional_function(); }\",\"试试不使用自定义的 cfg 标记会发生什么：\",\"$ rustc custom.rs && ./custom No such file or directory (os error 2)\",\"使用自定义的 cfg 标记：\",\"$ rustc --cfg some_condition custom.rs && ./custom condition met!\"]},\"201\":{\"h\":\"C 风格用法\",\"t\":[\"enum 也可以像 C 语言风格的枚举类型那样使用。\",\"// 该属性用于隐藏对未使用代码的警告。 #![allow(dead_code)] // 拥有隐式辨别值（implicit discriminator，从 0 开始）的 enum enum Number { Zero, One, Two, } // 拥有显式辨别值（explicit discriminator）的 enum enum Color { Red = 0xff0000, Green = 0x00ff00, Blue = 0x0000ff, } fn main() { // `enum` 可以转成整型。 println!(\\\"zero is {}\\\", Number::Zero as i32); println!(\\\"one is {}\\\", Number::One as i32); println!(\\\"roses are #{:06x}\\\", Color::Red as i32); println!(\\\"violets are #{:06x}\\\", Color::Blue as i32); }\"]},\"202\":{\"h\":\"参考：\",\"t\":[\"类型转换\"]},\"203\":{\"h\":\"使用 use\",\"t\":[\"使用 use 声明的话，就可以不写出名称的完整路径了：\",\"// 该属性用于隐藏对未使用代码的警告。 #![allow(dead_code)] enum Status { Rich, Poor, } enum Work { Civilian, Soldier, } fn main() { // 显式地 `use` 各个名称使他们直接可用，而不需要指定它们来自 `Status`。 use Status::{Poor, Rich}; // 自动地 `use` `Work` 内部的各个名称。 use Work::*; // `Poor` 等价于 `Status::Poor`。 let status = Poor; // `Civilian` 等价于 `Work::Civilian`。 let work = Civilian; match status { // 注意这里没有用完整路径，因为上面显式地使用了 `use`。 Rich => println!(\\\"The rich have lots of money!\\\"), Poor => println!(\\\"The poor have no money...\\\"), } match work { // 再次注意到没有用完整路径。 Civilian => println!(\\\"Civilians work!\\\"), Soldier => println!(\\\"Soldiers fight!\\\"), } }\"]},\"204\":{\"h\":\"参见：\",\"t\":[\"match 和 use\"]},\"205\":{\"h\":\"测试实例：链表\",\"t\":[\"enum 的一个常见用法就是创建链表（linked-list）：\",\"use List::*; enum List { // Cons：元组结构体，包含链表的一个元素和一个指向下一节点的指针 Cons(u32, Box<List>), // Nil：末结点，表明链表结束 Nil, } // 可以为 enum 定义方法 impl List { // 创建一个空的 List 实例 fn new() -> List { // `Nil` 为 `List` 类型（译注：因 `Nil` 的完整名称是 `List::Nil`） Nil } // 处理一个 List，在其头部插入新元素，并返回该 List fn prepend(self, elem: u32) -> List { // `Cons` 同样为 List 类型 Cons(elem, Box::new(self)) } // 返回 List 的长度 fn len(&self) -> u32 { // 必须对 `self` 进行匹配（match），因为这个方法的行为取决于 `self` 的 // 取值种类。 // `self` 为 `&List` 类型，`*self` 为 `List` 类型，匹配一个具体的 `T` // 类型要好过匹配引用 `&T`。 match *self { // 不能得到 tail 的所有权，因为 `self` 是借用的； // 因此使用一个对 tail 的引用 Cons(_, ref tail) => 1 + tail.len(), // （递归的）基准情形（base case）：一个长度为 0 的空列表 Nil => 0 } } // 返回列表的字符串表示（该字符串是堆分配的） fn stringify(&self) -> String { match *self { Cons(head, ref tail) => { // `format!` 和 `print!` 类似，但返回的是一个堆分配的字符串， // 而不是打印结果到控制台上 format!(\\\"{}, {}\\\", head, tail.stringify()) }, Nil => { format!(\\\"Nil\\\") }, } } } fn main() { // 创建一个空链表 let mut list = List::new(); // 追加一些元素 list = list.prepend(1); list = list.prepend(2); list = list.prepend(3); // 显示链表的最后状态 println!(\\\"linked list has length: {}\\\", list.len()); println!(\\\"{}\\\", list.stringify()); }\"]},\"206\":{\"h\":\"参见：\",\"t\":[\"Box 和 方法\"]},\"207\":{\"h\":\"把错误 “装箱”\",\"t\":[\"如果又想写简单的代码，又想保存原始错误信息，一个方法是把它们装箱（Box）。这样做的坏处就是，被包装的错误类型只能在运行时了解，而不能被静态地判别。\",\"对任何实现了 Error trait 的类型，标准库的 Box 通过 From 为它们提供了到 Box<Error> 的转换。\",\"use std::error; use std::fmt; // 为 `Box<error::Error>` 取别名。 type Result<T> = std::result::Result<T, Box<dyn error::Error>>; #[derive(Debug, Clone)] struct EmptyVec; impl fmt::Display for EmptyVec { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { write!(f, \\\"invalid first item to double\\\") } } impl error::Error for EmptyVec { fn description(&self) -> &str { \\\"invalid first item to double\\\" } fn cause(&self) -> Option<&dyn error::Error> { // 泛型错误。没有记录其内部原因。 None } } fn double_first(vec: Vec<&str>) -> Result<i32> { vec.first() .ok_or_else(|| EmptyVec.into()) // 装箱 .and_then(|s| { s.parse::<i32>() .map_err(|e| e.into()) // 装箱 .map(|i| 2 * i) }) } fn print(result: Result<i32>) { match result { Ok(n) => println!(\\\"The first doubled is {}\\\", n), Err(e) => println!(\\\"Error: {}\\\", e), } } fn main() { let numbers = vec![\\\"42\\\", \\\"93\\\", \\\"18\\\"]; let empty = vec![]; let strings = vec![\\\"tofu\\\", \\\"93\\\", \\\"18\\\"]; print(double_first(numbers)); print(double_first(empty)); print(double_first(strings)); }\"]},\"208\":{\"h\":\"参见：\",\"t\":[\"动态分发 and Error trait\"]},\"209\":{\"h\":\"定义一个错误类型\",\"t\":[\"有时候把所有不同的错误都视为一种错误类型会简化代码。我们将用一个自定义错误类型来演示这一点。\",\"Rust 允许我们定义自己的错误类型。一般来说，一个 “好的” 错误类型应当：\",\"用同一个类型代表了多种错误\",\"向用户提供了清楚的错误信息\",\"能够容易地与其他类型比较 \",\"好的例子：Err(EmptyVec)\",\"坏的例子：Err(\\\"Please use a vector with at least one element\\\".to_owned())\",\"能够容纳错误的具体信息 \",\"好的例子：Err(BadChar(c, position))\",\"坏的例子：Err(\\\"+ cannot be used here\\\".to_owned())\",\"能够与其他错误很好地整合\",\"use std::error; use std::fmt; type Result<T> = std::result::Result<T, DoubleError>; #[derive(Debug, Clone)] // 定义我们的错误类型，这种类型可以根据错误处理的实际情况定制。 // 我们可以完全自定义错误类型，也可以在类型中完全采用底层的错误实现， // 也可以介于二者之间。 struct DoubleError; // 错误的生成与它如何显示是完全没关系的。没有必要担心复杂的逻辑会导致混乱的显示。 // // 注意我们没有储存关于错误的任何额外信息，也就是说，如果不修改我们的错误类型定义的话， // 就无法指明是哪个字符串解析失败了。 impl fmt::Display for DoubleError { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { write!(f, \\\"invalid first item to double\\\") } } // 为 `DoubleError` 实现 `Error` trait，这样其他错误可以包裹这个错误类型。 impl error::Error for DoubleError { fn source(&self) -> Option<&(dyn error::Error + 'static)> { // 泛型错误，没有记录其内部原因。 None } } fn double_first(vec: Vec<&str>) -> Result<i32> { vec.first() // 把错误换成我们的新类型。 .ok_or(DoubleError) .and_then(|s| { s.parse::<i32>() // 这里也换成新类型。 .map_err(|_| DoubleError) .map(|i| 2 * i) }) } fn print(result: Result<i32>) { match result { Ok(n) => println!(\\\"The first doubled is {}\\\", n), Err(e) => println!(\\\"Error: {}\\\", e), } } fn main() { let numbers = vec![\\\"42\\\", \\\"93\\\", \\\"18\\\"]; let empty = vec![]; let strings = vec![\\\"tofu\\\", \\\"93\\\", \\\"18\\\"]; print(double_first(numbers)); print(double_first(empty)); print(double_first(strings)); }\"]},\"210\":{\"h\":\"从 Option 中取出 Result\",\"t\":[\"处理混合错误类型的最基本的手段就是让它们互相包含。\",\"use std::num::ParseIntError; fn double_first(vec: Vec<&str>) -> Option<Result<i32, ParseIntError>> { vec.first().map(|first| { first.parse::<i32>().map(|n| 2 * n) }) } fn main() { let numbers = vec![\\\"42\\\", \\\"93\\\", \\\"18\\\"]; let empty = vec![]; let strings = vec![\\\"tofu\\\", \\\"93\\\", \\\"18\\\"]; println!(\\\"The first doubled is {:?}\\\", double_first(numbers)); println!(\\\"The first doubled is {:?}\\\", double_first(empty)); // Error 1: the input vector is empty println!(\\\"The first doubled is {:?}\\\", double_first(strings)); // Error 2: the element doesn't parse to a number }\",\"有时候我们不想再处理错误（比如使用 ? 的时候），但如果Option 是 None 则继续处理错误。一些组合算子可以让我们轻松地交换 Result 和Option。\",\"use std::num::ParseIntError; fn double_first(vec: Vec<&str>) -> Result<Option<i32>, ParseIntError> { let opt = vec.first().map(|first| { first.parse::<i32>().map(|n| 2 * n) }); opt.map_or(Ok(None), |r| r.map(Some)) } fn main() { let numbers = vec![\\\"42\\\", \\\"93\\\", \\\"18\\\"]; let empty = vec![]; let strings = vec![\\\"tofu\\\", \\\"93\\\", \\\"18\\\"]; println!(\\\"The first doubled is {:?}\\\", double_first(numbers)); println!(\\\"The first doubled is {:?}\\\", double_first(empty)); println!(\\\"The first doubled is {:?}\\\", double_first(strings)); }\"]},\"211\":{\"h\":\"? 的其他用法\",\"t\":[\"注意在上一个例子中，我们调用 parse 后总是立即将错误从标准库的错误 map（映射）到装箱错误。\",\".and_then(|s| s.parse::<i32>() .map_err(|e| e.into())\",\"因为这个操作很简单常见，如果有省略写法就好了。遗憾的是 and_then 不够灵活，所以实现不了这样的写法。不过，我们可以使用 ? 来代替它。\",\"? 之前被解释为要么 unwrap，要么 return Err(err)，这只是在大多数情况下是正确的。? 实际上是指 unwrap 或 return Err(From::from(err))。由于 From::from 是不同类型之间的转换工具，也就是说，如果在错误可转换成返回类型地方使用 ?，它将自动转换成返回类型。\",\"我们在这里使用 ? 重写之前的例子。重写后，只要为我们的错误类型实现 From::from，就可以不再使用 map_err。\",\"use std::error; use std::fmt; // 为 `Box<error::Error>` 取别名。 type Result<T> = std::result::Result<T, Box<dyn error::Error>>; #[derive(Debug)] struct EmptyVec; impl fmt::Display for EmptyVec { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { write!(f, \\\"invalid first item to double\\\") } } impl error::Error for EmptyVec {} // 这里的结构和之前一样，但是这次没有把所有的 `Result` 和 `Option` 串起来， // 而是使用 `?` 立即得到内部值。 fn double_first(vec: Vec<&str>) -> Result<i32> { let first = vec.first().ok_or(EmptyVec)?; let parsed = first.parse::<i32>()?; Ok(2 * parsed) } fn print(result: Result<i32>) { match result { Ok(n) => println!(\\\"The first doubled is {}\\\", n), Err(e) => println!(\\\"Error: {}\\\", e), } } fn main() { let numbers = vec![\\\"42\\\", \\\"93\\\", \\\"18\\\"]; let empty = vec![]; let strings = vec![\\\"tofu\\\", \\\"93\\\", \\\"18\\\"]; print(double_first(numbers)); print(double_first(empty)); print(double_first(strings)); }\",\"这段代码已经相当清晰了。与原来的 panic 相比，除了返回类型是 Result 之外，它就像是把所有的 unwrap 调用都换成 ? 一样。因此必须在顶层解构它们。\"]},\"212\":{\"h\":\"参见：\",\"t\":[\"From::from 和 ?\"]},\"213\":{\"h\":\"包裹错误\",\"t\":[\"把错误装箱这种做法也可以改成把它包裹到你自己的错误类型中。\",\"use std::error; use std::num::ParseIntError; use std::fmt; type Result<T> = std::result::Result<T, DoubleError>; #[derive(Debug)] enum DoubleError { EmptyVec, // 在这个错误类型中，我们采用 `parse` 的错误类型中 `Err` 部分的实现。 // 若想提供更多信息，则该类型中还需要加入更多数据。 Parse(ParseIntError), } impl fmt::Display for DoubleError { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { match *self { DoubleError::EmptyVec => write!(f, \\\"please use a vector with at least one element\\\"), // 这是一个封装（wrapper），它采用内部各类型对 `fmt` 的实现。 DoubleError::Parse(ref e) => e.fmt(f), } } } impl error::Error for DoubleError { fn source(&self) -> Option<&(dyn error::Error + 'static)> { match *self { DoubleError::EmptyVec => None, // 原因采取内部对错误类型的实现。它隐式地转换成了 trait 对象 `&error:Error`。 // 这可以工作，因为内部的类型已经实现了 `Error` trait。 DoubleError::Parse(ref e) => Some(e), } } } // 实现从 `ParseIntError` 到 `DoubleError` 的转换。 // 在使用 `?` 时，或者一个 `ParseIntError` 需要转换成 `DoubleError` 时，它会被自动调用。 impl From<ParseIntError> for DoubleError { fn from(err: ParseIntError) -> DoubleError { DoubleError::Parse(err) } } fn double_first(vec: Vec<&str>) -> Result<i32> { let first = vec.first().ok_or(DoubleError::EmptyVec)?; let parsed = first.parse::<i32>()?; Ok(2 * parsed) } fn print(result: Result<i32>) { match result { Ok(n) => println!(\\\"The first doubled is {}\\\", n), Err(e) => println!(\\\"Error: {}\\\", e), } } fn main() { let numbers = vec![\\\"42\\\", \\\"93\\\", \\\"18\\\"]; let empty = vec![]; let strings = vec![\\\"tofu\\\", \\\"93\\\", \\\"18\\\"]; print(double_first(numbers)); print(double_first(empty)); print(double_first(strings)); }\",\"这种做法会在错误处理中增加一些模板化的代码，而且也不是所有的应用都需要这样做。一些库可以帮你处理模板化代码的问题。\"]},\"214\":{\"h\":\"See also:\",\"t\":[\"From::from and 枚举类型\"]},\"215\":{\"h\":\"组合算子：and_then\",\"t\":[\"map() 以链式调用的方式来简化 match 语句。然而，如果以返回类型是 Option<T> 的函数作为 map() 的参数，会导致出现嵌套形式 Option<Option<T>>。这样多层串联调用就会变得混乱。所以有必要引入 and_then()，在某些语言中它叫做 flatmap。\",\"and_then() 使用被 Option 包裹的值来调用其输入函数并返回结果。 如果 Option 是 None，那么它返回 None。\",\"在下面例子中，cookable_v2() 会产生一个 Option<Food>。如果在这里使用 map() 而不是 and_then() 将会得到 Option<Option<Food>>，这对 eat() 来说是一个无效类型。\",\"#![allow(dead_code)] #[derive(Debug)] enum Food { CordonBleu, Steak, Sushi } #[derive(Debug)] enum Day { Monday, Tuesday, Wednesday } // 我们没有制作寿司所需的原材料（ingredient）（有其他的原材料）。 fn have_ingredients(food: Food) -> Option<Food> { match food { Food::Sushi => None, _ => Some(food), } } // 我们拥有全部食物的食谱，除了法国蓝带猪排（Cordon Bleu）的。 fn have_recipe(food: Food) -> Option<Food> { match food { Food::CordonBleu => None, _ => Some(food), } } // 要做一份好菜，我们需要原材料和食谱。 // 我们可以借助一系列 `match` 来表达这个逻辑： fn cookable_v1(food: Food) -> Option<Food> { match have_ingredients(food) { None => None, Some(food) => match have_recipe(food) { None => None, Some(food) => Some(food), }, } } // 也可以使用 `and_then()` 把上面的逻辑改写得更紧凑： fn cookable_v2(food: Food) -> Option<Food> { have_ingredients(food).and_then(have_recipe) } fn eat(food: Food, day: Day) { match cookable_v2(food) { Some(food) => println!(\\\"Yay! On {:?} we get to eat {:?}.\\\", day, food), None => println!(\\\"Oh no. We don't get to eat on {:?}?\\\", day), } } fn main() { let (cordon_bleu, steak, sushi) = (Food::CordonBleu, Food::Steak, Food::Sushi); eat(cordon_bleu, Day::Monday); eat(steak, Day::Tuesday); eat(sushi, Day::Wednesday); }\"]},\"216\":{\"h\":\"参见：\",\"t\":[\"闭包，Option::map(), 和 Option::and_then()\"]},\"217\":{\"h\":\"组合算子：map\",\"t\":[\"match 是处理 Option 的一个可用的方法，但你会发现大量使用它会很繁琐，特别是当操作只对一种输入是有效的时。这时，可以使用组合算子（combinator），以模块化的风格来管理控制流。\",\"Option 有一个内置方法 map()，这个组合算子可用于 Some -> Some 和None -> None 这样的简单映射。多个不同的 map() 调用可以串起来，这样更加灵活。\",\"在下面例子中，process() 轻松取代了前面的所有函数，且更加紧凑。\",\"#![allow(dead_code)] #[derive(Debug)] enum Food { Apple, Carrot, Potato } #[derive(Debug)] struct Peeled(Food); #[derive(Debug)] struct Chopped(Food); #[derive(Debug)] struct Cooked(Food); // 削皮。如果没有食物，就返回 `None`。否则返回削好皮的食物。 fn peel(food: Option<Food>) -> Option<Peeled> { match food { Some(food) => Some(Peeled(food)), None => None, } } // 切食物。如果没有食物，就返回 `None`。否则返回切好的食物。 fn chop(peeled: Option<Peeled>) -> Option<Chopped> { match peeled { Some(Peeled(food)) => Some(Chopped(food)), None => None, } } // 烹饪食物。这里，我们使用 `map()` 来替代 `match` 以处理各种情况。 fn cook(chopped: Option<Chopped>) -> Option<Cooked> { chopped.map(|Chopped(food)| Cooked(food)) } // 这个函数会完成削皮切块烹饪一条龙。我们把 `map()` 串起来，以简化代码。 fn process(food: Option<Food>) -> Option<Cooked> { food.map(|f| Peeled(f)) .map(|Peeled(f)| Chopped(f)) .map(|Chopped(f)| Cooked(f)) } // 在尝试吃食物之前确认食物是否存在是非常重要的！ fn eat(food: Option<Cooked>) { match food { Some(food) => println!(\\\"Mmm. I love {:?}\\\", food), None => println!(\\\"Oh no! It wasn't edible.\\\"), } } fn main() { let apple = Some(Food::Apple); let carrot = Some(Food::Carrot); let potato = None; let cooked_apple = cook(chop(peel(apple))); let cooked_carrot = cook(chop(peel(carrot))); // 现在让我们试试看起来更简单的 `process()`。 let cooked_potato = process(potato); eat(cooked_apple); eat(cooked_carrot); eat(cooked_potato); }\"]},\"218\":{\"h\":\"参见：\",\"t\":[\"闭包, Option, 和 Option::map()\"]},\"219\":{\"h\":\"使用 ? 解开 Option\",\"t\":[\"你可以使用 match 语句来解开 Option，但使用 ? 运算符通常会更容易。如果 x 是 Option，那么若 x 是 Some ，对x?表达式求值将返回底层值，否则无论函数是否正在执行都将终止且返回 None。\",\"fn next_birthday(current_age: Option<u8>) -> Option<String> { // 如果 `current_age` 是 `None`，这将返回 `None`。 // 如果 `current_age` 是 `Some`，内部的 `u8` 将赋值给 `next_age`。 let next_age: u8 = current_age?; Some(format!(\\\"Next year I will be {}\\\", next_age)) }\",\"你可以将多个 ? 链接在一起，以使代码更具可读性。\",\"struct Person { job: Option<Job>, } #[derive(Clone, Copy)] struct Job { phone_number: Option<PhoneNumber>, } #[derive(Clone, Copy)] struct PhoneNumber { area_code: Option<u8>, number: u32, } impl Person { // 获取此人的工作电话号码的区号（如果存在的话）。 fn work_phone_area_code(&self) -> Option<u8> { // 没有`？`运算符的话，这将需要很多的嵌套的 `match` 语句。 // 这将需要更多代码——尝试自己编写一下，看看哪个更容易。 self.job?.phone_number?.area_code } } fn main() { let p = Person { job: Some(Job { phone_number: Some(PhoneNumber { area_code: Some(61), number: 439222222, }), }), }; assert_eq!(p.work_phone_area_code(), Some(61)); }\"]},\"220\":{\"h\":\"提前返回\",\"t\":[\"在上一个例子中，我们显式地使用组合算子处理了错误。另一种处理错误的方式是使用match 语句和提前返回（early return）的结合。\",\"这也就是说，如果发生错误，我们可以停止函数的执行然后返回错误。对有些人来说，这样的代码更好写，更易读。这次我们使用提前返回改写之前的例子：\",\"use std::num::ParseIntError; fn multiply(first_number_str: &str, second_number_str: &str) -> Result<i32, ParseIntError> { let first_number = match first_number_str.parse::<i32>() { Ok(first_number) => first_number, Err(e) => return Err(e), }; let second_number = match second_number_str.parse::<i32>() { Ok(second_number) => second_number, Err(e) => return Err(e), }; Ok(first_number * second_number) } fn print(result: Result<i32, ParseIntError>) { match result { Ok(n) => println!(\\\"n is {}\\\", n), Err(e) => println!(\\\"Error: {}\\\", e), } } fn main() { print(multiply(\\\"10\\\", \\\"2\\\")); print(multiply(\\\"t\\\", \\\"2\\\")); }\",\"到此为止，我们已经学会了如何使用组合算子和提前返回显式地处理错误。我们一般是想要避免 panic 的，但显式地处理所有错误确实显得过于繁琐。\",\"在下一部分，我们将看到，当只是需要 unwrap 并且不产生 panic 时，可以使用? 来达到同样的效果。\"]},\"221\":{\"h\":\"引入 ?\",\"t\":[\"有时我们只是想 unwrap 且避免产生 panic。到现在为止，对 unwrap 的错误处理都在强迫我们一层层地嵌套，然而我们只是想把里面的变量拿出来。? 正是为这种情况准备的。\",\"当找到一个 Err 时，可以采取两种行动：\",\"panic!，不过我们已经决定要尽可能避免 panic 了。\",\"返回它，因为 Err 就意味着它已经不能被处理了。\",\"?几乎[^†] 就等于一个会返回 Err 而不是 panic 的 unwrap。我们来看看怎样简化之前使用组合算子的例子：\",\"use std::num::ParseIntError; fn multiply(first_number_str: &str, second_number_str: &str) -> Result<i32, ParseIntError> { let first_number = first_number_str.parse::<i32>()?; let second_number = second_number_str.parse::<i32>()?; Ok(first_number * second_number) } fn print(result: Result<i32, ParseIntError>) { match result { Ok(n) => println!(\\\"n is {}\\\", n), Err(e) => println!(\\\"Error: {}\\\", e), } } fn main() { print(multiply(\\\"10\\\", \\\"2\\\")); print(multiply(\\\"t\\\", \\\"2\\\")); }\"]},\"222\":{\"h\":\"宏\",\"t\":[\"在 ? 出现以前，相同的功能是使用 try! 宏完成的。现在我们推荐使用 ? 运算符，但是在老代码中仍然会看到 try!。如果使用 try! 的话，上一个例子中的 multiply 函数看起来会像是这样：\",\"use std::num::ParseIntError; fn multiply(first_number_str: &str, second_number_str: &str) -> Result<i32, ParseIntError> { let first_number = try!(first_number_str.parse::<i32>()); let second_number = try!(second_number_str.parse::<i32>()); Ok(first_number * second_number) } fn print(result: Result<i32, ParseIntError>) { match result { Ok(n) => println!(\\\"n is {}\\\", n), Err(e) => println!(\\\"Error: {}\\\", e), } } fn main() { print(multiply(\\\"10\\\", \\\"2\\\")); print(multiply(\\\"t\\\", \\\"2\\\")); }\",\"[^†]: 更多细节请看? 的更多用法。\"]},\"223\":{\"h\":\"给 Result 取别名\",\"t\":[\"当我们要重用某个 Result 类型时，该怎么办呢？回忆一下，Rust 允许我们创建别名。若某个 Result 有可能被重用，我们可以方便地给它取一个别名。\",\"在模块的层面上创建别名特别有帮助。同一模块中的错误常常会有相同的 Err 类型，所以单个别名就能简便地定义所有相关的 Result。这太有用了，以至于标准库也提供了一个别名： io::Result！\",\"下面给出一个简短的示例来展示语法：\",\"use std::num::ParseIntError; // 为带有错误类型 `ParseIntError` 的 `Result` 定义一个泛型别名。 type AliasedResult<T> = Result<T, ParseIntError>; // 使用上面定义过的别名来表示上一节中的 `Result<i32,ParseIntError>` 类型。 fn multiply(first_number_str: &str, second_number_str: &str) -> AliasedResult<i32> { first_number_str.parse::<i32>().and_then(|first_number| { second_number_str.parse::<i32>().map(|second_number| first_number * second_number) }) } // 在这里使用别名又让我们节省了一些代码量。 fn print(result: AliasedResult<i32>) { match result { Ok(n) => println!(\\\"n is {}\\\", n), Err(e) => println!(\\\"Error: {}\\\", e), } } fn main() { print(multiply(\\\"10\\\", \\\"2\\\")); print(multiply(\\\"t\\\", \\\"2\\\")); }\"]},\"224\":{\"h\":\"参见：\",\"t\":[\"io::Result\"]},\"225\":{\"h\":\"Result 的 map\",\"t\":[\"上一节的 multiply 函数的 panic 设计不是健壮的（robust）。一般地，我们希望把错误返回给调用者，这样它可以决定回应错误的正确方式。\",\"首先，我们需要了解需要处理的错误类型是什么。为了确定 Err 的类型，我们可以用 parse() 来试验。Rust 已经为 i32 类型使用FromStr trait 实现了 parse()。结果表明，这里的 Err 类型被指定为ParseIntError。\",\"译注：原文没有具体讲如何确定 Err 的类型。由于目前用于获取类型的函数仍然是不 稳定的，我们可以用间接的方法。使用下面的代码：\",\"fn main () { let i: () = \\\"t\\\".parse::<i32>(); }\",\"由于不可能把 Result 类型赋给单元类型变量 i，编译器会提示我们：\",\"note: expected type `()` found type `std::result::Result<i32, std::num::ParseIntError>`\",\"这样就知道了 parse<i32> 函数的返回类型详情。\",\"在下面的例子中，使用简单的 match 语句导致了更加繁琐的代码。\",\"use std::num::ParseIntError; // 修改了上一节中的返回类型，现在使用模式匹配而不是 `unwrap()`。 fn multiply(first_number_str: &str, second_number_str: &str) -> Result<i32, ParseIntError> { match first_number_str.parse::<i32>() { Ok(first_number) => { match second_number_str.parse::<i32>() { Ok(second_number) => { Ok(first_number * second_number) }, Err(e) => Err(e), } }, Err(e) => Err(e), } } fn print(result: Result<i32, ParseIntError>) { match result { Ok(n) => println!(\\\"n is {}\\\", n), Err(e) => println!(\\\"Error: {}\\\", e), } } fn main() { // 这种情形下仍然会给出正确的答案。 let twenty = multiply(\\\"10\\\", \\\"2\\\"); print(twenty); // 这种情况下就会提供一条更有用的错误信息。 let tt = multiply(\\\"t\\\", \\\"2\\\"); print(tt); }\",\"幸运的是，Option 的 map、and_then、以及很多其他组合算子也为 Result 实现了。官方文档的 Result 一节包含完整的方法列表。\",\"use std::num::ParseIntError; // 就像 `Option` 那样，我们可以使用 `map()` 之类的组合算子。 // 除去写法外，这个函数与上面那个完全一致，它的作用是： // 如果值是合法的，计算其乘积，否则返回错误。 fn multiply(first_number_str: &str, second_number_str: &str) -> Result<i32, ParseIntError> { first_number_str.parse::<i32>().and_then(|first_number| { second_number_str.parse::<i32>().map(|second_number| first_number * second_number) }) } fn print(result: Result<i32, ParseIntError>) { match result { Ok(n) => println!(\\\"n is {}\\\", n), Err(e) => println!(\\\"Error: {}\\\", e), } } fn main() { // 这种情况下仍然会给出正确的答案。 let twenty = multiply(\\\"10\\\", \\\"2\\\"); print(twenty); // 这种情况下就会提供一条更有用的错误信息。 let tt = multiply(\\\"t\\\", \\\"2\\\"); print(tt); }\"]},\"226\":{\"h\":\"嵌套循环和标签\",\"t\":[\"在处理嵌套循环的时候可以 break 或 continue 外层循环。在这类情形中，循环必须用一些 'label（标签）来注明，并且标签必须传递给 break/continue 语句。\",\"#![allow(unreachable_code)] fn main() { 'outer: loop { println!(\\\"Entered the outer loop\\\"); 'inner: loop { println!(\\\"Entered the inner loop\\\"); // 这只是中断内部的循环 //break; // 这会中断外层循环 break 'outer; } println!(\\\"This point will never be reached\\\"); } println!(\\\"Exited the outer loop\\\"); }\"]},\"227\":{\"h\":\"从 loop 循环中返回\",\"t\":[\"loop 有个用途是尝试一个操作直到成功为止。若操作返回一个值，则可能需要将其传递给代码的其余部分：将该值放在 break 之后，它就会被 loop 表达式返回。\",\"fn main() { let mut counter = 0; let result = loop { counter += 1; if counter == 10 { break counter * 2; } }; assert_eq!(result, 20); }\"]},\"228\":{\"h\":\"绑定\",\"t\":[\"在 match 中，若间接地访问一个变量，则不经过重新绑定就无法在分支中再使用它。match 提供了 @ 符号来绑定变量到名称：\",\"// `age` 函数，返回一个 `u32` 值。 fn age() -> u32 { 15 } fn main() { println!(\\\"Tell me what type of person you are\\\"); match age() { 0 => println!(\\\"I haven't celebrated my first birthday yet\\\"), // 可以直接匹配（`match`） 1 ..= 12，但那样的话孩子会是几岁？ // 相反，在 1 ..= 12 分支中绑定匹配值到 `n` 。现在年龄就可以读取了。 n @ 1 ..= 12 => println!(\\\"I'm a child of age {:?}\\\", n), n @ 13 ..= 19 => println!(\\\"I'm a teen of age {:?}\\\", n), // 不符合上面的范围。返回结果。 n => println!(\\\"I'm an old person of age {:?}\\\", n), } }\",\"你也可以使用绑定来“解构” enum 变体，例如 Option:\",\"fn some_number() -> Option<u32> { Some(42) } fn main() { match some_number() { // 得到 `Some` 可变类型，如果它的值（绑定到 `n` 上）等于 42，则匹配。 Some(n @ 42) => println!(\\\"The Answer: {}!\\\", n), // 匹配任意其他数字。 Some(n) => println!(\\\"Not interesting... {}\\\", n), // 匹配任意其他值（`None` 可变类型）。 _ => (), } }\"]},\"229\":{\"h\":\"参见：\",\"t\":[\"函数，枚举 和 Option\"]},\"230\":{\"h\":\"解构\",\"t\":[\"match 代码块能以多种方式解构物件。\",\"[解构结构体][struct]\"]},\"231\":{\"h\":\"卫语句\",\"t\":[\"可以加上 match卫语句（guard） 来过滤分支。\",\"fn main() { let pair = (2, -2); // 试一试 ^ 将不同的值赋给 `pair` println!(\\\"Tell me about {:?}\\\", pair); match pair { (x, y) if x == y => println!(\\\"These are twins\\\"), // ^ `if` 条件部分是一个卫语句 (x, y) if x + y == 0 => println!(\\\"Antimatter, kaboom!\\\"), (x, _) if x % 2 == 1 => println!(\\\"The first one is odd\\\"), _ => println!(\\\"No correlation...\\\"), } }\"]},\"232\":{\"h\":\"参见：\",\"t\":[\"元组\"]},\"233\":{\"h\":\"类型匿名\",\"t\":[\"闭包从周围的作用域中捕获变量是简单明了的。这样会有某些后果吗？确实有。观察一下使用闭包作为函数参数，这要求闭包是泛型的，闭包定义的方式决定了这是必要的。\",\"// `F` 必须是泛型的。 fn apply<F>(f: F) where F: FnOnce() { f(); }\",\"当闭包被定义，编译器会隐式地创建一个匿名类型的结构体，用以储存闭包捕获的变量，同时为这个未知类型的结构体实现函数功能，通过 Fn、FnMut 或 FnOnce 三种 trait 中的一种。\",\"若使用闭包作为函数参数，由于这个结构体的类型未知，任何的用法都要求是泛型的。然而，使用未限定类型的参数 <T> 过于不明确，并且是不允许的。事实上，指明为该结构体实现的是 Fn、FnMut、或 FnOnce 中的哪种 trait，对于约束该结构体的类型而言就已经足够了。\",\"// `F` 必须为一个没有输入参数和返回值的闭包实现 `Fn`，这和对 `print` 的 // 要求恰好一样。 fn apply<F>(f: F) where F: Fn() { f(); } fn main() { let x = 7; // 捕获 `x` 到匿名类型中，并为它实现 `Fn`。 // 将闭包存储到 `print` 中。 let print = || println!(\\\"{}\\\", x); apply(print); }\"]},\"234\":{\"h\":\"参见：\",\"t\":[\"详尽分析, Fn, FnMut, 和 FnOnce\"]},\"235\":{\"h\":\"捕获\",\"t\":[\"闭包本质上很灵活，能做功能要求的事情，使闭包在没有类型标注的情况下运行。这使得捕获（capture）能够灵活地适应用例，既可移动（move），又可借用（borrow）。闭包可以通过以下方式捕获变量：\",\"通过引用：&T\",\"通过可变引用：&mut T\",\"通过值：T\",\"闭包优先通过引用来捕获变量，并且仅在需要时使用其他方式。\",\"fn main() { use std::mem; let color = String::from(\\\"green\\\"); // 这个闭包打印 `color`。它会立即借用（通过引用，`&`）`color` 并将该借用和 // 闭包本身存储到 `print` 变量中。`color` 会一直保持被借用状态直到 // `print` 离开作用域。 // // `println!` 只需传引用就能使用，而这个闭包捕获的也是变量的引用，因此无需 // 进一步处理就可以使用 `println!`。 let print = || println!(\\\"`color`: {}\\\", color); // 使用借用来调用闭包 `color`。 print(); // `color` 可再次被不可变借用，因为闭包只持有一个指向 `color` 的不可变引用。 let _reborrow = &color; print(); // 在最后使用 `print` 之后，移动或重新借用都是允许的。 let _color_moved = color; let mut count = 0; // 这个闭包使 `count` 值增加。要做到这点，它需要得到 `&mut count` 或者 // `count` 本身，但 `&mut count` 的要求没那么严格，所以我们采取这种方式。 // 该闭包立即借用 `count`。 // // `inc` 前面需要加上 `mut`，因为闭包里存储着一个 `&mut` 变量。调用闭包时， // 该变量的变化就意味着闭包内部发生了变化。因此闭包需要是可变的。 let mut inc = || { count += 1; println!(\\\"`count`: {}\\\", count); }; // 使用可变借用调用闭包 inc(); // 因为之后调用闭包，所以仍然可变借用 `count` // 试图重新借用将导致错误 // let _reborrow = &count; // ^ 试一试：将此行注释去掉。 inc(); // 闭包不再借用 `&mut count`，因此可以正确地重新借用 let _count_reborrowed = &mut count; // 不可复制类型（non-copy type）。 let movable = Box::new(3); // `mem::drop` 要求 `T` 类型本身，所以闭包将会捕获变量的值。这种情况下， // 可复制类型将会复制给闭包，从而原始值不受影响。不可复制类型必须移动 // （move）到闭包中，因而 `movable` 变量在这里立即移动到了闭包中。 let consume = || { println!(\\\"`movable`: {:?}\\\", movable); mem::drop(movable); }; // `consume` 消耗了该变量，所以该闭包只能调用一次。 consume(); //consume(); // ^ 试一试：将此行注释去掉。 }\",\"在竖线 | 之前使用 move 会强制闭包取得被捕获变量的所有权：\",\"fn main() { // `Vec` 在语义上是不可复制的。 let haystack = vec![1, 2, 3]; let contains = move |needle| haystack.contains(needle); println!(\\\"{}\\\", contains(&1)); println!(\\\"{}\\\", contains(&4)); //println!(\\\"There're {} elements in vec\\\", haystack.len()); // ^ 取消上面一行的注释将导致编译时错误，因为借用检查不允许在变量被移动走 // 之后继续使用它。 // 在闭包的签名中删除 `move` 会导致闭包以不可变方式借用 `haystack`，因此之后 // `haystack` 仍然可用，取消上面的注释也不会导致错误。 }\"]},\"236\":{\"h\":\"参见：\",\"t\":[\"Box 和 std::mem::drop\"]},\"237\":{\"h\":\"std 中的例子\",\"t\":[\"本小节列出几个标准库中使用闭包的例子。\"]},\"238\":{\"h\":\"输入函数\",\"t\":[\"既然闭包可以作为参数，你很可能想知道函数是否也可以呢。确实可以！如果你声明一个接受闭包作为参数的函数，那么任何满足该闭包的 trait 约束的函数都可以作为其参数。\",\"// 定义一个函数，可以接受一个由 `Fn` 限定的泛型 `F` 参数并调用它。 fn call_me<F: Fn()>(f: F) { f() } // 定义一个满足 `Fn` 约束的封装函数（wrapper function）。 fn function() { println!(\\\"I'm a function!\\\"); } fn main() { // 定义一个满足 `Fn` 约束的闭包。 let closure = || println!(\\\"I'm a closure!\\\"); call_me(closure); call_me(function); }\",\"多说一句，Fn、FnMut 和 FnOnce 这些 trait 明确了闭包如何从周围的作用域中捕获变量。\"]},\"239\":{\"h\":\"参见：\",\"t\":[\"Fn, FnMut, 和 FnOnce\"]},\"240\":{\"h\":\"作为输入参数\",\"t\":[\"虽然 Rust 无需类型说明就能在大多数时候完成变量捕获，但在编写函数时，这种模糊写法是不允许的。当以闭包作为输入参数时，必须指出闭包的完整类型，它是通过使用以下 trait 中的一种来指定的。其受限制程度按以下顺序递减：\",\"Fn：表示捕获方式为通过引用（&T）的闭包\",\"FnMut：表示捕获方式为通过可变引用（&mut T）的闭包\",\"FnOnce：表示捕获方式为通过值（T）的闭包\",\"译注：顺序之所以是这样，是因为 &T 只是获取了不可变的引用，&mut T 则可以改变变量，T 则是拿到了变量的所有权而非借用。\",\"对闭包所要捕获的每个变量，编译器都将以限制最少的方式来捕获。\",\"译注：这句可能说得不对，事实上是在满足使用需求的前提下尽量以限制最多的方式捕获。\",\"例如用一个类型说明为 FnOnce 的闭包作为参数。这说明闭包可能采取 &T，&mut T 或 T 中的一种捕获方式，但编译器最终是根据所捕获变量在闭包里的使用情况决定捕获方式。\",\"这是因为如果能以移动的方式捕获变量，则闭包也有能力使用其他方式借用变量。注意反过来就不再成立：如果参数的类型说明是 Fn，那么不允许该闭包通过 &mut T 或 T 捕获变量。\",\"在下面的例子中，试着分别用一用 Fn、FnMut 和 FnOnce，看看会发生什么：\",\"// 该函数将闭包作为参数并调用它。 fn apply<F>(f: F) where // 闭包没有输入值和返回值。 F: FnOnce() { // ^ 试一试：将 `FnOnce` 换成 `Fn` 或 `FnMut`。 f(); } // 输入闭包，返回一个 `i32` 整型的函数。 fn apply_to_3<F>(f: F) -> i32 where // 闭包处理一个 `i32` 整型并返回一个 `i32` 整型。 F: Fn(i32) -> i32 { f(3) } fn main() { use std::mem; let greeting = \\\"hello\\\"; // 不可复制的类型。 // `to_owned` 从借用的数据创建有所有权的数据。 let mut farewell = \\\"goodbye\\\".to_owned(); // 捕获 2 个变量：通过引用捕获 `greeting`，通过值捕获 `farewell`。 let diary = || { // `greeting` 通过引用捕获，故需要闭包是 `Fn`。 println!(\\\"I said {}.\\\", greeting); // 下文改变了 `farewell` ，因而要求闭包通过可变引用来捕获它。 // 现在需要 `FnMut`。 farewell.push_str(\\\"!!!\\\"); println!(\\\"Then I screamed {}.\\\", farewell); println!(\\\"Now I can sleep. zzzzz\\\"); // 手动调用 drop 又要求闭包通过值获取 `farewell`。 // 现在需要 `FnOnce`。 mem::drop(farewell); }; // 以闭包作为参数，调用函数 `apply`。 apply(diary); // 闭包 `double` 满足 `apply_to_3` 的 trait 约束。 let double = |x| 2 * x; println!(\\\"3 doubled: {}\\\", apply_to_3(double)); }\"]},\"241\":{\"h\":\"参见：\",\"t\":[\"std::mem::drop, Fn, FnMut, 和 FnOnce\"]},\"242\":{\"h\":\"作为输出参数\",\"t\":[\"闭包作为输入参数是可能的，所以返回闭包作为输出参数（output parameter）也应该是可能的。然而返回闭包类型会有问题，因为目前 Rust 只支持返回具体（非泛型）的类型。按照定义，匿名的闭包的类型是未知的，所以只有使用impl Trait才能返回一个闭包。\",\"返回闭包的有效特征是：\",\"Fn\",\"FnMut\",\"FnOnce\",\"除此之外，还必须使用 move 关键字，它表明所有的捕获都是通过值进行的。这是必须的，因为在函数退出时，任何通过引用的捕获都被丢弃，在闭包中留下无效的引用。\",\"fn create_fn() -> impl Fn() { let text = \\\"Fn\\\".to_owned(); move || println!(\\\"This is a: {}\\\", text) } fn create_fnmut() -> impl FnMut() { let text = \\\"FnMut\\\".to_owned(); move || println!(\\\"This is a: {}\\\", text) } fn create_fnonce() -> impl FnOnce() { let text = \\\"FnOnce\\\".to_owned(); move || println!(\\\"This is a: {}\\\", text) } fn main() { let fn_plain = create_fn(); let mut fn_mut = create_fnmut(); let fn_once = create_fnonce(); fn_plain(); fn_mut(); fn_once(); }\"]},\"243\":{\"h\":\"参见：\",\"t\":[\"Fn, FnMut, 泛型 和 impl Trait.\"]},\"244\":{\"h\":\"存在问题\",\"t\":[\"trait 如果对实现了它的容器类型是泛型的，则须遵守类型规范要求——trait 的使用者必须指出 trait 的全部泛型类型。\",\"在下面例子中，Containstrait 允许使用泛型类型 A 和 B。然后我们为Container 类型实现了这个 trait，将 A 和 B 指定为 i32，这样就可以对它们使用 difference() 函数。\",\"因为 Contains 是泛型的，我们必须在 fn difference() 中显式地指出所有的泛型类型。但实际上，我们想要表达，A 和 B 究竟是什么类型是由输入 C 决定的。在下一节会看到，关联类型恰好提供了这样的功能。\",\"struct Container(i32, i32); // 这个 trait 检查给定的 2 个项是否储存于容器中 // 并且能够获得容器的第一个或最后一个值。 trait Contains<A, B> { fn contains(&self, _: &A, _: &B) -> bool; // 显式地要求 `A` 和 `B` fn first(&self) -> i32; // 未显式地要求 `A` 或 `B` fn last(&self) -> i32; // 未显式地要求 `A` 或 `B` } impl Contains<i32, i32> for Container { // 如果存储的数字和给定的相等则为真。 fn contains(&self, number_1: &i32, number_2: &i32) -> bool { (&self.0 == number_1) && (&self.1 == number_2) } // 得到第一个数字。 fn first(&self) -> i32 { self.0 } // 得到最后一个数字。 fn last(&self) -> i32 { self.1 } } // 容器 `C` 就包含了 `A` 和 `B` 类型。鉴于此，必须指出 `A` 和 `B` 显得很麻烦。 fn difference<A, B, C>(container: &C) -> i32 where C: Contains<A, B> { container.last() - container.first() } fn main() { let number_1 = 3; let number_2 = 10; let container = Container(number_1, number_2); println!(\\\"Does container contain {} and {}: {}\\\", &number_1, &number_2, container.contains(&number_1, &number_2)); println!(\\\"First number: {}\\\", container.first()); println!(\\\"Last number: {}\\\", container.last()); println!(\\\"The difference is: {}\\\", difference(&container)); }\"]},\"245\":{\"h\":\"参见：\",\"t\":[\"struct, 和 trait\"]},\"246\":{\"h\":\"关联类型\",\"t\":[\"通过把容器内部的类型放到 trait 中作为输出类型，使用 “关联类型” 增加了代码的可读性。这样的 trait 的定义语法如下：\",\"// `A` 和 `B` 在 trait 里面通过 `type` 关键字来定义。 // （注意：此处的 `type` 不同于为类型取别名时的 `type`）。 trait Contains { type A; type B; // 这种语法能够泛型地表示这些新类型。 fn contains(&self, _: &Self::A, _: &Self::B) -> bool; }\",\"注意使用了 Containstrait 的函数就不需要写出 A 或 B 了：\",\"// 不使用关联类型 fn difference<A, B, C>(container: &C) -> i32 where C: Contains<A, B> { ... } // 使用关联类型 fn difference<C: Contains>(container: &C) -> i32 { ... }\",\"让我们使用关联类型来重写上一小节的例子：\",\"struct Container(i32, i32); // 这个 trait 检查给定的 2 个项是否储存于容器中 // 并且能够获得容器的第一个或最后一个值。 trait Contains { // 在这里定义可以被方法使用的泛型类型。 type A; type B; fn contains(&self, _: &Self::A, _: &Self::B) -> bool; fn first(&self) -> i32; fn last(&self) -> i32; } impl Contains for Container { // 指出 `A` 和 `B` 是什么类型。如果 `input`（输入）类型 // 为 `Container(i32, i32)`，那么 `output`（输出）类型 // 会被确定为 `i32` 和 `i32`。 type A = i32; type B = i32; // `&Self::A` 和 `&Self::B` 在这里也是合法的类型。 fn contains(&self, number_1: &i32, number_2: &i32) -> bool { (&self.0 == number_1) && (&self.1 == number_2) } // 得到第一个数字。 fn first(&self) -> i32 { self.0 } // 得到最后一个数字。 fn last(&self) -> i32 { self.1 } } fn difference<C: Contains>(container: &C) -> i32 { container.last() - container.first() } fn main() { let number_1 = 3; let number_2 = 10; let container = Container(number_1, number_2); println!(\\\"Does container contain {} and {}: {}\\\", &number_1, &number_2, container.contains(&number_1, &number_2)); println!(\\\"First number: {}\\\", container.first()); println!(\\\"Last number: {}\\\", container.last()); println!(\\\"The difference is: {}\\\", difference(&container)); }\"]},\"247\":{\"h\":\"测试实例：空约束\",\"t\":[\"约束的工作机制会产生这样的效果：即使一个 trait 不包含任何功能，你仍然可以用它作为约束。标准库中的 Eq 和 Ord 就是这样的 trait。\",\"struct Cardinal; struct BlueJay; struct Turkey; trait Red {} trait Blue {} impl Red for Cardinal {} impl Blue for BlueJay {} // 这些函数只对实现了相应的 trait 的类型有效。 // 事实上这些 trait 内部是空的，但这没有关系。 fn red<T: Red>(_: &T) -> &'static str { \\\"red\\\" } fn blue<T: Blue>(_: &T) -> &'static str { \\\"blue\\\" } fn main() { let cardinal = Cardinal; let blue_jay = BlueJay; let _turkey = Turkey; // 由于约束，`red()` 不能作用于 blue_jay （蓝松鸟），反过来也一样。 println!(\\\"A cardinal is {}\\\", red(&cardinal)); println!(\\\"A blue jay is {}\\\", blue(&blue_jay)); //println!(\\\"A turkey is {}\\\", red(&_turkey)); // ^ 试一试：去掉此行注释。 }\"]},\"248\":{\"h\":\"参见：\",\"t\":[\"std::cmp::Eq, std::cmp::Ord, 和 trait\"]},\"249\":{\"h\":\"测试实例：单位说明\",\"t\":[\"通过实现一个带虚类型参数的 Add trait 可以实现单位检查。这种 Add trait 的代码如下：\",\"// 这个 `trait` 会要求 `Self + RHS = Output`。`<RHS = Self>` 表示 RHS 的默认值 // 为 Self 类型，也就是如果没有在实现中另行指定，RHS 就取 Self 类型。 pub trait Add<RHS = Self> { type Output; fn add(self, rhs: RHS) -> Self::Output; } // `Output` 必须是 `T<U>` 类型，所以是 `T<U> + T<U> = T<U>`。 impl<U> Add for T<U> { type Output = T<U>; ... }\",\"完整实现：\",\"use std::ops::Add; use std::marker::PhantomData; /// 创建空枚举类型来表示单位。 #[derive(Debug, Clone, Copy)] enum Inch {} #[derive(Debug, Clone, Copy)] enum Mm {} /// `Length` 是一个带有虚类型参数 `Unit` 的类型， /// 而且对于表示长度的类型（即 `f64`）而言，`Length` 不是泛型的。 /// /// `f64` 已经实现了 `Clone` 和 `Copy` trait. #[derive(Debug, Clone, Copy)] struct Length<Unit>(f64, PhantomData<Unit>); /// `Add` trait 定义了 `+` 运算符的行为。 impl<Unit> Add for Length<Unit> { type Output = Length<Unit>; // add() 返回一个含有和的新的 `Length` 结构体。 fn add(self, rhs: Length<Unit>) -> Length<Unit> { // `+` 调用了针对 `f64` 类型的 `Add` 实现。 Length(self.0 + rhs.0, PhantomData) } } fn main() { // 指定 `one_foot` 拥有虚类型参数 `Inch`。 let one_foot: Length<Inch> = Length(12.0, PhantomData); // `one_meter` 拥有虚类型参数 `Mm`。 let one_meter: Length<Mm> = Length(1000.0, PhantomData); // `+` 调用了我们对 `Length<Unit>` 实现的 `add()` 方法。 // // 由于 `Length` 了实现了 `Copy`，`add()` 不会消耗 `one_foot` // 和 `one_meter`，而是复制它们作为 `self` 和 `rhs`。 let two_feet = one_foot + one_foot; let two_meters = one_meter + one_meter; // 加法正常执行。 println!(\\\"one foot + one_foot = {:?} in\\\", two_feet.0); println!(\\\"one meter + one_meter = {:?} mm\\\", two_meters.0); // 无意义的运算当然会失败： // 编译期错误：类型不匹配。 //let one_feter = one_foot + one_meter; }\"]},\"250\":{\"h\":\"参见：\",\"t\":[\"Borrowing (&), Bounds (X: Y), enum, impl & self,Overloading, ref, Traits (X for Y), 和 TupleStructs.\"]},\"251\":{\"h\":\"格式化\",\"t\":[\"我们已经看到，格式化的方式是通过格式字符串来指定的：\",\"format!(\\\"{}\\\", foo) -> \\\"3735928559\\\"\",\"format!(\\\"0x{:X}\\\", foo) ->\\\"0xDEADBEEF\\\"\",\"format!(\\\"0o{:o}\\\", foo) -> \\\"0o33653337357\\\"\",\"根据使用的参数类型是 X、o 还是未指定，同样的变量（foo）能够格式化成不同的形式。\",\"这个格式化的功能是通过 trait 实现的，每种参数类型都对应一种 trait。最常见的格式化 trait 就是 Display，它可以处理参数类型为未指定的情况，比如 {}。\",\"use std::fmt::{self, Formatter, Display}; struct City { name: &'static str, // 纬度 lat: f32, // 经度 lon: f32, } impl Display for City { // `f` 是一个缓冲区（buffer），此方法必须将格式化后的字符串写入其中 fn fmt(&self, f: &mut Formatter) -> fmt::Result { let lat_c = if self.lat >= 0.0 { 'N' } else { 'S' }; let lon_c = if self.lon >= 0.0 { 'E' } else { 'W' }; // `write!` 和 `format!` 类似，但它会将格式化后的字符串写入 // 一个缓冲区（即第一个参数f）中。 write!(f, \\\"{}: {:.3}°{} {:.3}°{}\\\", self.name, self.lat.abs(), lat_c, self.lon.abs(), lon_c) } } #[derive(Debug)] struct Color { red: u8, green: u8, blue: u8, } fn main() { for city in [ City { name: \\\"Dublin\\\", lat: 53.347778, lon: -6.259722 }, City { name: \\\"Oslo\\\", lat: 59.95, lon: 10.75 }, City { name: \\\"Vancouver\\\", lat: 49.25, lon: -123.1 }, ].iter() { println!(\\\"{}\\\", *city); } for color in [ Color { red: 128, green: 255, blue: 90 }, Color { red: 0, green: 3, blue: 254 }, Color { red: 0, green: 0, blue: 0 }, ].iter() { // 在添加了针对 fmt::Display 的实现后，请改用 {} 检验效果。 println!(\\\"{:?}\\\", *color) } }\",\"在 fmt::fmt 文档中可以查看格式化 traits 一览表和它们的参数类型。\"]},\"252\":{\"h\":\"动手试一试\",\"t\":[\"为上面的 Color 结构体实现 fmt::Display，应得到如下的输出结果：\",\"RGB (128, 255, 90) 0x80FF5A RGB (0, 3, 254) 0x0003FE RGB (0, 0, 0) 0x000000\",\"如果感到疑惑，可看下面两条提示：\",\"你可能需要多次列出每个颜色，\",\"你可以使用 :02补零使位数为 2 位。\"]},\"253\":{\"h\":\"参见：\",\"t\":[\"std::fmt\"]},\"254\":{\"h\":\"调试（Debug）\",\"t\":[\"所有的类型，若想用 std::fmt 的格式化打印，都要求实现至少一个可打印的 traits。仅有一些类型提供了自动实现，比如 std 库中的类型。所有其他类型都必须手动实现。\",\"fmt::Debug 这个 trait 使这项工作变得相当简单。所有类型都能派生（derive，即自动创建）fmt::Debug 的实现。但是 fmt::Display 需要手动实现。\",\"// 这个结构体不能使用 `fmt::Display` 或 `fmt::Debug` 来进行打印。 struct UnPrintable(i32); // `derive` 属性会自动创建所需的实现，使这个 `struct` 能使用 `fmt::Debug` 打印。 #[derive(Debug)] struct DebugPrintable(i32);\",\"所有 std 库类型都天生可以使用 {:?} 来打印：\",\"// 推导 `Structure` 的 `fmt::Debug` 实现。 // `Structure` 是一个包含单个 `i32` 的结构体。 #[derive(Debug)] struct Structure(i32); // 将 `Structure` 放到结构体 `Deep` 中。然后使 `Deep` 也能够打印。 #[derive(Debug)] struct Deep(Structure); fn main() { // 使用 `{:?}` 打印和使用 `{}` 类似。 println!(\\\"{:?} months in a year.\\\", 12); println!(\\\"{1:?} {0:?} is the {actor:?} name.\\\", \\\"Slater\\\", \\\"Christian\\\", actor=\\\"actor's\\\"); // `Structure` 也可以打印！ println!(\\\"Now {:?} will print!\\\", Structure(3)); // 使用 `derive` 的一个问题是不能控制输出的形式。 // 假如我只想展示一个 `7` 怎么办？ println!(\\\"Now {:?} will print!\\\", Deep(Structure(7))); }\",\"所以 fmt::Debug 确实使这些内容可以打印，但是牺牲了一些美感。Rust 也通过 {:#?} 提供了 “美化打印” 的功能：\",\"#[derive(Debug)] struct Person<'a> { name: &'a str, age: u8 } fn main() { let name = \\\"Peter\\\"; let age = 27; let peter = Person { name, age }; // 美化打印 println!(\\\"{:#?}\\\", peter); }\",\"你可以通过手动实现 fmt::Display 来控制显示效果。\"]},\"255\":{\"h\":\"参见：\",\"t\":[\"attributes, derive, std::fmt 和 struct\"]},\"256\":{\"h\":\"显示（Display）\",\"t\":[\"fmt::Debug 通常看起来不太简洁，因此自定义输出的外观经常是更可取的。这需要通过手动实现 fmt::Display 来做到。fmt::Display 采用 {} 标记。实现方式看起来像这样：\",\"// （使用 `use`）导入 `fmt` 模块使 `fmt::Display` 可用 use std::fmt; // 定义一个结构体，咱们会为它实现 `fmt::Display`。以下是个简单的元组结构体 // `Structure`，包含一个 `i32` 元素。 struct Structure(i32); // 为了使用 `{}` 标记，必须手动为类型实现 `fmt::Display` trait。 impl fmt::Display for Structure { // 这个 trait 要求 `fmt` 使用与下面的函数完全一致的函数签名 fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { // 仅将 self 的第一个元素写入到给定的输出流 `f`。返回 `fmt:Result`，此 // 结果表明操作成功或失败。注意 `write!` 的用法和 `println!` 很相似。 write!(f, \\\"{}\\\", self.0) } }\",\"fmt::Display 的效果可能比 fmt::Debug 简洁，但对于 std 库来说，这就有一个问题。模棱两可的类型该如何显示呢？举个例子，假设标准库对所有的 Vec<T> 都实现了同一种输出样式，那么它应该是哪种样式？下面两种中的一种吗？\",\"Vec<path>：/:/etc:/home/username:/bin（使用 : 分割）\",\"Vec<number>：1,2,3（使用 , 分割）\",\"我们没有这样做，因为没有一种合适的样式适用于所有类型，标准库也并不擅自规定一种样式。对于 Vec<T> 或其他任意泛型容器（generic container），fmt::Display 都没有实现。因此在这些泛型的情况下要用 fmt::Debug。\",\"这并不是一个问题，因为对于任何非泛型的容器类型， fmt::Display 都能够实现。\",\"use std::fmt; // 导入 `fmt` // 带有两个数字的结构体。推导出 `Debug`，以便与 `Display` 的输出进行比较。 #[derive(Debug)] struct MinMax(i64, i64); // 实现 `MinMax` 的 `Display`。 impl fmt::Display for MinMax { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { // 使用 `self.number` 来表示各个数据。 write!(f, \\\"({}, {})\\\", self.0, self.1) } } // 为了比较，定义一个含有具名字段的结构体。 #[derive(Debug)] struct Point2D { x: f64, y: f64, } // 类似地对 `Point2D` 实现 `Display` impl fmt::Display for Point2D { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { // 自定义格式，使得仅显示 `x` 和 `y` 的值。 write!(f, \\\"x: {}, y: {}\\\", self.x, self.y) } } fn main() { let minmax = MinMax(0, 14); println!(\\\"Compare structures:\\\"); println!(\\\"Display: {}\\\", minmax); println!(\\\"Debug: {:?}\\\", minmax); let big_range = MinMax(-300, 300); let small_range = MinMax(-3, 3); println!(\\\"The big range is {big} and the small is {small}\\\", small = small_range, big = big_range); let point = Point2D { x: 3.3, y: 7.2 }; println!(\\\"Compare points:\\\"); println!(\\\"Display: {}\\\", point); println!(\\\"Debug: {:?}\\\", point); // 报错。`Debug` 和 `Display` 都被实现了，但 `{:b}` 需要 `fmt::Binary` // 得到实现。这语句不能运行。 // println!(\\\"What does Point2D look like in binary: {:b}?\\\", point); }\",\"fmt::Display 被实现了，而 fmt::Binary 没有，因此 fmt::Binary 不能使用。std::fmt 有很多这样的 trait，它们都要求有各自的实现。这些内容将在后面的 std::fmt 章节中详细介绍。\"]},\"257\":{\"h\":\"动手试一试\",\"t\":[\"检验上面例子的输出，然后在示例程序中，仿照 Point2D 结构体增加一个名为 Complex 的结构体。 使用一样的方式打印，输出结果要求是这个样子：\",\"Display: 3.3 + 7.2i Debug: Complex { real: 3.3, imag: 7.2 }\"]},\"258\":{\"h\":\"参见：\",\"t\":[\"derive, std::fmt, macros, struct,trait, 和 use\"]},\"259\":{\"h\":\"别名使用\",\"t\":[\"数据可以多次不可变借用，但是在不可变借用的同时，原始数据不能使用可变借用。或者说，同一时间内只允许一次可变借用。仅当最后一次使用可变引用之后，原始数据才可以再次借用。\",\"struct Point { x: i32, y: i32, z: i32 } fn main() { let mut point = Point { x: 0, y: 0, z: 0 }; let borrowed_point = &point; let another_borrow = &point; // 数据可以通过引用或原始类型来访问 println!(\\\"Point has coordinates: ({}, {}, {})\\\", borrowed_point.x, another_borrow.y, point.z); // 报错！`point` 不能以可变方式借用，因为当前还有不可变借用。 // let mutable_borrow = &mut point; // TODO ^ 试一试去掉此行注释 // 被借用的值在这里被重新使用 println!(\\\"Point has coordinates: ({}, {}, {})\\\", borrowed_point.x, another_borrow.y, point.z); // 不可变的引用不再用于其余的代码，因此可以使用可变的引用重新借用。 let mutable_borrow = &mut point; // 通过可变引用来修改数据 mutable_borrow.x = 5; mutable_borrow.y = 2; mutable_borrow.z = 1; // 报错！不能再以不可变方式来借用 `point`，因为它当前已经被可变借用。 // let y = &point.y; // TODO ^ 试一试去掉此行注释 // 报错！无法打印，因为 `println!` 用到了一个不可变引用。 // println!(\\\"Point Z coordinate is {}\\\", point.z); // TODO ^ 试一试去掉此行注释 // 正常运行！可变引用能够以不可变类型传入 `println!` println!(\\\"Point has coordinates: ({}, {}, {})\\\", mutable_borrow.x, mutable_borrow.y, mutable_borrow.z); // 可变引用不再用于其余的代码，因此可以重新借用 let new_borrowed_point = &point; println!(\\\"Point now has coordinates: ({}, {}, {})\\\", new_borrowed_point.x, new_borrowed_point.y, new_borrowed_point.z); }\"]},\"260\":{\"h\":\"冻结\",\"t\":[\"当数据被不可变地借用时，它还会冻结（freeze）。已冻结的数据无法通过原始对象来修改，直到对这些数据的所有引用离开作用域为止。\",\"fn main() { let mut _mutable_integer = 7i32; { // 借用 `_mutable_integer` let large_integer = &_mutable_integer; // 报错！`_mutable_integer` 在本作用域被冻结 _mutable_integer = 50; // 改正 ^ 注释掉此行 println!(\\\"Immutably borrowed {}\\\", large_integer); // `large_integer` 离开作用域 } // 正常运行！`_mutable_integer` 在这作用域没有冻结 _mutable_integer = 3; }\"]},\"261\":{\"h\":\"可变性\",\"t\":[\"可变数据可以使用 &mut T 进行可变借用。这叫做可变引用（mutable reference），它使借用者可以读/写数据。相反，&T 通过不可变引用（immutable reference）来借用数据，借用者可以读数据而不能更改数据：\",\"#[allow(dead_code)] #[derive(Clone, Copy)] struct Book { // `&'static str` 是一个对分配在只读内存区的字符串的引用 author: &'static str, title: &'static str, year: u32, } // 此函数接受一个对 Book 类型的引用 fn borrow_book(book: &Book) { println!(\\\"I immutably borrowed {} - {} edition\\\", book.title, book.year); } // 此函数接受一个对可变的 Book 类型的引用，它把年份 `year` 改为 2014 年 fn new_edition(book: &mut Book) { book.year = 2014; println!(\\\"I mutably borrowed {} - {} edition\\\", book.title, book.year); } fn main() { // 创建一个名为 `immutabook` 的不可变的 Book 实例 let immutabook = Book { // 字符串字面量拥有 `&'static str` 类型 author: \\\"Douglas Hofstadter\\\", title: \\\"Gödel, Escher, Bach\\\", year: 1979, }; // 创建一个 `immutabook` 的可变拷贝，命名为 `mutabook` let mut mutabook = immutabook; // 不可变地借用一个不可变对象 borrow_book(&immutabook); // 不可变地借用一个可变对象 borrow_book(&mutabook); // 可变地借用一个可变对象 new_edition(&mut mutabook); // 报错！不能可变地借用一个不可变对象 new_edition(&mut immutabook); // 改正 ^ 注释掉此行 }\"]},\"262\":{\"h\":\"参见：\",\"t\":[\"static\"]},\"263\":{\"h\":\"ref 模式\",\"t\":[\"在通过 let 绑定来进行模式匹配或解构时，ref 关键字可用来创建结构体/元组的字段的引用。下面的例子展示了几个实例，可看到 ref 的作用：\",\"#[derive(Clone, Copy)] struct Point { x: i32, y: i32 } fn main() { let c = 'Q'; // 赋值语句中左边的 `ref` 关键字等价于右边的 `&` 符号。 let ref ref_c1 = c; let ref_c2 = &c; println!(\\\"ref_c1 equals ref_c2: {}\\\", *ref_c1 == *ref_c2); let point = Point { x: 0, y: 0 }; // 在解构一个结构体时 `ref` 同样有效。 let _copy_of_x = { // `ref_to_x` 是一个指向 `point` 的 `x` 字段的引用。 let Point { x: ref ref_to_x, y: _ } = point; // 返回一个 `point` 的 `x` 字段的拷贝。 *ref_to_x }; // `point` 的可变拷贝 let mut mutable_point = point; { // `ref` 可以与 `mut` 结合以创建可变引用。 let Point { x: _, y: ref mut mut_ref_to_y } = mutable_point; // 通过可变引用来改变 `mutable_point` 的字段 `y`。 *mut_ref_to_y = 1; } println!(\\\"point is ({}, {})\\\", point.x, point.y); println!(\\\"mutable_point is ({}, {})\\\", mutable_point.x, mutable_point.y); // 包含一个指针的可变元组 let mut mutable_tuple = (Box::new(5u32), 3u32); { // 解构 `mutable_tuple` 来改变 `last` 的值。 let (_, ref mut last) = mutable_tuple; *last = 2u32; } println!(\\\"tuple is {:?}\\\", mutable_tuple); }\"]},\"264\":{\"h\":\"省略\",\"t\":[\"有些生命周期的模式太常用了，所以借用检查器将会隐式地添加它们以减少程序输入量和增强可读性。这种隐式添加生命周期的过程称为省略（elision）。在 Rust 使用省略仅仅是因为这些模式太普遍了。\",\"下面代码展示了一些省略的例子。对于省略的详细描述，可以参考官方文档的生命周期省略。\",\"// `elided_input` 和 `annotated_input` 事实上拥有相同的签名， // `elided_input` 的生命周期会被编译器自动添加： fn elided_input(x: &i32) { println!(\\\"`elided_input`: {}\\\", x) } fn annotated_input<'a>(x: &'a i32) { println!(\\\"`annotated_input`: {}\\\", x) } // 类似地，`elided_pass` 和 `annotated_pass` 也拥有相同的签名， // 生命周期会被隐式地添加进 `elided_pass`： fn elided_pass(x: &i32) -> &i32 { x } fn annotated_pass<'a>(x: &'a i32) -> &'a i32 { x } fn main() { let x = 3; elided_input(&x); annotated_input(&x); println!(\\\"`elided_pass`: {}\\\", elided_pass(&x)); println!(\\\"`annotated_pass`: {}\\\", annotated_pass(&x)); }\"]},\"265\":{\"h\":\"参见：\",\"t\":[\"省略\"]},\"266\":{\"h\":\"显式标注\",\"t\":[\"借用检查器使用显式的生命周期标记来明确引用的有效时间应该持续多久。在生命周期没有省略[^1]的情况下，Rust 需要显式标注来确定引用的生命周期应该是什么样的。可以用撇号显式地标出生命周期，语法如下：\",\"foo<'a> // `foo` 带有一个生命周期参数 `'a`\",\"和闭包类似，使用生命周期需要泛型。另外这个生命周期的语法也表明了 foo 的生命周期不能超出 'a 的周期。若要给类型显式地标注生命周期，其语法会像是 &'a T 这样，其中 'a 的作用刚刚已经介绍了。\",\"foo<'a, 'b> // `foo` 带有生命周期参数 `'a` 和 `'b`\",\"在上面这种情形中，foo 的生命周期不能超出 'a 和 'b 中任一个的周期。\",\"看下面的例子，了解显式生命周期标注的运用：\",\"// `print_refs` 接受两个 `i32` 的引用，它们有不同的生命周期 `'a` 和 `'b`。 // 这两个生命周期都必须至少要和 `print_refs` 函数一样长。 fn print_refs<'a, 'b>(x: &'a i32, y: &'b i32) { println!(\\\"x is {} and y is {}\\\", x, y); } // 不带参数的函数，不过有一个生命周期参数 `'a`。 fn failed_borrow<'a>() { let _x = 12; // 报错：`_x` 的生命周期不够长 //let y: &'a i32 = &_x; // 在函数内部使用生命周期 `'a` 作为显式类型标注将导致失败，因为 `&_x` 的 // 生命周期比 `y` 的短。短生命周期不能强制转换成长生命周期。 } fn main() { // 创建变量，稍后用于借用。 let (four, nine) = (4, 9); // 两个变量的借用（`&`）都传进函数。 print_refs(&four, &nine); // 任何被借用的输入量都必须比借用者生存得更长。 // 也就是说，`four` 和 `nine` 的生命周期都必须比 `print_refs` 的长。 failed_borrow(); // `failed_borrow` 未包含引用，因此不要求 `'a` 长于函数的生命周期， // 但 `'a` 寿命确实更长。因为该生命周期从未被约束，所以默认为 `'static`。 }\",\"[^1]: 省略 隐式地标注了生命周期，所以情况不同。\"]},\"267\":{\"h\":\"参见：\",\"t\":[\"泛型 和 闭包\"]},\"268\":{\"h\":\"函数\",\"t\":[\"排除省略（elision）的情况，带上生命周期的函数签名有一些限制：\",\"任何引用都必须拥有标注好的生命周期。\",\"任何被返回的引用都必须有和某个输入量相同的生命周期或是静态类型（static）。\",\"另外要注意，如果没有输入的函数返回引用，有时会导致返回的引用指向无效数据，这种情况下禁止它返回这样的引用。下面例子展示了一些合法的带有生命周期的函数：\",\"// 一个拥有生命周期 `'a` 的输入引用，其中 `'a` 的存活时间 // 至少与函数的一样长。 fn print_one<'a>(x: &'a i32) { println!(\\\"`print_one`: x is {}\\\", x); } // 可变引用同样也可能拥有生命周期。 fn add_one<'a>(x: &'a mut i32) { *x += 1; } // 拥有不同生命周期的多个元素。对下面这种情形，两者即使拥有 // 相同的生命周期 `'a` 也没问题，但对一些更复杂的情形，可能 // 就需要不同的生命周期了。 fn print_multi<'a, 'b>(x: &'a i32, y: &'b i32) { println!(\\\"`print_multi`: x is {}, y is {}\\\", x, y); } // 返回传递进来的引用也是可行的。 // 但必须返回正确的生命周期。 fn pass_x<'a, 'b>(x: &'a i32, _: &'b i32) -> &'a i32 { x } //fn invalid_output<'a>() -> &'a String { &String::from(\\\"foo\\\") } // 上面代码是无效的：`'a` 存活的时间必须比函数的长。 // 这里的 `&String::from(\\\"foo\\\")` 将会创建一个 `String` 类型，然后对它取引用。 // 数据在离开作用域时删掉，返回一个指向无效数据的引用。 fn main() { let x = 7; let y = 9; print_one(&x); print_multi(&x, &y); let z = pass_x(&x, &y); print_one(z); let mut t = 3; add_one(&mut t); print_one(&t); }\"]},\"269\":{\"h\":\"参见：\",\"t\":[\"函数\"]},\"270\":{\"h\":\"约束\",\"t\":[\"就如泛型类型能够被约束一样，生命周期（它们本身就是泛型）也可以使用约束。: 字符的意义在这里稍微有些不同，不过 + 是相同的。注意下面的说明：\",\"T: 'a：在 T 中的所有引用都必须比生命周期 'a 活得更长。\",\"T: Trait + 'a：T 类型必须实现 Trait trait，并且在 T 中的所有引用都必须比 'a 活得更长。\",\"下面例子展示了上述语法的实际应用：\",\"use std::fmt::Debug; // 用于约束的 trait。 #[derive(Debug)] struct Ref<'a, T: 'a>(&'a T); // `Ref` 包含一个指向泛型类型 `T` 的引用，其中 `T` 拥有一个未知的生命周期 // `'a`。`T` 拥有生命周期限制， `T` 中的任何*引用*都必须比 `'a` 活得更长。另外 // `Ref` 的生命周期也不能超出 `'a`。 // 一个泛型函数，使用 `Debug` trait 来打印内容。 fn print<T>(t: T) where T: Debug { println!(\\\"`print`: t is {:?}\\\", t); } // 这里接受一个指向 `T` 的引用，其中 `T` 实现了 `Debug` trait，并且在 `T` 中的 // 所有*引用*都必须比 `'a'` 存活时间更长。另外，`'a` 也要比函数活得更长。 fn print_ref<'a, T>(t: &'a T) where T: Debug + 'a { println!(\\\"`print_ref`: t is {:?}\\\", t); } fn main() { let x = 7; let ref_x = Ref(&x); print_ref(&ref_x); print(ref_x); }\"]},\"271\":{\"h\":\"参见：\",\"t\":[\"泛型, 泛型中的约束, 以及 泛型中的多重约束\"]},\"272\":{\"h\":\"强制转换\",\"t\":[\"一个较长的生命周期可以强制转成一个较短的生命周期，使它在一个通常情况下不能工作的作用域内也能正常工作。强制转换可由编译器隐式地推导并执行，也可以通过声明不同的生命周期的形式实现。\",\"// 在这里，Rust 推导了一个尽可能短的生命周期。 // 然后这两个引用都被强制转成这个生命周期。 fn multiply<'a>(first: &'a i32, second: &'a i32) -> i32 { first * second } // `<'a: 'b, 'b>` 读作生命周期 `'a` 至少和 `'b` 一样长。 // 在这里我们我们接受了一个 `&'a i32` 类型并返回一个 `&'b i32` 类型，这是 // 强制转换得到的结果。 fn choose_first<'a: 'b, 'b>(first: &'a i32, _: &'b i32) -> &'b i32 { first } fn main() { let first = 2; // 较长的生命周期 { let second = 3; // 较短的生命周期 println!(\\\"The product is {}\\\", multiply(&first, &second)); println!(\\\"{} is the first\\\", choose_first(&first, &second)); }; }\"]},\"273\":{\"h\":\"方法\",\"t\":[\"方法的标注和函数类似：\",\"struct Owner(i32); impl Owner { // 标注生命周期，就像独立的函数一样。 fn add_one<'a>(&'a mut self) { self.0 += 1; } fn print<'a>(&'a self) { println!(\\\"`print`: {}\\\", self.0); } } fn main() { let mut owner = Owner(18); owner.add_one(); owner.print(); }\",\"译注：方法一般是不需要标明生命周期的，因为 self 的生命周期会赋给所有的输出生命周期参数，详见 TRPL。\"]},\"274\":{\"h\":\"参见：\",\"t\":[\"方法\"]},\"275\":{\"h\":\"static\",\"t\":[\"'static 生命周期是可能的生命周期中最长的，它会在整个程序运行的时期中存在。'static 生命周期也可被强制转换成一个更短的生命周期。有两种方式使变量拥有 'static 生命周期，它们都把数据保存在可执行文件的只读内存区：\",\"使用 static 声明来产生常量（constant）。\",\"产生一个拥有 &'static str 类型的 string 字面量。\",\"看下面的例子，了解列举到的各个方法：\",\"// 产生一个拥有 `'static` 生命周期的常量。 static NUM: i32 = 18; // 返回一个指向 `NUM` 的引用，该引用不取 `NUM` 的 `'static` 生命周期， // 而是被强制转换成和输入参数的一样。 fn coerce_static<'a>(_: &'a i32) -> &'a i32 { &NUM } fn main() { { // 产生一个 `string` 字面量并打印它： let static_string = \\\"I'm in read-only memory\\\"; println!(\\\"static_string: {}\\\", static_string); // 当 `static_string` 离开作用域时，该引用不能再使用，不过 // 数据仍然存在于二进制文件里面。 } { // 产生一个整型给 `coerce_static` 使用： let lifetime_num = 9; // 将对 `NUM` 的引用强制转换成 `lifetime_num` 的生命周期： let coerced_static = coerce_static(&lifetime_num); println!(\\\"coerced_static: {}\\\", coerced_static); } println!(\\\"NUM: {} stays accessible!\\\", NUM); }\"]},\"276\":{\"h\":\"参见：\",\"t\":[\"'static 常量\"]},\"277\":{\"h\":\"结构体\",\"t\":[\"在结构体中标注生命周期也和函数的类似：\",\"// 一个 `Borrowed` 类型，含有一个指向 `i32` 类型的引用。 // 该引用必须比 `Borrowed` 寿命更长。 #[derive(Debug)] struct Borrowed<'a>(&'a i32); // 和前面类似，这里的两个引用都必须比这个结构体长寿。 #[derive(Debug)] struct NamedBorrowed<'a> { x: &'a i32, y: &'a i32, } // 一个枚举类型，其取值不是 `i32` 类型就是一个指向 `i32` 的引用。 #[derive(Debug)] enum Either<'a> { Num(i32), Ref(&'a i32), } fn main() { let x = 18; let y = 15; let single = Borrowed(&x); let double = NamedBorrowed { x: &x, y: &y }; let reference = Either::Ref(&x); let number = Either::Num(y); println!(\\\"x is borrowed in {:?}\\\", single); println!(\\\"x and y are borrowed in {:?}\\\", double); println!(\\\"x is borrowed in {:?}\\\", reference); println!(\\\"y is *not* borrowed in {:?}\\\", number); }\"]},\"278\":{\"h\":\"参见：\",\"t\":[\"结构体\"]},\"279\":{\"h\":\"trait\",\"t\":[\"trait 方法中生命期的标注基本上与函数类似。注意，impl 也可能有生命周期的标注。\",\"// 带有生命周期标注的结构体。 #[derive(Debug)] struct Borrowed<'a> { x: &'a i32, } // 给 impl 标注生命周期。 impl<'a> Default for Borrowed<'a> { fn default() -> Self { Self { x: &10, } } } fn main() { let b: Borrowed = Default::default(); println!(\\\"b is {:?}\\\", b); }\"]},\"280\":{\"h\":\"参见：\",\"t\":[\"trait\"]},\"281\":{\"h\":\"可变性\",\"t\":[\"当所有权转移时，数据的可变性可能发生改变。\",\"fn main() { let immutable_box = Box::new(5u32); println!(\\\"immutable_box contains {}\\\", immutable_box); // 可变性错误 //*immutable_box = 4; // *移动* box，改变所有权（和可变性） let mut mutable_box = immutable_box; println!(\\\"mutable_box contains {}\\\", mutable_box); // 修改 box 的内容 *mutable_box = 4; println!(\\\"mutable_box now contains {}\\\", mutable_box); }\"]},\"282\":{\"h\":\"部分移动\",\"t\":[\"在单个变量的解构内，可以同时使用 by-move 和 by-reference 模式绑定。这样做将导致变量的部分移动（partial move），这意味着变量的某些部分将被移动，而其他部分将保留。在这种情况下，后面不能整体使用父级变量，但是仍然可以使用只引用（而不移动）的部分。\",\"fn main() { #[derive(Debug)] struct Person { name: String, age: u8, } let person = Person { name: String::from(\\\"Alice\\\"), age: 20, }; // `name` 从 person 中移走，但 `age` 只是引用 let Person { name, ref age } = person; println!(\\\"The person's age is {}\\\", age); println!(\\\"The person's name is {}\\\", name); // 报错！部分移动值的借用：`person` 部分借用产生 //println!(\\\"The person struct is {:?}\\\", person); // `person` 不能使用，但 `person.age` 因为没有被移动而可以继续使用 println!(\\\"The person's age from person struct is {}\\\", person.age); }\"]},\"283\":{\"h\":\"参见：\",\"t\":[\"解构\"]},\"284\":{\"h\":\"更改或自定义关键字类型\",\"t\":[\"任何实现了 Eq 和 Hash trait 的类型都可以充当 HashMap 的键。这包括：\",\"bool （当然这个用处不大，因为只有两个可能的键）\",\"int，unit，以及其他整数类型\",\"String 和 &str（友情提示：如果使用 String 作为键来创建 HashMap，则可以 将 &str 作为散列表的 .get() 方法的参数，以获取值）\",\"注意到 f32 和 f64没有实现 Hash，这很大程度上是由于若使用浮点数作为散列表的键，浮点精度误差会很容易导致错误。\",\"对于所有的集合类（collection class），如果它们包含的类型都分别实现了 Eq 和 Hash，那么这些集合类也就实现了 Eq 和 Hash。例如，若 T 实现了Hash，则 Vec<T> 也实现了 Hash。\",\"对自定义类型可以轻松地实现 Eq 和 Hash，只需加上一行代码：#[derive(PartialEq, Eq, Hash)]。\",\"编译器将会完成余下的工作。如果你想控制更多的细节，你可以手动实现 Eq 和/或 Hash。本指南不包含实现 Hash 的细节内容。\",\"为了试验 HashMap 中的 struct，让我们试着做一个非常简易的用户登录系统：\",\"use std::collections::HashMap; // Eq 要求你对此类型推导 PartiaEq。 #[derive(PartialEq, Eq, Hash)] struct Account<'a>{ username: &'a str, password: &'a str, } struct AccountInfo<'a>{ name: &'a str, email: &'a str, } type Accounts<'a> = HashMap<Account<'a>, AccountInfo<'a>>; fn try_logon<'a>(accounts: &Accounts<'a>, username: &'a str, password: &'a str){ println!(\\\"Username: {}\\\", username); println!(\\\"Password: {}\\\", password); println!(\\\"Attempting logon...\\\"); let logon = Account { username: username, password: password, }; match accounts.get(&logon) { Some(account_info) => { println!(\\\"Successful logon!\\\"); println!(\\\"Name: {}\\\", account_info.name); println!(\\\"Email: {}\\\", account_info.email); }, _ => println!(\\\"Login failed!\\\"), } } fn main(){ let mut accounts: Accounts = HashMap::new(); let account = Account { username: \\\"j.everyman\\\", password: \\\"password123\\\", }; let account_info = AccountInfo { name: \\\"John Everyman\\\", email: \\\"j.everyman@email.com\\\", }; accounts.insert(account, account_info); try_logon(&accounts, \\\"j.everyman\\\", \\\"psasword123\\\"); try_logon(&accounts, \\\"j.everyman\\\", \\\"password123\\\"); }\"]},\"285\":{\"h\":\"散列集 HashSet\",\"t\":[\"请把 HashSet 当成这样一个 HashMap：我们只关心其中的键而非值（HashSet<T> 实际上只是对 HashMap<T, ()> 的封装）。\",\"你可能会问：“这有什么意义呢？我完全可以将键存储到一个 Vec 中呀。”\",\"HashSet 的独特之处在于，它保证了不会出现重复的元素。这是任何 set 集合类型（set collection）遵循的规定。HashSet 只是它的一个实现。（参见：BTreeSet）\",\"如果插入的值已经存在于 HashSet 中（也就是，新值等于已存在的值，并且拥有相同的散列值），那么新值将会替换旧的值。\",\"如果你不想要一样东西出现多于一次，或者你要判断一样东西是不是已经存在，这种做法就很有用了。\",\"不过集合（set）可以做更多的事。\",\"集合（set）拥有 4 种基本操作（下面的调用全部都返回一个迭代器）：\",\"union（并集）：获得两个集合中的所有元素（不含重复值）。\",\"difference（差集）：获取属于第一个集合而不属于第二集合的所有元素。\",\"intersection（交集）：获取同时属于两个集合的所有元素。\",\"symmetric_difference（对称差）：获取所有只属于其中一个集合，而不同时属于 两个集合的所有元素。\",\"在下面的例子中尝试使用这些操作。\",\"use std::collections::HashSet; fn main() { let mut a: HashSet<i32> = vec!(1i32, 2, 3).into_iter().collect(); let mut b: HashSet<i32> = vec!(2i32, 3, 4).into_iter().collect(); assert!(a.insert(4)); assert!(a.contains(&4)); // 如果值已经存在，那么 `HashSet::insert()` 返回 false。 assert!(b.insert(4), \\\"Value 4 is already in set B!\\\"); // 改正 ^ 将此行注释掉。 b.insert(5); // 若一个集合（collection）的元素类型实现了 `Debug`，那么该集合也就实现了 `Debug`。 // 这通常将元素打印成这样的格式 `[elem1, elem2, ...] println!(\\\"A: {:?}\\\", a); println!(\\\"B: {:?}\\\", b); // 乱序打印 [1, 2, 3, 4, 5]。 println!(\\\"Union: {:?}\\\", a.union(&b).collect::<Vec<&i32>>()); // 这将会打印出 [1] println!(\\\"Difference: {:?}\\\", a.difference(&b).collect::<Vec<&i32>>()); // 乱序打印 [2, 3, 4]。 println!(\\\"Intersection: {:?}\\\", a.intersection(&b).collect::<Vec<&i32>>()); // 打印 [1, 5] println!(\\\"Symmetric Difference: {:?}\\\", a.symmetric_difference(&b).collect::<Vec<&i32>>()); }\",\"（例子改编自文档。）\"]},\"286\":{\"h\":\"? 运算符\",\"t\":[\"把 result 用 match 连接起来会显得很难看；幸运的是，? 运算符可以把这种逻辑变得干净漂亮。? 运算符用在返回值为 Result 的表达式后面，它等同于这样一个匹配表达式：其中 Err(err) 分支展开成提前返回的 return Err(err)，而 Ok(ok) 分支展开成 ok 表达式。\",\"mod checked { #[derive(Debug)] enum MathError { DivisionByZero, NegativeLogarithm, NegativeSquareRoot, } type MathResult = Result<f64, MathError>; fn div(x: f64, y: f64) -> MathResult { if y == 0.0 { Err(MathError::DivisionByZero) } else { Ok(x / y) } } fn sqrt(x: f64) -> MathResult { if x < 0.0 { Err(MathError::NegativeSquareRoot) } else { Ok(x.sqrt()) } } fn ln(x: f64) -> MathResult { if x < 0.0 { Err(MathError::NegativeLogarithm) } else { Ok(x.ln()) } } // 中间函数 fn op_(x: f64, y: f64) -> MathResult { // 如果 `div` “失败” 了，那么返回 `DivisionByZero` let ratio = div(x, y)?; // 如果 `ln` “失败” 了，那么返回 `NegativeLogarithm` let ln = ln(ratio)?; sqrt(ln) } pub fn op(x: f64, y: f64) { match op_(x, y) { Err(why) => panic!(\\\"{}\\\",match why { MathError::NegativeLogarithm => \\\"logarithm of negative number\\\", MathError::DivisionByZero => \\\"division by zero\\\", MathError::NegativeSquareRoot => \\\"square root of negative number\\\", }), Ok(value) => println!(\\\"{}\\\", value), } } } fn main() { checked::op(1.0, 10.0); }\",\"记得查阅文档，里面有很多匹配/组合 Result 的方法。\"]},\"287\":{\"h\":\"参数解析\",\"t\":[\"可以用模式匹配来解析简单的参数：\",\"use std::env; fn increase(number: i32) { println!(\\\"{}\\\", number + 1); } fn decrease(number: i32) { println!(\\\"{}\\\", number - 1); } fn help() { println!(\\\"usage: match_args <string> Check whether given string is the answer. match_args {{increase|decrease}} <integer> Increase or decrease given integer by one.\\\"); } fn main() { let args: Vec<String> = env::args().collect(); match args.len() { // 没有传入参数 1 => { println!(\\\"My name is 'match_args'. Try passing some arguments!\\\"); }, // 一个传入参数 2 => { match args[1].parse() { Ok(42) => println!(\\\"This is the answer!\\\"), _ => println!(\\\"This is not the answer.\\\"), } }, // 传入一条命令和一个参数 3 => { let cmd = &args[1]; let num = &args[2]; // 解析数字 let number: i32 = match num.parse() { Ok(n) => { n }, Err(_) => { println!(\\\"error: second argument not an integer\\\"); help(); return; }, }; // 解析命令 match &cmd[..] { \\\"increase\\\" => increase(number), \\\"decrease\\\" => decrease(number), _ => { println!(\\\"error: invalid command\\\"); help(); }, } }, // 所有其他情况 _ => { // 显示帮助信息 help(); } } }\",\"$ ./match_args Rust This is not the answer. $ ./match_args 42 This is the answer! $ ./match_args do something error: second argument not an integer usage: match_args <string> Check whether given string is the answer. match_args {increase|decrease} <integer> Increase or decrease given integer by one. $ ./match_args do 42 error: invalid command usage: match_args <string> Check whether given string is the answer. match_args {increase|decrease} <integer> Increase or decrease given integer by one. $ ./match_args increase 42 43\"]},\"288\":{\"h\":\"创建文件 create\",\"t\":[\"create 静态方法以只写模式（write-only mode）打开一个文件。若文件已经存在，则旧内容将被销毁。否则，将创建一个新文件。\",\"static LOREM_IPSUM: &'static str = \\\"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. \\\"; use std::io::prelude::*; use std::fs::File; use std::path::Path; fn main() { let path = Path::new(\\\"out/lorem_ipsum.txt\\\"); let display = path.display(); // 以只写模式打开文件，返回 `io::Result<File>` let mut file = match File::create(&path) { Err(why) => panic!(\\\"couldn't create {}: {:?}\\\", display, why), Ok(file) => file, }; // 将 `LOREM_IPSUM` 字符串写进 `file`，返回 `io::Result<()>` match file.write_all(LOREM_IPSUM.as_bytes()) { Err(why) => { panic!(\\\"couldn't write to {}: {:?}\\\", display, why) }, Ok(_) => println!(\\\"successfully wrote to {}\\\", display), } }\",\"下面是预期成功的输出：\",\"$ mkdir out $ rustc create.rs && ./create successfully wrote to out/lorem_ipsum.txt $ cat out/lorem_ipsum.txt Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\",\"（和前面例子一样，我们鼓励你在失败条件下测试这个例子。）\",\"还有一个更通用的 open_mode 方法，这能够以其他方式来来打开文件，如：read+write（读 + 写），追加（append），等等。\"]},\"289\":{\"h\":\"打开文件 open\",\"t\":[\"open 静态方法能够以只读模式（read-only mode）打开一个文件。\",\"File 拥有资源，即文件描述符（file descriptor），它会在自身被 drop 时关闭文件。\",\"use std::fs::File; use std::io::prelude::*; use std::path::Path; fn main() { // 创建指向所需的文件的路径 let path = Path::new(\\\"hello.txt\\\"); let display = path.display(); // 以只读方式打开路径，返回 `io::Result<File>` let mut file = match File::open(&path) { // `io::Error` 的 `description` 方法返回一个描述错误的字符串。 Err(why) => panic!(\\\"couldn't open {}: {:?}\\\", display, why), Ok(file) => file, }; // 读取文件内容到一个字符串，返回 `io::Result<usize>` let mut s = String::new(); match file.read_to_string(&mut s) { Err(why) => panic!(\\\"couldn't read {}: {:?}\\\", display, why), Ok(_) => print!(\\\"{} contains:\\\\n{}\\\", display, s), } // `file` 离开作用域，并且 `hello.txt` 文件将被关闭。 }\",\"下面是所希望的成功的输出：\",\"$ echo \\\"Hello World!\\\" > hello.txt $ rustc open.rs && ./open hello.txt contains: Hello World!\",\"（我们鼓励您在不同的失败条件下测试前面的例子：hello.txt 不存在，或 hello.txt 不可读，等等。）\"]},\"290\":{\"h\":\"读取行\",\"t\":[\"方法 lines() 在文件的行上返回一个迭代器。\",\"File::open 需要一个泛型 AsRef<Path>。这正是 read_lines() 期望的输入。\",\"use std::fs::File; use std::io::{self, BufRead}; use std::path::Path; fn main() { // 在生成输出之前，文件 `hosts` 必须存在于当前路径中 if let Ok(lines) = read_lines(\\\"./hosts\\\") { // 使用迭代器，返回一个（可选）字符串 for line in lines { if let Ok(ip) = line { println!(\\\"{}\\\", ip); } } } } // 输出包裹在 Result 中以允许匹配错误， // 将迭代器返回给文件行的读取器（Reader）。 fn read_lines<P>(filename: P) -> io::Result<io::Lines<io::BufReader<File>>> where P: AsRef<Path>, { let file = File::open(filename)?; Ok(io::BufReader::new(file).lines()) }\",\"运行此程序将一行行将内容打印出来。\",\"$ echo -e \\\"127.0.0.1\\\\n192.168.0.1\\\\n\\\" > hosts $ rustc read_lines.rs && ./read_lines 127.0.0.1 192.168.0.1\",\"这个过程比在内存中创建 String 更有效，特别是处理更大的文件。\"]},\"291\":{\"h\":\"管道\",\"t\":[\"std::Child 结构体代表了一个正在运行的子进程，它暴露了 stdin（标准输入），stdout（标准输出）和 stderr（标准错误）句柄，从而可以通过管道与所代表的进程交互。\",\"use std::io::prelude::*; use std::process::{Command, Stdio}; static PANGRAM: &'static str = \\\"the quick brown fox jumped over the lazy dog\\\\n\\\"; fn main() { // 启动 `wc` 命令 let process = match Command::new(\\\"wc\\\") .stdin(Stdio::piped()) .stdout(Stdio::piped()) .spawn() { Err(why) => panic!(\\\"couldn't spawn wc: {:?}\\\", why), Ok(process) => process, }; // 将字符串写入 `wc` 的 `stdin`。 // // `stdin` 拥有 `Option<ChildStdin>` 类型，不过我们已经知道这个实例不为空值， // 因而可以直接 `unwrap 它。 match process.stdin.unwrap().write_all(PANGRAM.as_bytes()) { Err(why) => panic!(\\\"couldn't write to wc stdin: {:?}\\\", why), Ok(_) => println!(\\\"sent pangram to wc\\\"), } // 因为 `stdin` 在上面调用后就不再存活，所以它被 `drop` 了，管道也被关闭。 // // 这点非常重要，因为否则 `wc` 就不会开始处理我们刚刚发送的输入。 // `stdout` 字段也拥有 `Option<ChildStdout>` 类型，所以必需解包。 let mut s = String::new(); match process.stdout.unwrap().read_to_string(&mut s) { Err(why) => panic!(\\\"couldn't read wc stdout: {:?}\\\", why), Ok(_) => print!(\\\"wc responded with:\\\\n{}\\\", s), } }\"]},\"292\":{\"h\":\"等待\",\"t\":[\"如果你想等待一个 process::Child 完成，就必须调用 Child::wait，这会返回一个 process::ExitStatus。\",\"use std::process::Command; fn main() { let mut child = Command::new(\\\"sleep\\\").arg(\\\"5\\\").spawn().unwrap(); let _result = child.wait().unwrap(); println!(\\\"reached end of main\\\"); }\",\"$ rustc wait.rs && ./wait reached end of main # `wait` keeps running for 5 seconds # `sleep 5` command ends, and then our `wait` program finishes\"]},\"293\":{\"h\":\"测试实例：map-reduce\",\"t\":[\"Rust 使数据的并行化处理非常简单，在 Rust 中你无需面对并行处理的很多传统难题。\",\"标准库提供了开箱即用的线程类型，把它和 Rust 的所有权概念与别名规则结合起来，可以自动地避免数据竞争（data race）。\",\"当某状态对某线程是可见的，别名规则（即一个可变引用 XOR 一些只读引用。译注：XOR 是异或的意思，即「二者仅居其一」）就自动地避免了别的线程对它的操作。（当需要同步处理时，请使用 Mutex 或 Channel 这样的同步类型。）\",\"在本例中，我们将会计算一堆数字中每一位的和。我们将把它们分成几块，放入不同的线程。每个线程会把自己那一块数字的每一位加起来，之后我们再把每个线程提供的结果再加起来。\",\"注意到，虽然我们在线程之间传递了引用，但 Rust 理解我们是在传递只读的引用，因此不会发生数据竞争等不安全的事情。另外，因为我们把数据块 move 到了线程中，Rust 会保证数据存活至线程退出，因此不会产生悬挂指针。\",\"use std::thread; // 这是 `main` 线程 fn main() { // 这是我们要处理的数据。 // 我们会通过线程实现 map-reduce 算法，从而计算每一位的和 // 每个用空白符隔开的块都会分配给单独的线程来处理 // // 试一试：插入空格，看看输出会怎样变化！ let data = \\\"86967897737416471853297327050364959 11861322575564723963297542624962850 70856234701860851907960690014725639 38397966707106094172783238747669219 52380795257888236525459303330302837 58495327135744041048897885734297812 69920216438980873548808413720956532 16278424637452589860345374828574668\\\"; // 创建一个向量，用于储存将要创建的子线程 let mut children = vec![]; /************************************************************************* * \\\"Map\\\" 阶段 * * 把数据分段，并进行初始化处理 ************************************************************************/ // 把数据分段，每段将会单独计算 // 每段都是完整数据的一个引用（&str） let chunked_data = data.split_whitespace(); // 对分段的数据进行迭代。 // .enumerate() 会把当前的迭代计数与被迭代的元素以元组 (index, element) // 的形式返回。接着立即使用 “解构赋值” 将该元组解构成两个变量， // `i` 和 `data_segment`。 for (i, data_segment) in chunked_data.enumerate() { println!(\\\"data segment {} is \\\\\\\"{}\\\\\\\"\\\", i, data_segment); // 用单独的线程处理每一段数据 // // spawn() 返回新线程的句柄（handle），我们必须拥有句柄， // 才能获取线程的返回值。 // // 'move || -> u32' 语法表示该闭包： // * 没有参数（'||'） // * 会获取所捕获变量的所有权（'move'） // * 返回无符号 32 位整数（'-> u32'） // // Rust 可以根据闭包的内容推断出 '-> u32'，所以我们可以不写它。 // // 试一试：删除 'move'，看看会发生什么 children.push(thread::spawn(move || -> u32 { // 计算该段的每一位的和： let result = data_segment // 对该段中的字符进行迭代.. .chars() // ..把字符转成数字.. .map(|c| c.to_digit(10).expect(\\\"should be a digit\\\")) // ..对返回的数字类型的迭代器求和 .sum(); // println! 会锁住标准输出，这样各线程打印的内容不会交错在一起 println!(\\\"processed segment {}, result={}\\\", i, result); // 不需要 “return”，因为 Rust 是一种 “表达式语言”，每个代码块中 // 最后求值的表达式就是代码块的值。 result })); } /************************************************************************* * \\\"Reduce\\\" 阶段 * * 收集中间结果，得出最终结果 ************************************************************************/ // 把每个线程产生的中间结果收入一个新的向量中 let mut intermediate_sums = vec![]; for child in children { // 收集每个子线程的返回值 let intermediate_sum = child.join().unwrap(); intermediate_sums.push(intermediate_sum); } // 把所有中间结果加起来，得到最终结果 // // 我们用 “涡轮鱼” 写法 ::<> 来为 sum() 提供类型提示。 // // 试一试：不使用涡轮鱼写法，而是显式地指定 intermediate_sums 的类型 let final_result = intermediate_sums.iter().sum::<u32>(); println!(\\\"Final sum result: {}\\\", final_result); }\"]},\"294\":{\"h\":\"作业\",\"t\":[\"根据用户输入的数据来决定线程的数量是不明智的。如果用户输入的数据中有一大堆空格怎么办？我们真的想要创建 2000 个线程吗？\",\"请修改程序，使得数据总是被分成有限数目的段，这个数目是由程序开头的静态常量决定的。\"]},\"295\":{\"h\":\"参见:\",\"t\":[\"[向量][vectors]和[迭代器][iterators]\",\"[解构][destructuring]赋值\",\"使用涡轮鱼写法帮助类型推断\",\"[枚举类型][enumerate]\"]},\"296\":{\"h\":\"枚举\",\"t\":[\"和前面相似，解构 enum 的方式如下：\",\"// 需要 `allow` 来消除警告，因为只使用了枚举类型的一种取值。 #[allow(dead_code)] enum Color { // 这三个取值仅由它们的名字（而非类型）来指定。 Red, Blue, Green, // 这些则把 `u32` 元组赋予不同的名字，以色彩模型命名。 RGB(u32, u32, u32), HSV(u32, u32, u32), HSL(u32, u32, u32), CMY(u32, u32, u32), CMYK(u32, u32, u32, u32), } fn main() { let color = Color::RGB(122, 17, 40); // 试一试 ^ 将不同的值赋给 `color` println!(\\\"What color is it?\\\"); // 可以使用 `match` 来解构 `enum`。 match color { Color::Red => println!(\\\"The color is Red!\\\"), Color::Blue => println!(\\\"The color is Blue!\\\"), Color::Green => println!(\\\"The color is Green!\\\"), Color::RGB(r, g, b) => println!(\\\"Red: {}, green: {}, and blue: {}!\\\", r, g, b), Color::HSV(h, s, v) => println!(\\\"Hue: {}, saturation: {}, value: {}!\\\", h, s, v), Color::HSL(h, s, l) => println!(\\\"Hue: {}, saturation: {}, lightness: {}!\\\", h, s, l), Color::CMY(c, m, y) => println!(\\\"Cyan: {}, magenta: {}, yellow: {}!\\\", c, m, y), Color::CMYK(c, m, y, k) => println!(\\\"Cyan: {}, magenta: {}, yellow: {}, key (black): {}!\\\", c, m, y, k), // 不需要其它分支，因为所有的情形都已覆盖 } }\"]},\"297\":{\"h\":\"参见：\",\"t\":[\"#[allow(...)], 色彩模型 和 enum\"]},\"298\":{\"h\":\"指针和引用\",\"t\":[\"对指针来说，解构（destructure）和解引用（dereference）要区分开，因为这两者的概念是不同的，和 C 那样的语言用法不一样。\",\"解引用使用 *\",\"解构使用 &、ref、和 ref mut\",\"fn main() { // 获得一个 `i32` 类型的引用。`&` 表示取引用。 let reference = &4; match reference { // 如果用 `&val` 这个模式去匹配 `reference`，就相当于做这样的比较： // `&i32`（译注：即 `reference` 的类型） // `&val`（译注：即用于匹配的模式） // ^ 我们看到，如果去掉匹配的 `&`，`i32` 应当赋给 `val`。 // 译注：因此可用 `val` 表示被 `reference` 引用的值 4。 &val => println!(\\\"Got a value via destructuring: {:?}\\\", val), } // 如果不想用 `&`，需要在匹配前解引用。 match *reference { val => println!(\\\"Got a value via dereferencing: {:?}\\\", val), } // 如果一开始就不用引用，会怎样？ `reference` 是一个 `&` 类型，因为赋值语句 // 的右边已经是一个引用。但下面这个不是引用，因为右边不是。 let _not_a_reference = 3; // Rust 对这种情况提供了 `ref`。它更改了赋值行为，从而可以对具体值创建引用。 // 下面这行将得到一个引用。 let ref _is_a_reference = 3; // 相应地，定义两个非引用的变量，通过 `ref` 和 `ref mut` 仍可取得其引用。 let value = 5; let mut mut_value = 6; // 使用 `ref` 关键字来创建引用。 // 译注：下面的 r 是 `&i32` 类型，它像 `i32` 一样可以直接打印，因此用法上 // 似乎看不出什么区别。但读者可以把 `println!` 中的 `r` 改成 `*r`，仍然能 // 正常运行。前面例子中的 `println!` 里就不能是 `*val`，因为不能对整数解 // 引用。 match value { ref r => println!(\\\"Got a reference to a value: {:?}\\\", r), } // 类似地使用 `ref mut`。 match mut_value { ref mut m => { // 已经获得了 `mut_value` 的引用，先要解引用，才能改变它的值。 *m += 10; println!(\\\"We added 10. `mut_value`: {:?}\\\", m); }, } }\"]},\"299\":{\"h\":\"参见：\",\"t\":[\"ref 模式\"]},\"300\":{\"h\":\"数组/切片\",\"t\":[\"像元组一样，数组和切片也可以这样解构:\",\"fn main() { // 尝试改变数组中的值，或者将其做成切片! let array = [1, -2, 6]; match array { // 将第二个和第三个元素绑定到各自的变量 [0, second, third] => println!(\\\"array[0] = 0, array[1] = {}, array[2] = {}\\\", second, third), // 单个值可以用 `_` 忽略 [1, _, third] => println!( \\\"array[0] = 1, array[2] = {} and array[1] was ignored\\\", third ), // 你也可以绑定一些而忽略其余的 [-1, second, ..] => println!( \\\"array[0] = -1, array[1] = {} and all the other ones were ignored\\\", second ), // 下面的代码无法编译 // [-1, second] => ... // 或者将它们存储在另一个数组/切片中（类型取决于所匹配的值的类型） [3, second, tail @ ..] => println!( \\\"array[0] = 3, array[1] = {} and the other elements were {:?}\\\", second, tail ), // 结合这些模式，我们可以绑定第一个和最后一个值，并将其余的值存储在一个数组中 [first, middle @ .., last] => println!( \\\"array[0] = {}, middle = {:?}, array[2] = {}\\\", first, middle, last ), } }\"]},\"301\":{\"h\":\"参见：\",\"t\":[\"数组和切片 与 @ 符号用法绑定\"]},\"302\":{\"h\":\"结构体\",\"t\":[\"类似地，解构 struct 如下所示：\",\"fn main() { struct Foo { x: (u32, u32), y: u32 } // 解构结构体的成员 let foo = Foo { x: (1, 2), y: 3 }; let Foo { x: (a, b), y } = foo; println!(\\\"a = {}, b = {}, y = {} \\\", a, b, y); // 可以解构结构体并重命名变量，成员顺序并不重要 let Foo { y: i, x: j } = foo; println!(\\\"i = {:?}, j = {:?}\\\", i, j); // 也可以忽略某些变量 let Foo { y, .. } = foo; println!(\\\"y = {}\\\", y); // 这将得到一个错误：模式中没有提及 `x` 字段 // let Foo { y } = foo; }\"]},\"303\":{\"h\":\"参见：\",\"t\":[\"结构体, ref 模式\"]},\"304\":{\"h\":\"元组\",\"t\":[\"元组可以在 match 中解构，如下所示：\",\"fn main() { let triple = (0, -2, 3); // 试一试 ^ 将不同的值赋给 `triple` println!(\\\"Tell me about {:?}\\\", triple); // match 可以解构一个元组 match triple { // 解构出第二个和第三个元素 (0, y, z) => println!(\\\"First is `0`, `y` is {:?}, and `z` is {:?}\\\", y, z), (1, ..) => println!(\\\"First is `1` and the rest doesn't matter\\\"), // `..` 可用来忽略元组的其余部分 _ => println!(\\\"It doesn't matter what they are\\\"), // `_` 表示不将值绑定到变量 } }\"]},\"305\":{\"h\":\"参见：\",\"t\":[\"元组\"]},\"306\":{\"h\":\"Iterator::any\",\"t\":[\"Iterator::any 是一个函数，若传给它一个迭代器（iterator），当其中任一元素满足谓词（predicate）时它将返回 true，否则返回 false（译注：谓词是闭包规定的， true/false 是闭包作用在元素上的返回值）。它的签名如下：\",\"pub trait Iterator { // 被迭代的类型。 type Item; // `any` 接受 `&mut self` 参数（译注：回想一下，这是 `self: &mut Self` 的简写） // 表明函数的调用者可以被借用和修改，但不会被消耗。 fn any<F>(&mut self, f: F) -> bool where // `FnMut` 表示被捕获的变量最多只能被修改，而不能被消耗。 // `Self::Item` 表明变量是通过值传递给闭包（译注：是迭代器对应的元素的类型） F: FnMut(Self::Item) -> bool {} }\",\"fn main() { let vec1 = vec![1, 2, 3]; let vec2 = vec![4, 5, 6]; // 对 vec 的 `iter()` 举出 `&i32`。（通过用 `&x` 匹配）把它解构成 `i32`。 // 译注：注意 `any` 方法会自动地把 `vec.iter()` 举出的迭代器的元素一个个地 // 传给闭包。因此闭包接收到的参数是 `&i32` 类型的。 println!(\\\"2 in vec1: {}\\\", vec1.iter() .any(|&x| x == 2)); // 对 vec 的 `into_iter()` 举出 `i32` 类型。无需解构。 println!(\\\"2 in vec2: {}\\\", vec2.into_iter().any(| x| x == 2)); let array1 = [1, 2, 3]; let array2 = [4, 5, 6]; // 对数组的 `iter()` 举出 `&i32`。 println!(\\\"2 in array1: {}\\\", array1.iter() .any(|&x| x == 2)); // 对数组的 `into_iter()` 举出 `i32`。 println!(\\\"2 in array2: {}\\\", array2.into_iter().any(|x| x == 2)); }\"]},\"307\":{\"h\":\"参见：\",\"t\":[\"std::iter::Iterator::any\"]},\"308\":{\"h\":\"Iterator::find\",\"t\":[\"Iterator::find 是一个函数，在传给它一个迭代器时，将用 Option 类型返回第一个满足谓词的元素。它的签名如下：\",\"pub trait Iterator { // 被迭代的类型。 type Item; // `find` 接受 `&mut self` 参数，表明函数的调用者可以被借用和修改， // 但不会被消耗。 fn find<P>(&mut self, predicate: P) -> Option<Self::Item> where // `FnMut` 表示被捕获的变量最多只能被修改，而不能被消耗。 // `&Self::Item` 指明了被捕获变量的类型（译注：是对迭代器元素的引用类型） P: FnMut(&Self::Item) -> bool {} }\",\"fn main() { let vec1 = vec![1, 2, 3]; let vec2 = vec![4, 5, 6]; // 对 vec1 的 `iter()` 举出 `&i32` 类型。 let mut iter = vec1.iter(); // 对 vec2 的 `into_iter()` 举出 `i32` 类型。 let mut into_iter = vec2.into_iter(); // 对迭代器举出的元素的引用是 `&&i32` 类型。解构成 `i32` 类型。 // 译注：注意 `find` 方法会把迭代器元素的引用传给闭包。迭代器元素自身 // 是 `&i32` 类型，所以传给闭包的是 `&&i32` 类型。 println!(\\\"Find 2 in vec1: {:?}\\\", iter .find(|&&x| x == 2)); // 对迭代器举出的元素的引用是 `&i32` 类型。解构成 `i32` 类型。 println!(\\\"Find 2 in vec2: {:?}\\\", into_iter.find(| &x| x == 2)); let array1 = [1, 2, 3]; let array2 = [4, 5, 6]; // 对数组的 `iter()` 举出 `&i32`。 println!(\\\"Find 2 in array1: {:?}\\\", array1.iter() .find(|&&x| x == 2)); // 对数组的 `into_iter()` 通常举出 `i32`。 println!(\\\"Find 2 in array2: {:?}\\\", array2.into_iter().find(|&x| x == 2)); }\"]},\"309\":{\"h\":\"参见：\",\"t\":[\"std::iter::Iterator::find\"]},\"310\":{\"h\":\"测试实例：List\",\"t\":[\"对一个结构体实现 fmt::Display，其中的元素需要一个接一个地处理到，这可能会很麻烦。问题在于每个 write! 都要生成一个 fmt::Result。正确的实现需要处理所有的 Result。Rust 专门为解决这个问题提供了 ? 操作符。\",\"在 write! 上使用 ? 会像是这样：\",\"// 对 `write!` 进行尝试（try），观察是否出错。若发生错误，返回相应的错误。 // 否则（没有出错）继续执行后面的语句。 write!(f, \\\"{}\\\", value)?;\",\"另外，你也可以使用 try! 宏，它和 ? 是一样的。这种写法比较罗嗦，故不再推荐， 但在老一些的 Rust 代码中仍会看到。使用 try! 看起来像这样：\",\"try!(write!(f, \\\"{}\\\", value));\",\"有了 ?，对一个 Vec 实现 fmt::Display 就很简单了：\",\"use std::fmt; // 导入 `fmt` 模块。 // 定义一个包含单个 `Vec` 的结构体 `List`。 struct List(Vec<i32>); impl fmt::Display for List { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { // 使用元组的下标获取值，并创建一个 `vec` 的引用。 let vec = &self.0; write!(f, \\\"[\\\")?; // 使用 `v` 对 `vec` 进行迭代，并用 `count` 记录迭代次数。 for (count, v) in vec.iter().enumerate() { // 对每个元素（第一个元素除外）加上逗号。 // 使用 `?` 或 `try!` 来返回错误。 if count != 0 { write!(f, \\\", \\\")?; } write!(f, \\\"{}\\\", v)?; } // 加上配对中括号，并返回一个 fmt::Result 值。 write!(f, \\\"]\\\") } } fn main() { let v = List(vec![1, 2, 3]); println!(\\\"{}\\\", v); }\"]},\"311\":{\"h\":\"动手试一试：\",\"t\":[\"更改程序使 vector 里面每个元素的下标也能够打印出来。新的结果如下：\",\"[0: 1, 1: 2, 2: 3]\"]},\"312\":{\"h\":\"参见：\",\"t\":[\"for, ref, Result, struct,?, 和 vec!\"]},\"313\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"314\":{\"h\":\"Attribute\"},\"315\":{\"h\":\"Compatibility\"},\"316\":{\"h\":\"Cargo\"},\"317\":{\"h\":\"Conversion\"},\"318\":{\"h\":\"Crates\"},\"319\":{\"h\":\"Custom Types\"},\"320\":{\"h\":\"Error\"},\"321\":{\"h\":\"Flow Control\"},\"322\":{\"h\":\"Fn\"},\"323\":{\"h\":\"Generics\"},\"324\":{\"h\":\"Hello\"},\"325\":{\"h\":\"Macros\"},\"326\":{\"h\":\"Meta\"},\"327\":{\"h\":\"Mod\"},\"328\":{\"h\":\"Primitives\"},\"329\":{\"h\":\"Scope\"},\"330\":{\"h\":\"Std\"},\"331\":{\"h\":\"Std Misc\"},\"332\":{\"h\":\"Testing\"},\"333\":{\"h\":\"Trait\"},\"334\":{\"h\":\"Types\"},\"335\":{\"h\":\"Variable Bindings\"},\"336\":{\"h\":\"Cfg\"},\"337\":{\"h\":\"Enum\"},\"338\":{\"h\":\"Multiple Error Types\"},\"339\":{\"h\":\"Option Unwrap\"},\"340\":{\"h\":\"Result\"},\"341\":{\"h\":\"Loop\"},\"342\":{\"h\":\"Match\"},\"343\":{\"h\":\"Closures\"},\"344\":{\"h\":\"Assoc Items\"},\"345\":{\"h\":\"Bounds\"},\"346\":{\"h\":\"Phantom\"},\"347\":{\"h\":\"Print\"},\"348\":{\"h\":\"Borrow\"},\"349\":{\"h\":\"Lifetime\"},\"350\":{\"h\":\"Move\"},\"351\":{\"h\":\"Hash\"},\"352\":{\"h\":\"Result\"},\"353\":{\"h\":\"Arg\"},\"354\":{\"h\":\"File\"},\"355\":{\"h\":\"Process\"},\"356\":{\"h\":\"Threads\"},\"357\":{\"h\":\"Destructuring\"},\"358\":{\"h\":\"Closure Examples\"},\"359\":{\"h\":\"Print Display\"}},\"dirtCount\":0,\"index\":[[\"故不再推荐\",{\"1\":{\"310\":1}}],[\"故需要闭包是\",{\"1\":{\"240\":1}}],[\"继续执行后面的语句\",{\"1\":{\"310\":1}}],[\"继承\",{\"1\":{\"189\":1}}],[\"专门为解决这个问题提供了\",{\"1\":{\"310\":1}}],[\"问题在于每个\",{\"1\":{\"310\":1}}],[\"问题描述\",{\"1\":{\"80\":1}}],[\"举出的迭代器的元素一个个地\",{\"1\":{\"306\":1}}],[\"举出\",{\"1\":{\"306\":4,\"308\":3}}],[\"举个例子\",{\"1\":{\"40\":1,\"44\":1,\"137\":1,\"256\":1}}],[\"谓词是闭包规定的\",{\"1\":{\"306\":1}}],[\"成员顺序并不重要\",{\"1\":{\"302\":1}}],[\"成功编译之前需要一些先决条件\",{\"1\":{\"41\":1}}],[\"先要解引用\",{\"1\":{\"298\":1}}],[\"先转换到对应的无符号类型\",{\"1\":{\"193\":1}}],[\"似乎看不出什么区别\",{\"1\":{\"298\":1}}],[\"仍可取得其引用\",{\"1\":{\"298\":1}}],[\"仍然能\",{\"1\":{\"298\":1}}],[\"仍然可用\",{\"1\":{\"235\":1}}],[\"仍然可以使程序\",{\"1\":{\"68\":1}}],[\"仍然代表泛型\",{\"1\":{\"11\":1}}],[\"色彩模型\",{\"1\":{\"297\":1}}],[\"阶段\",{\"1\":{\"293\":2}}],[\"插入空格\",{\"1\":{\"293\":1}}],[\"算法\",{\"1\":{\"293\":1}}],[\"理解我们是在传递只读的引用\",{\"1\":{\"293\":1}}],[\"放入不同的线程\",{\"1\":{\"293\":1}}],[\"放到结构体\",{\"1\":{\"254\":1}}],[\"二者仅居其一\",{\"1\":{\"293\":1}}],[\"二进制可执行文件\",{\"1\":{\"44\":1}}],[\"二进制文件或库\",{\"1\":{\"1\":1}}],[\"句柄\",{\"1\":{\"291\":1}}],[\"期望的输入\",{\"1\":{\"290\":1}}],[\"追加\",{\"1\":{\"288\":1}}],[\"追加一些元素\",{\"1\":{\"205\":1}}],[\"传给闭包\",{\"1\":{\"306\":1}}],[\"传入一条命令和一个参数\",{\"1\":{\"287\":1}}],[\"传递\",{\"1\":{\"118\":1}}],[\"组合\",{\"1\":{\"286\":1}}],[\"组合算子\",{\"0\":{\"215\":1,\"217\":1},\"1\":{\"0\":2}}],[\"失败\",{\"1\":{\"286\":2}}],[\"失败表示成\",{\"1\":{\"147\":1}}],[\"例子改编自文档\",{\"1\":{\"285\":1}}],[\"例如用一个类型说明为\",{\"1\":{\"240\":1}}],[\"例如引用\",{\"1\":{\"140\":1}}],[\"例如考虑这种情况\",{\"1\":{\"139\":1}}],[\"例如下面的例子用到了\",{\"1\":{\"89\":1}}],[\"例如在\",{\"1\":{\"84\":1}}],[\"例如我们可以增加一些安静的沉思\",{\"1\":{\"30\":1}}],[\"例如\",{\"1\":{\"26\":1,\"45\":1,\"70\":2,\"83\":1,\"89\":1,\"181\":1,\"184\":1,\"185\":1,\"187\":1,\"189\":1,\"228\":1,\"284\":1}}],[\"例如字符串\",{\"1\":{\"15\":1}}],[\"例如定义一个名为\",{\"1\":{\"11\":1}}],[\"例如局部变量\",{\"1\":{\"8\":1}}],[\"例如读取一个文件时失败了\",{\"1\":{\"7\":1}}],[\"乱序打印\",{\"1\":{\"285\":2}}],[\"交集\",{\"1\":{\"285\":1}}],[\"交互\",{\"1\":{\"67\":2}}],[\"差集\",{\"1\":{\"285\":1}}],[\"获得一个\",{\"1\":{\"298\":1}}],[\"获得两个集合中的所有元素\",{\"1\":{\"285\":1}}],[\"获取所有只属于其中一个集合\",{\"1\":{\"285\":1}}],[\"获取同时属于两个集合的所有元素\",{\"1\":{\"285\":1}}],[\"获取属于第一个集合而不属于第二集合的所有元素\",{\"1\":{\"285\":1}}],[\"获取此人的工作电话号码的区号\",{\"1\":{\"219\":1}}],[\"种基本操作\",{\"1\":{\"285\":1}}],[\"种类\",{\"1\":{\"164\":1}}],[\"种类型\",{\"1\":{\"60\":1}}],[\"新的结果如下\",{\"1\":{\"311\":1}}],[\"新的类型\",{\"1\":{\"191\":1}}],[\"新值等于已存在的值\",{\"1\":{\"285\":1}}],[\"遵循的规定\",{\"1\":{\"285\":1}}],[\"我完全可以将键存储到一个\",{\"1\":{\"285\":1}}],[\"我们真的想要创建\",{\"1\":{\"294\":1}}],[\"我们用\",{\"1\":{\"293\":1}}],[\"我们鼓励您在不同的失败条件下测试前面的例子\",{\"1\":{\"289\":1}}],[\"我们鼓励你在失败条件下测试这个例子\",{\"1\":{\"288\":1}}],[\"我们只关心其中的键而非值\",{\"1\":{\"285\":1}}],[\"我们只需给\",{\"1\":{\"43\":1}}],[\"我们没有这样做\",{\"1\":{\"256\":1}}],[\"我们没有制作寿司所需的原材料\",{\"1\":{\"215\":1}}],[\"我们希望把错误返回给调用者\",{\"1\":{\"225\":1}}],[\"我们一般是想要避免\",{\"1\":{\"220\":1}}],[\"我们已经学会了如何使用组合算子和提前返回显式地处理错误\",{\"1\":{\"220\":1}}],[\"我们已经看到\",{\"1\":{\"151\":1,\"251\":1}}],[\"我们显式地使用组合算子处理了错误\",{\"1\":{\"220\":1}}],[\"我们把\",{\"1\":{\"217\":1}}],[\"我们需要了解需要处理的错误类型是什么\",{\"1\":{\"225\":1}}],[\"我们需要原材料和食谱\",{\"1\":{\"215\":1}}],[\"我们需要把字面量的类型告诉编译器\",{\"1\":{\"135\":1}}],[\"我们拥有全部食物的食谱\",{\"1\":{\"215\":1}}],[\"我们采用\",{\"1\":{\"213\":1}}],[\"我们调用\",{\"1\":{\"211\":1}}],[\"我们实现了不服从交换律的加法\",{\"1\":{\"187\":1}}],[\"我们在这里使用\",{\"1\":{\"186\":1,\"211\":1}}],[\"我们在这里定义了一个\",{\"1\":{\"93\":1}}],[\"我们的函数返回一个包含一些\",{\"1\":{\"184\":1}}],[\"我们必须拥有句柄\",{\"1\":{\"293\":1}}],[\"我们必须在\",{\"1\":{\"244\":1}}],[\"我们必须使用完全限定语法\",{\"1\":{\"181\":1}}],[\"我们必须满足这一假设\",{\"1\":{\"34\":1}}],[\"我们通常会给它们写一层安全的封装\",{\"1\":{\"159\":1}}],[\"我们通过\",{\"1\":{\"139\":1}}],[\"我们想要表达\",{\"1\":{\"244\":1}}],[\"我们想要捕获的数学\",{\"1\":{\"151\":1}}],[\"我们想要以一种方式来管理不同的错误类型\",{\"1\":{\"67\":1}}],[\"我们提供了\",{\"1\":{\"151\":1}}],[\"我们更希望能访问数据\",{\"1\":{\"138\":1}}],[\"我们看到\",{\"1\":{\"298\":1}}],[\"我们看到代码仍然正常运行\",{\"1\":{\"128\":1}}],[\"我们看到了如何编写单元测试和集成测试\",{\"1\":{\"45\":1}}],[\"我们看到了以下目录层次结构\",{\"1\":{\"43\":1}}],[\"我们要将\",{\"1\":{\"103\":1}}],[\"我们使用\",{\"1\":{\"101\":1,\"135\":1,\"217\":1}}],[\"我们也可以使用\",{\"1\":{\"131\":1}}],[\"我们也可以执行\",{\"1\":{\"44\":1}}],[\"我们也没有为其实现\",{\"1\":{\"76\":1}}],[\"我们应该更具体地了解返回类型并考虑显式地处理错误\",{\"1\":{\"70\":1}}],[\"我们试着用\",{\"1\":{\"70\":1}}],[\"我们来看看怎样简化之前使用组合算子的例子\",{\"1\":{\"221\":1}}],[\"我们来看看当\",{\"1\":{\"70\":1}}],[\"我们来看一些处理这种问题的策略\",{\"1\":{\"63\":1}}],[\"我们就让程序\",{\"1\":{\"68\":1}}],[\"我们会通过线程实现\",{\"1\":{\"293\":1}}],[\"我们会看到处理这类问题的几种策略\",{\"1\":{\"67\":1}}],[\"我们会用\",{\"1\":{\"11\":1}}],[\"我们得提供要转换到的类型\",{\"1\":{\"51\":1}}],[\"我们经常需要把字符串转成数字\",{\"1\":{\"51\":1}}],[\"我们知道测试是任何软件不可缺少的一部分\",{\"1\":{\"45\":1}}],[\"我们可以绑定第一个和最后一个值\",{\"1\":{\"300\":1}}],[\"我们可以用间接的方法\",{\"1\":{\"225\":1}}],[\"我们可以用\",{\"1\":{\"225\":1}}],[\"我们可以方便地给它取一个别名\",{\"1\":{\"223\":1}}],[\"我们可以停止函数的执行然后返回错误\",{\"1\":{\"220\":1}}],[\"我们可以借助一系列\",{\"1\":{\"215\":1}}],[\"我们可以使用\",{\"1\":{\"211\":1,\"225\":1}}],[\"我们可以使用由\",{\"1\":{\"178\":1}}],[\"我们可以完全自定义错误类型\",{\"1\":{\"209\":1}}],[\"我们可以直接使用值的方法\",{\"1\":{\"149\":1}}],[\"我们可以把之前的\",{\"1\":{\"116\":1}}],[\"我们可以检查空字符串\",{\"1\":{\"68\":1}}],[\"我们可以通过别名引用每个枚举变量\",{\"1\":{\"58\":1}}],[\"我们可以将单元测试放在需要测试的模块中\",{\"1\":{\"45\":1}}],[\"我们可以在文档中隐藏几行源代码\",{\"1\":{\"171\":1}}],[\"我们可以在项目目录中的任何位置\",{\"1\":{\"44\":1}}],[\"我们可以在这里使用函数\",{\"1\":{\"10\":1}}],[\"我们可以很简单地在\",{\"1\":{\"44\":1}}],[\"我们选定创建的都是二进制可执行文件而不是库\",{\"1\":{\"44\":1}}],[\"我们将把它们分成几块\",{\"1\":{\"293\":1}}],[\"我们将会计算一堆数字中每一位的和\",{\"1\":{\"293\":1}}],[\"我们将看到\",{\"1\":{\"220\":1}}],[\"我们将看到生命周期和作用域的联系与区别\",{\"1\":{\"139\":1}}],[\"我们将用一个自定义错误类型来演示这一点\",{\"1\":{\"209\":1}}],[\"我们将展示如何在\",{\"1\":{\"115\":1}}],[\"我们将要看到的最简单的错误处理机制就是\",{\"1\":{\"69\":1}}],[\"我们将更仔细地学习测试的内容\",{\"1\":{\"43\":1}}],[\"我们将无法命名该功能\",{\"1\":{\"40\":1}}],[\"我们构建了\",{\"1\":{\"41\":1}}],[\"我们借用官方文档的一句话\",{\"1\":{\"32\":1}}],[\"我们定义了包含一系列方法的\",{\"1\":{\"30\":1}}],[\"我们\",{\"1\":{\"11\":1}}],[\"友情提示\",{\"1\":{\"284\":1}}],[\"寿命更长\",{\"1\":{\"277\":1}}],[\"寿命确实更长\",{\"1\":{\"266\":1}}],[\"含有一个指向\",{\"1\":{\"277\":1}}],[\"含有私有字段\",{\"1\":{\"129\":1}}],[\"详见\",{\"1\":{\"273\":1}}],[\"详尽分析\",{\"1\":{\"234\":1}}],[\"较短的生命周期\",{\"1\":{\"272\":1}}],[\"较长的生命周期\",{\"1\":{\"272\":1}}],[\"至少和\",{\"1\":{\"272\":1}}],[\"至少与函数的一样长\",{\"1\":{\"268\":1}}],[\"读\",{\"1\":{\"288\":1}}],[\"读作生命周期\",{\"1\":{\"272\":1}}],[\"读取文件内容到一个字符串\",{\"1\":{\"289\":1}}],[\"读取目录的内容\",{\"1\":{\"161\":1}}],[\"读取行\",{\"0\":{\"290\":1},\"1\":{\"0\":1}}],[\"活得更长\",{\"1\":{\"270\":3}}],[\"存活时间更长\",{\"1\":{\"270\":1}}],[\"存活的时间必须比函数的长\",{\"1\":{\"268\":1}}],[\"存在问题\",{\"0\":{\"244\":1},\"1\":{\"0\":1}}],[\"排除省略\",{\"1\":{\"268\":1}}],[\"排序并移除重复值\",{\"1\":{\"152\":1}}],[\"稍后用于借用\",{\"1\":{\"266\":1}}],[\"稍后详述\",{\"1\":{\"16\":3}}],[\"短生命周期不能强制转换成长生命周期\",{\"1\":{\"266\":1}}],[\"短路求值的布尔逻辑\",{\"1\":{\"135\":1}}],[\"命名为\",{\"1\":{\"261\":1}}],[\"命令来运行它们\",{\"1\":{\"177\":1}}],[\"命令就可以了\",{\"1\":{\"176\":1}}],[\"命令\",{\"1\":{\"173\":1,\"291\":1}}],[\"命令传入一个错误的\",{\"1\":{\"166\":1}}],[\"命令行参数可使用\",{\"1\":{\"156\":1}}],[\"命令式\",{\"1\":{\"85\":1}}],[\"命令加上\",{\"1\":{\"38\":1}}],[\"年\",{\"1\":{\"261\":1}}],[\"年龄认证\",{\"1\":{\"99\":1}}],[\"仿照\",{\"1\":{\"257\":1}}],[\"简洁\",{\"1\":{\"256\":1}}],[\"简介\",{\"1\":{\"0\":1}}],[\"咱们会为它实现\",{\"1\":{\"256\":1}}],[\"导入\",{\"1\":{\"256\":2,\"310\":1}}],[\"导入共用模块\",{\"1\":{\"173\":1}}],[\"采用\",{\"1\":{\"256\":1}}],[\"采用泛型意味着仔细地指定泛型类型具体化时\",{\"1\":{\"11\":1}}],[\"美化打印\",{\"1\":{\"254\":2}}],[\"假如我只想展示一个\",{\"1\":{\"254\":1}}],[\"假设标准库对所有的\",{\"1\":{\"256\":1}}],[\"假设我们希望程序有一个很棒的命令行界面\",{\"1\":{\"44\":1}}],[\"假设我们要在同一个项目中有两个二进制可执行文件\",{\"1\":{\"43\":1}}],[\"假设传入的指针指向有效的内存\",{\"1\":{\"34\":1}}],[\"推导了一个尽可能短的生命周期\",{\"1\":{\"272\":1}}],[\"推导出\",{\"1\":{\"256\":1}}],[\"推导\",{\"1\":{\"254\":1}}],[\"应当赋给\",{\"1\":{\"298\":1}}],[\"应当会在此处被销毁\",{\"1\":{\"148\":1}}],[\"应得到如下的输出结果\",{\"1\":{\"252\":1}}],[\"°\",{\"1\":{\"251\":2}}],[\"经度\",{\"1\":{\"251\":1}}],[\"经典的\",{\"1\":{\"60\":1}}],[\"纬度\",{\"1\":{\"251\":1}}],[\"反过来也一样\",{\"1\":{\"247\":1}}],[\"蓝松鸟\",{\"1\":{\"247\":1}}],[\"增加了代码的可读性\",{\"1\":{\"246\":1}}],[\"增加一个函数\",{\"1\":{\"61\":1}}],[\"增加一个计算\",{\"1\":{\"61\":1}}],[\"增加一个参数\",{\"1\":{\"43\":1}}],[\"增加一个属性来消除警告\",{\"1\":{\"39\":1}}],[\"鉴于此\",{\"1\":{\"244\":1}}],[\"容器\",{\"1\":{\"244\":1}}],[\"未包含引用\",{\"1\":{\"266\":1}}],[\"未显式地要求\",{\"1\":{\"244\":2}}],[\"未实现\",{\"1\":{\"89\":2}}],[\"检验上面例子的输出\",{\"1\":{\"257\":1}}],[\"检验效果\",{\"1\":{\"251\":1}}],[\"检验左右两边是否\",{\"1\":{\"174\":1}}],[\"检查给定的\",{\"1\":{\"244\":1,\"246\":1}}],[\"决定的\",{\"1\":{\"244\":1}}],[\"究竟是什么类型是由输入\",{\"1\":{\"244\":1}}],[\"匿名的闭包的类型是未知的\",{\"1\":{\"242\":1}}],[\"满足\",{\"1\":{\"240\":1}}],[\"换成\",{\"1\":{\"240\":1}}],[\"换句话说\",{\"1\":{\"5\":1}}],[\"顺序之所以是这样\",{\"1\":{\"240\":1}}],[\"明确了闭包如何从周围的作用域中捕获变量\",{\"1\":{\"238\":1}}],[\"限定的泛型\",{\"1\":{\"238\":1}}],[\"进一步处理就可以使用\",{\"1\":{\"235\":1}}],[\"进行迭代\",{\"1\":{\"310\":1}}],[\"进行尝试\",{\"1\":{\"310\":1}}],[\"进行可变借用\",{\"1\":{\"261\":1}}],[\"进行匹配\",{\"1\":{\"205\":1}}],[\"进行接收\",{\"1\":{\"156\":1}}],[\"进行格式化\",{\"1\":{\"107\":1}}],[\"进行交互\",{\"1\":{\"67\":2}}],[\"既然闭包可以作为参数\",{\"1\":{\"238\":1}}],[\"既然斐波那契数列不存在终点\",{\"1\":{\"186\":1}}],[\"既可移动\",{\"1\":{\"235\":1}}],[\"过于不明确\",{\"1\":{\"233\":1}}],[\"过滤掉为\",{\"1\":{\"64\":1}}],[\"三种\",{\"1\":{\"233\":1}}],[\"观察是否出错\",{\"1\":{\"310\":1}}],[\"观察一下使用闭包作为函数参数\",{\"1\":{\"233\":1}}],[\"观察块注释是如何简单地对表达式进行修改的\",{\"1\":{\"105\":1}}],[\"变体\",{\"1\":{\"228\":1}}],[\"变量在这里立即移动到了闭包中\",{\"1\":{\"235\":1}}],[\"变量中\",{\"1\":{\"235\":1}}],[\"变量可以手动使用\",{\"1\":{\"183\":1}}],[\"变量可以给出类型说明\",{\"1\":{\"21\":1}}],[\"变量指针位置的值来生成\",{\"1\":{\"144\":1}}],[\"变量内容会转化成字符串\",{\"1\":{\"107\":1}}],[\"变量是这个类型\",{\"1\":{\"84\":1}}],[\"变量解引用\",{\"1\":{\"83\":1}}],[\"变量的类型为\",{\"1\":{\"84\":1}}],[\"变量的类型并不能改变\",{\"1\":{\"21\":1}}],[\"变量的闭包如下\",{\"1\":{\"83\":1}}],[\"变量匹配\",{\"1\":{\"76\":1}}],[\"变量都得显式地声明\",{\"1\":{\"55\":1}}],[\"变量都能够显式地给出类型说明\",{\"1\":{\"21\":1}}],[\"变量\",{\"1\":{\"21\":1,\"55\":1,\"76\":3,\"235\":1}}],[\"变量遮蔽\",{\"1\":{\"15\":1,\"22\":1}}],[\"变量先声明\",{\"0\":{\"196\":1},\"1\":{\"0\":1}}],[\"变量绑定有一个作用域\",{\"1\":{\"199\":1}}],[\"变量绑定默认是不可变的\",{\"1\":{\"198\":1}}],[\"变量绑定可以在声明时说明类型\",{\"1\":{\"35\":1}}],[\"变量绑定\",{\"0\":{\"35\":1},\"1\":{\"0\":1,\"8\":1,\"15\":2,\"196\":1}}],[\"符号用法绑定\",{\"1\":{\"301\":1}}],[\"符号\",{\"1\":{\"263\":1}}],[\"符号来绑定变量到名称\",{\"1\":{\"228\":1}}],[\"符号会导致编译失败\",{\"1\":{\"171\":1}}],[\"外层循环\",{\"1\":{\"226\":1}}],[\"外部的测试\",{\"1\":{\"173\":1}}],[\"外部语言函数必须在一个\",{\"1\":{\"159\":1}}],[\"外部语言函数接口\",{\"0\":{\"159\":1},\"1\":{\"0\":1}}],[\"修改\",{\"1\":{\"281\":1}}],[\"修改了上一节中的返回类型\",{\"1\":{\"225\":1}}],[\"修饰语后变量就可以改变\",{\"1\":{\"198\":1}}],[\"修饰语来改变默认可见性\",{\"1\":{\"133\":1}}],[\"修饰语来重载这一行为\",{\"1\":{\"133\":1}}],[\"修饰语来重载该行为\",{\"1\":{\"129\":1}}],[\"稳定的\",{\"1\":{\"225\":1}}],[\"首先\",{\"1\":{\"225\":1}}],[\"首先将代码构建为库\",{\"1\":{\"118\":1}}],[\"回忆一下\",{\"1\":{\"223\":1}}],[\"回想一下\",{\"1\":{\"110\":1,\"306\":1}}],[\"出现以前\",{\"1\":{\"222\":1}}],[\"出版书名为\",{\"1\":{\"15\":1}}],[\"几乎\",{\"1\":{\"221\":1}}],[\"烹饪食物\",{\"1\":{\"217\":1}}],[\"削皮\",{\"1\":{\"217\":1}}],[\"轻松取代了前面的所有函数\",{\"1\":{\"217\":1}}],[\"立即得到内部值\",{\"1\":{\"211\":1}}],[\"串起来\",{\"1\":{\"211\":1,\"217\":1}}],[\"遗憾的是\",{\"1\":{\"211\":1}}],[\"映射\",{\"1\":{\"211\":1}}],[\"坏的例子\",{\"1\":{\"209\":2}}],[\"向量\",{\"1\":{\"295\":1}}],[\"向用户提供了清楚的错误信息\",{\"1\":{\"209\":1}}],[\"向它传入指向第一个元素的指针和长度参数\",{\"1\":{\"34\":1}}],[\"好的例子\",{\"1\":{\"209\":2}}],[\"好的\",{\"1\":{\"209\":1}}],[\"又要求闭包通过值获取\",{\"1\":{\"240\":1}}],[\"又可借用\",{\"1\":{\"235\":1}}],[\"又想保存原始错误信息\",{\"1\":{\"207\":1}}],[\"又有一点和\",{\"1\":{\"16\":1}}],[\"递归的\",{\"1\":{\"205\":1}}],[\"递归地创建一个目录\",{\"1\":{\"161\":1}}],[\"递归地拆解多重的\",{\"1\":{\"116\":1}}],[\"末结点\",{\"1\":{\"205\":1}}],[\"各个名称使他们直接可用\",{\"1\":{\"203\":1}}],[\"各个取值不同\",{\"1\":{\"57\":1}}],[\"遮蔽\",{\"1\":{\"197\":1,\"199\":2}}],[\"初始化一个绑定\",{\"1\":{\"196\":1}}],[\"写法\",{\"1\":{\"293\":1}}],[\"写法是\",{\"1\":{\"195\":1}}],[\"写\",{\"1\":{\"288\":1}}],[\"写数据\",{\"1\":{\"261\":1}}],[\"写一个\",{\"1\":{\"137\":1}}],[\"心急的读者可以看看下面的简短解释\",{\"1\":{\"195\":1}}],[\"啊哈\",{\"1\":{\"194\":1}}],[\"章节中详细介绍\",{\"1\":{\"256\":1}}],[\"章节\",{\"1\":{\"190\":1}}],[\"加法正常执行\",{\"1\":{\"249\":1}}],[\"加起来的\",{\"1\":{\"187\":1}}],[\"加上配对中括号\",{\"1\":{\"310\":1}}],[\"加上逗号\",{\"1\":{\"310\":1}}],[\"加上\",{\"1\":{\"137\":1}}],[\"直到对这些数据的所有引用离开作用域为止\",{\"1\":{\"260\":1}}],[\"直到最高有效位\",{\"1\":{\"193\":1}}],[\"直到值位于新类型\",{\"1\":{\"193\":1}}],[\"直到返回\",{\"1\":{\"186\":1}}],[\"直接解析\",{\"1\":{\"42\":1}}],[\"斐波那契\",{\"1\":{\"186\":1}}],[\"某些\",{\"1\":{\"185\":1}}],[\"某些情况下也可使用\",{\"1\":{\"89\":1}}],[\"手动调用\",{\"1\":{\"240\":1}}],[\"手动\",{\"1\":{\"183\":1}}],[\"手动使用\",{\"1\":{\"68\":1}}],[\"何时需要调用这些方法呢\",{\"1\":{\"181\":1}}],[\"他们甚至可能有不同的返回类型\",{\"1\":{\"181\":1}}],[\"许多\",{\"1\":{\"181\":1}}],[\"计算该段的每一位的和\",{\"1\":{\"293\":1}}],[\"计算其乘积\",{\"1\":{\"225\":1}}],[\"计算机科学的学生\",{\"1\":{\"189\":1}}],[\"计算哈希值\",{\"1\":{\"179\":1}}],[\"计数器值加\",{\"1\":{\"80\":1}}],[\"计数器变量\",{\"1\":{\"80\":1}}],[\"比\",{\"1\":{\"199\":1}}],[\"比较\",{\"1\":{\"179\":1}}],[\"比如使用\",{\"1\":{\"210\":1}}],[\"比如指定字面量\",{\"1\":{\"195\":1}}],[\"比如数组\",{\"1\":{\"186\":1}}],[\"比如创建文件\",{\"1\":{\"173\":1}}],[\"比如测试\",{\"1\":{\"170\":1}}],[\"比如基准测试相关的\",{\"1\":{\"168\":1}}],[\"比如在数组或区间中\",{\"1\":{\"186\":1}}],[\"比如在\",{\"1\":{\"134\":1}}],[\"比如lazy\",{\"1\":{\"112\":1}}],[\"比如说使用\",{\"1\":{\"168\":1}}],[\"比如说我想要定义一套小的计算器\",{\"1\":{\"112\":1}}],[\"比如说\",{\"1\":{\"99\":1,\"116\":1}}],[\"比如说寻找\",{\"1\":{\"7\":1}}],[\"比如代码生成或者需要编译的一些本地代码\",{\"1\":{\"41\":1}}],[\"比如字面量\",{\"1\":{\"35\":1}}],[\"比如一个未声明类型整数和\",{\"1\":{\"21\":1}}],[\"比如println\",{\"1\":{\"16\":1}}],[\"比如\",{\"1\":{\"7\":1,\"47\":1,\"63\":1,\"76\":1,\"135\":1,\"141\":1,\"187\":1,\"191\":1,\"251\":1,\"254\":1}}],[\"得出最终结果\",{\"1\":{\"293\":1}}],[\"得来的结果仍然可用\",{\"1\":{\"178\":1}}],[\"得到最终结果\",{\"1\":{\"293\":1}}],[\"得到最后一个数字\",{\"1\":{\"244\":1,\"246\":1}}],[\"得到实现\",{\"1\":{\"256\":1}}],[\"得到第一个数字\",{\"1\":{\"244\":1,\"246\":1}}],[\"得到\",{\"1\":{\"228\":1}}],[\"得到类型\",{\"1\":{\"46\":1}}],[\"得到下面结果\",{\"1\":{\"14\":1}}],[\"已冻结的数据无法通过原始对象来修改\",{\"1\":{\"260\":1}}],[\"已经获得了\",{\"1\":{\"298\":1}}],[\"已经实现了\",{\"1\":{\"249\":1}}],[\"已经为\",{\"1\":{\"225\":1}}],[\"已经在\",{\"1\":{\"193\":1}}],[\"已经移入\",{\"1\":{\"149\":1}}],[\"已被销毁\",{\"1\":{\"178\":1}}],[\"已失去了它的资源\",{\"1\":{\"178\":1}}],[\"赋值\",{\"1\":{\"295\":1}}],[\"赋值语句中左边的\",{\"1\":{\"263\":1}}],[\"赋予测试以排除某些测试\",{\"1\":{\"177\":1}}],[\"赋给\",{\"1\":{\"8\":1}}],[\"源文件都被编译成一个单独的\",{\"1\":{\"173\":1}}],[\"隐藏行包围了文档中显示的函数体\",{\"1\":{\"171\":1}}],[\"隐式地标注了生命周期\",{\"1\":{\"266\":1}}],[\"隐式地提供的\",{\"1\":{\"200\":1}}],[\"隐式地指定类型参数\",{\"1\":{\"91\":3}}],[\"隐式地处理\",{\"1\":{\"68\":2}}],[\"隐式处理要么返回\",{\"1\":{\"68\":1}}],[\"听起来很复杂\",{\"1\":{\"171\":1}}],[\"部分借用产生\",{\"1\":{\"282\":1}}],[\"部分的实现\",{\"1\":{\"213\":1}}],[\"部分\",{\"1\":{\"168\":1}}],[\"部分移动值的借用\",{\"1\":{\"282\":1}}],[\"部分移动\",{\"0\":{\"282\":1},\"1\":{\"0\":1}}],[\"启动\",{\"1\":{\"167\":1,\"291\":1}}],[\"启用编译器的特性\",{\"1\":{\"1\":1}}],[\"记录迭代次数\",{\"1\":{\"310\":1}}],[\"记得查阅文档\",{\"1\":{\"286\":1}}],[\"记得看看其他的\",{\"1\":{\"164\":1}}],[\"记住\",{\"1\":{\"153\":1}}],[\"记住这句话\",{\"1\":{\"32\":1}}],[\"针对\",{\"1\":{\"164\":1}}],[\"针对类\",{\"1\":{\"164\":1}}],[\"删除\",{\"1\":{\"293\":1}}],[\"删除一个文件\",{\"1\":{\"161\":1}}],[\"删除注释分隔符将会改变结果\",{\"1\":{\"105\":1}}],[\"忽略\",{\"1\":{\"300\":1}}],[\"忽略测试\",{\"0\":{\"177\":1}}],[\"忽略已存在的文件\",{\"1\":{\"161\":1}}],[\"忽略失败的项\",{\"0\":{\"64\":1}}],[\"封装\",{\"1\":{\"159\":1}}],[\"封装了一个\",{\"1\":{\"147\":1}}],[\"操作符\",{\"1\":{\"310\":1}}],[\"操作的失败都变成显式内容\",{\"1\":{\"163\":1}}],[\"操作的失败都变成显式的\",{\"1\":{\"160\":1}}],[\"操作时很多情形都可能出现错误\",{\"1\":{\"163\":1}}],[\"操作时可能出现各种错误\",{\"1\":{\"160\":1}}],[\"操作\",{\"1\":{\"158\":1}}],[\"操作可能失败\",{\"1\":{\"63\":1}}],[\"端可被复制\",{\"1\":{\"158\":1}}],[\"发送是一个非阻塞\",{\"1\":{\"158\":1}}],[\"发送端\",{\"1\":{\"158\":1}}],[\"发散函数\",{\"0\":{\"84\":1},\"1\":{\"0\":1,\"84\":1}}],[\"展示了使用最流行的命令行参数\",{\"1\":{\"157\":1}}],[\"超出下标范围将抛出一个\",{\"1\":{\"154\":1}}],[\"保留多少内存\",{\"1\":{\"154\":1}}],[\"保证其运行速度足够快\",{\"1\":{\"17\":1}}],[\"ようこそ\",{\"1\":{\"153\":1}}],[\"转成\",{\"1\":{\"193\":1}}],[\"转化成\",{\"1\":{\"164\":1}}],[\"转义字符\",{\"1\":{\"153\":1}}],[\"转换成一个字符串\",{\"1\":{\"110\":1}}],[\"转换成字符串\",{\"1\":{\"110\":1}}],[\"转换成\",{\"1\":{\"47\":1}}],[\"转换为类型\",{\"1\":{\"46\":1}}],[\"转换到别的类型\",{\"1\":{\"4\":1}}],[\"码位表示\",{\"1\":{\"153\":1}}],[\"像元组一样\",{\"1\":{\"300\":1}}],[\"像这样\",{\"1\":{\"153\":1}}],[\"像是camelcase\",{\"1\":{\"191\":1}}],[\"像是\",{\"1\":{\"11\":1}}],[\"书写含有特殊字符的字符串字面量有很多种方法\",{\"1\":{\"153\":1}}],[\"逆序迭代单词\",{\"1\":{\"152\":1}}],[\"序列的切片\",{\"1\":{\"152\":1}}],[\"序列\",{\"1\":{\"152\":1,\"153\":1}}],[\"金字塔\",{\"1\":{\"151\":1}}],[\"克隆到\",{\"1\":{\"178\":1}}],[\"克隆只创建另一个指向包裹值的指针\",{\"1\":{\"149\":1}}],[\"克隆\",{\"1\":{\"149\":1}}],[\"退出作用域时\",{\"1\":{\"149\":1}}],[\"退出循环\",{\"1\":{\"78\":1}}],[\"每段都是完整数据的一个引用\",{\"1\":{\"293\":1}}],[\"每段将会单独计算\",{\"1\":{\"293\":1}}],[\"每种参数类型都对应一种\",{\"1\":{\"251\":1}}],[\"每当在堆上分配内存时\",{\"1\":{\"184\":1}}],[\"每当克隆一个\",{\"1\":{\"149\":1}}],[\"每个代码块中\",{\"1\":{\"293\":1}}],[\"每个用空白符隔开的块都会分配给单独的线程来处理\",{\"1\":{\"293\":1}}],[\"每个线程会把自己那一块数字的每一位加起来\",{\"1\":{\"293\":1}}],[\"每个线程都把消息放在通道的消息队列中\",{\"1\":{\"158\":1}}],[\"每个线程都将通过通道来发送它的\",{\"1\":{\"158\":1}}],[\"每个闭包都有自己未命名的具体类型\",{\"1\":{\"185\":1}}],[\"每个分支都必须以分号结束\",{\"1\":{\"113\":1}}],[\"每个都是\",{\"1\":{\"20\":1}}],[\"值增加\",{\"1\":{\"235\":1}}],[\"值\",{\"1\":{\"228\":1,\"310\":1}}],[\"值都被解包\",{\"1\":{\"186\":1}}],[\"值的所有者的数量\",{\"1\":{\"149\":1}}],[\"值可以进行模式匹配\",{\"1\":{\"147\":1}}],[\"跟踪引用的数量\",{\"1\":{\"149\":1}}],[\"跟默认情况不同\",{\"1\":{\"41\":1}}],[\"除此之外\",{\"1\":{\"242\":1}}],[\"除去写法外\",{\"1\":{\"225\":1}}],[\"除以\",{\"1\":{\"148\":1}}],[\"除了法国蓝带猪排\",{\"1\":{\"215\":1}}],[\"除了返回类型是\",{\"1\":{\"211\":1}}],[\"除了\",{\"1\":{\"193\":1}}],[\"除了可添加其他二进制可执行文件外\",{\"1\":{\"43\":1}}],[\"除了表示类型\",{\"1\":{\"11\":1}}],[\"想要非\",{\"1\":{\"153\":1}}],[\"想要了解更多关于散列\",{\"1\":{\"146\":1}}],[\"想获取这些例子外的更多内容\",{\"1\":{\"15\":1}}],[\"k\",{\"1\":{\"296\":2}}],[\"keeps\",{\"1\":{\"292\":1}}],[\"keypress\",{\"1\":{\"57\":3}}],[\"keyword\",{\"1\":{\"40\":2}}],[\"key\",{\"1\":{\"1\":1,\"146\":2,\"296\":1}}],[\"kaboom\",{\"1\":{\"231\":1}}],[\"katie\",{\"1\":{\"146\":1}}],[\"kind\",{\"1\":{\"161\":9}}],[\"矩形\",{\"1\":{\"145\":1}}],[\"堆分配一个字符串\",{\"1\":{\"152\":1}}],[\"堆分配的整数\",{\"1\":{\"148\":1}}],[\"堆分配的\",{\"1\":{\"145\":1}}],[\"堆分配的指针\",{\"1\":{\"24\":1}}],[\"堆上分配的内存也会被释放\",{\"1\":{\"145\":1}}],[\"缩写\",{\"1\":{\"144\":1,\"149\":1}}],[\"缩写成\",{\"1\":{\"60\":1}}],[\"看起来像这样\",{\"1\":{\"310\":1}}],[\"看下面的例子\",{\"1\":{\"266\":1,\"275\":1}}],[\"看看输出会怎样变化\",{\"1\":{\"293\":1}}],[\"看看会发生什么\",{\"1\":{\"240\":1,\"293\":1}}],[\"看看哪个更容易\",{\"1\":{\"219\":1}}],[\"看看它多么简单\",{\"1\":{\"185\":1}}],[\"看看它的返回类型多么复杂\",{\"1\":{\"185\":1}}],[\"看看\",{\"1\":{\"142\":1}}],[\"看到了吧\",{\"1\":{\"112\":1}}],[\"析构函数\",{\"0\":{\"142\":1}}],[\"资源获取即初始化\",{\"1\":{\"141\":1}}],[\"资源的所有权\",{\"1\":{\"140\":1}}],[\"占有堆\",{\"1\":{\"141\":1}}],[\"移动或重新借用都是允许的\",{\"1\":{\"235\":1}}],[\"移动语义\",{\"1\":{\"179\":1}}],[\"移动\",{\"1\":{\"140\":1,\"178\":1,\"281\":1}}],[\"移除上面那个属性\",{\"1\":{\"191\":1}}],[\"移除一个空目录\",{\"1\":{\"161\":1}}],[\"移除\",{\"1\":{\"73\":1,\"154\":1}}],[\"移除类型标注\",{\"1\":{\"30\":1}}],[\"栈分配的变量\",{\"1\":{\"145\":1}}],[\"栈分配的整型\",{\"1\":{\"140\":1}}],[\"栈和堆\",{\"0\":{\"145\":1},\"1\":{\"0\":1}}],[\"─────────────────────────────────────┘\",{\"1\":{\"139\":1}}],[\"──────────────────────────────────┘│\",{\"1\":{\"139\":1}}],[\"─────────────────────────────────┘│\",{\"1\":{\"139\":1}}],[\"────────────────┐\",{\"1\":{\"139\":1}}],[\"──┐│\",{\"1\":{\"139\":2}}],[\"确实使这些内容可以打印\",{\"1\":{\"254\":1}}],[\"确实可以\",{\"1\":{\"238\":1}}],[\"确实有\",{\"1\":{\"233\":1}}],[\"确切地说\",{\"1\":{\"139\":1}}],[\"确保库准确地实现了你想要的功能\",{\"1\":{\"17\":1}}],[\"离开作用域时\",{\"1\":{\"275\":1}}],[\"离开作用域\",{\"1\":{\"197\":1,\"235\":1,\"260\":1,\"289\":1}}],[\"离开作用域且不再被借用\",{\"1\":{\"138\":1}}],[\"离开作用域后释放\",{\"1\":{\"86\":1}}],[\"销毁\",{\"1\":{\"138\":1,\"183\":1}}],[\"静态地保证了引用总是指向有效的对象\",{\"1\":{\"138\":1}}],[\"静态方法能够以只读模式\",{\"1\":{\"289\":1}}],[\"静态方法以只写模式\",{\"1\":{\"288\":1}}],[\"静态方法使用双冒号调用\",{\"1\":{\"86\":1}}],[\"静态方法不需要被实例调用\",{\"1\":{\"86\":1}}],[\"机制\",{\"1\":{\"138\":1}}],[\"左下对角线上的两元素交换后的\",{\"1\":{\"137\":1}}],[\"阅读编译器给出的错误信息\",{\"1\":{\"136\":1}}],[\"体会为什么类型声明这么重要\",{\"1\":{\"135\":1}}],[\"八进制或二进制记法表示\",{\"1\":{\"135\":1}}],[\"布尔值\",{\"1\":{\"135\":1}}],[\"布尔型\",{\"1\":{\"20\":1}}],[\"越界的下标会引发致命错误\",{\"1\":{\"134\":1}}],[\"下文改变了\",{\"1\":{\"240\":1}}],[\"下一个\",{\"1\":{\"186\":2}}],[\"下标使用中括号表示\",{\"1\":{\"154\":1}}],[\"下标从\",{\"1\":{\"134\":1}}],[\"下面代码展示了一些省略的例子\",{\"1\":{\"264\":1}}],[\"下面两种中的一种吗\",{\"1\":{\"256\":1}}],[\"下面给出一个简短的示例来展示语法\",{\"1\":{\"223\":1}}],[\"下面例子展示了上述语法的实际应用\",{\"1\":{\"270\":1}}],[\"下面例子展示了一些合法的带有生命周期的函数\",{\"1\":{\"268\":1}}],[\"下面例子展示了如何使用\",{\"1\":{\"186\":1}}],[\"下面例子展示了泛型语法的使用\",{\"1\":{\"11\":1}}],[\"下面示例给\",{\"1\":{\"183\":1}}],[\"下面是所希望的成功的输出\",{\"1\":{\"289\":1}}],[\"下面是所期望的成功的输出\",{\"1\":{\"161\":1}}],[\"下面是预期成功的输出\",{\"1\":{\"288\":1}}],[\"下面是可以自动派生的\",{\"1\":{\"179\":1}}],[\"下面是个快速入门示例\",{\"1\":{\"141\":1}}],[\"下面是一些使用\",{\"1\":{\"119\":1}}],[\"下面是一个简单的示例\",{\"1\":{\"44\":1}}],[\"下面使用连线来标注各个变量的创建和销毁\",{\"1\":{\"139\":1}}],[\"下面一些注释没有翻译\",{\"1\":{\"139\":1}}],[\"下面语句无法运行\",{\"1\":{\"107\":1}}],[\"下面语句输出\",{\"1\":{\"107\":1}}],[\"下面全部函数都得到了变量的所有权\",{\"1\":{\"91\":1}}],[\"下面这行将得到一个引用\",{\"1\":{\"298\":1}}],[\"下面这行是使用函数的实现\",{\"1\":{\"83\":1}}],[\"下面这个函数相反\",{\"1\":{\"84\":1}}],[\"下面的代码无法编译\",{\"1\":{\"300\":1}}],[\"下面的代码块实现了\",{\"1\":{\"187\":2}}],[\"下面的调用全部都返回一个迭代器\",{\"1\":{\"285\":1}}],[\"下面的例子展示了几个实例\",{\"1\":{\"263\":1}}],[\"下面的函数将两数相除\",{\"1\":{\"170\":1}}],[\"下面的\",{\"1\":{\"44\":1,\"298\":1}}],[\"下面创建一个新的\",{\"1\":{\"44\":1}}],[\"位整数\",{\"1\":{\"293\":1}}],[\"位操作的\",{\"1\":{\"193\":1}}],[\"位运算\",{\"1\":{\"135\":1}}],[\"位有符号整数\",{\"1\":{\"135\":1}}],[\"位无符号整数\",{\"1\":{\"135\":1}}],[\"位\",{\"1\":{\"134\":1,\"193\":1,\"252\":1}}],[\"平台上就是\",{\"1\":{\"134\":1}}],[\"平民\",{\"1\":{\"68\":1}}],[\"第二个字是切片的长度\",{\"1\":{\"134\":1}}],[\"第一行是对函数的简短描述\",{\"1\":{\"170\":1}}],[\"第一个元素除外\",{\"1\":{\"310\":1}}],[\"第一个参数是调用本程序的路径\",{\"1\":{\"156\":1}}],[\"第一个字是一个指向数据的指针\",{\"1\":{\"134\":1}}],[\"第一个匹配分支会被比对\",{\"1\":{\"79\":1}}],[\"第一版和第二版都只有\",{\"1\":{\"87\":1}}],[\"第一次使用类型\",{\"1\":{\"11\":1}}],[\"相应地\",{\"1\":{\"298\":1}}],[\"相比\",{\"1\":{\"211\":1}}],[\"相比于直接返回一个\",{\"1\":{\"184\":1}}],[\"相当于给\",{\"1\":{\"193\":1}}],[\"相加的函数\",{\"1\":{\"185\":1}}],[\"相等\",{\"1\":{\"149\":1,\"174\":1}}],[\"相同的生命周期\",{\"1\":{\"268\":1}}],[\"相同的功能是使用\",{\"1\":{\"222\":1}}],[\"相同\",{\"1\":{\"134\":1}}],[\"相反\",{\"1\":{\"134\":1,\"228\":1,\"261\":1}}],[\"相关的\",{\"1\":{\"104\":1}}],[\"说\",{\"1\":{\"118\":1}}],[\"示例\",{\"1\":{\"118\":1}}],[\"人\",{\"1\":{\"118\":1}}],[\"仅当最后一次使用可变引用之后\",{\"1\":{\"259\":1}}],[\"仅当根据环境无法推断时\",{\"1\":{\"21\":1}}],[\"仅将\",{\"1\":{\"256\":1}}],[\"仅有一些类型提供了自动实现\",{\"1\":{\"254\":1}}],[\"仅用于测试\",{\"1\":{\"168\":1}}],[\"仅运行文档测试\",{\"1\":{\"117\":1}}],[\"运算符用在返回值为\",{\"1\":{\"286\":1}}],[\"运算符可以把这种逻辑变得干净漂亮\",{\"1\":{\"286\":1}}],[\"运算符可以被任何\",{\"1\":{\"187\":1}}],[\"运算符的行为\",{\"1\":{\"249\":1}}],[\"运算符\",{\"0\":{\"286\":1},\"1\":{\"222\":1}}],[\"运算符通常会更容易\",{\"1\":{\"219\":1}}],[\"运算符会调用\",{\"1\":{\"187\":1}}],[\"运算符进行解引用\",{\"1\":{\"145\":1}}],[\"运算符重载\",{\"0\":{\"187\":1},\"1\":{\"0\":1}}],[\"运行此程序将一行行将内容打印出来\",{\"1\":{\"290\":1}}],[\"运行特定的测试\",{\"0\":{\"176\":1}}],[\"运行这些测试会输出\",{\"1\":{\"175\":1}}],[\"运行我们想要测试的代码\",{\"1\":{\"174\":1}}],[\"运行时将会释放该线程所拥有的所有资源\",{\"1\":{\"148\":1}}],[\"运行下列例子\",{\"1\":{\"142\":1}}],[\"运行所有测试\",{\"1\":{\"117\":1}}],[\"构建文档到\",{\"1\":{\"117\":1}}],[\"构建脚本只是另一个\",{\"1\":{\"42\":1}}],[\"构建脚本\",{\"0\":{\"41\":1},\"1\":{\"0\":1}}],[\"妈妈快看\",{\"1\":{\"116\":1}}],[\"们调用\",{\"1\":{\"114\":1}}],[\"们见多识广\",{\"1\":{\"68\":1}}],[\"基准情形\",{\"1\":{\"205\":1}}],[\"基准测试\",{\"1\":{\"17\":1}}],[\"基本的概念有三个\",{\"1\":{\"115\":1}}],[\"基本情形\",{\"1\":{\"114\":1}}],[\"强制实行\",{\"1\":{\"141\":1}}],[\"强制类型为整型\",{\"1\":{\"112\":1}}],[\"强制转换得到的结果\",{\"1\":{\"272\":1}}],[\"强制转换可由编译器隐式地推导并执行\",{\"1\":{\"272\":1}}],[\"强制转换\",{\"0\":{\"272\":1},\"1\":{\"0\":1}}],[\"意思为\",{\"1\":{\"111\":1}}],[\"完整实现\",{\"1\":{\"249\":1}}],[\"完整列表详见\",{\"1\":{\"110\":1}}],[\"完全限定语法\",{\"1\":{\"182\":1}}],[\"完全没有泄漏\",{\"1\":{\"141\":1}}],[\"完全不需要手动释放内存\",{\"1\":{\"141\":1}}],[\"完成\",{\"1\":{\"292\":1}}],[\"完成这项工作的标准手段是用\",{\"1\":{\"51\":1}}],[\"完成上述命令后\",{\"1\":{\"44\":1}}],[\"连同其结果一起\",{\"1\":{\"110\":1}}],[\"连接起来会显得很难看\",{\"1\":{\"286\":1}}],[\"连接\",{\"1\":{\"97\":1}}],[\"借此推断类型\",{\"1\":{\"194\":1}}],[\"借助这点\",{\"1\":{\"160\":1,\"163\":1}}],[\"借助上述宏来创建名为\",{\"1\":{\"110\":1}}],[\"借用检查器使用显式的生命周期标记来明确引用的有效时间应该持续多久\",{\"1\":{\"266\":1}}],[\"借用者可以读数据而不能更改数据\",{\"1\":{\"261\":1}}],[\"借用的作用域则是由使用引用的位置决定的\",{\"1\":{\"139\":1}}],[\"借用就是有效的\",{\"1\":{\"139\":1}}],[\"借用了\",{\"1\":{\"138\":1}}],[\"借用集合中的每个元素\",{\"1\":{\"73\":1}}],[\"借用\",{\"0\":{\"138\":1},\"1\":{\"0\":1,\"15\":1,\"23\":1,\"260\":1}}],[\"再次注意到没有用完整路径\",{\"1\":{\"203\":1}}],[\"再试试上面的例子\",{\"1\":{\"166\":1}}],[\"再用另一个反斜杠来转义它就可以\",{\"1\":{\"153\":1}}],[\"再用一个\",{\"1\":{\"108\":1}}],[\"再一次使用宏\",{\"1\":{\"14\":1}}],[\"输出包裹在\",{\"1\":{\"290\":1}}],[\"输出结果要求是这个样子\",{\"1\":{\"257\":1}}],[\"输出结果\",{\"1\":{\"137\":1}}],[\"输出结构体内容\",{\"1\":{\"108\":1}}],[\"输出\",{\"1\":{\"112\":1,\"116\":1,\"160\":1,\"163\":1,\"246\":1}}],[\"输入闭包\",{\"1\":{\"240\":1}}],[\"输入和返回类型两者都可以自动推导\",{\"1\":{\"83\":1}}],[\"输入\",{\"1\":{\"67\":1,\"160\":1,\"163\":1,\"246\":1}}],[\"输入函数\",{\"0\":{\"238\":1},\"1\":{\"0\":1}}],[\"尝试改变数组中的值\",{\"1\":{\"300\":1}}],[\"尝试自己编写一下\",{\"1\":{\"219\":1}}],[\"尝试借用\",{\"1\":{\"138\":1}}],[\"尝试将\",{\"1\":{\"135\":1}}],[\"尝试取消注释\",{\"1\":{\"108\":1}}],[\"尝试使用嵌套的解构方式\",{\"1\":{\"61\":1}}],[\"见\",{\"1\":{\"108\":2}}],[\"个线程吗\",{\"1\":{\"294\":1}}],[\"个项是否储存于容器中\",{\"1\":{\"244\":1,\"246\":1}}],[\"个变量\",{\"1\":{\"240\":1}}],[\"个词来表示\",{\"1\":{\"154\":1}}],[\"个\",{\"1\":{\"107\":1}}],[\"个空格和\",{\"1\":{\"107\":1}}],[\"及更高版本\",{\"1\":{\"107\":1}}],[\"j\",{\"1\":{\"284\":4,\"302\":3}}],[\"job\",{\"1\":{\"219\":5}}],[\"join\",{\"1\":{\"164\":2,\"167\":1,\"293\":1}}],[\"john\",{\"1\":{\"118\":3,\"284\":1}}],[\"jis\",{\"1\":{\"153\":3}}],[\"jay\",{\"1\":{\"247\":4}}],[\"java\",{\"1\":{\"135\":1}}],[\"james\",{\"1\":{\"107\":1}}],[\"jumped\",{\"1\":{\"291\":1}}],[\"jumps\",{\"1\":{\"107\":1,\"152\":1}}],[\"julian\",{\"1\":{\"141\":1,\"148\":1}}],[\"juliet\",{\"1\":{\"118\":1}}],[\"just\",{\"1\":{\"136\":1,\"183\":2}}],[\"补上漏掉的参数\",{\"1\":{\"107\":1}}],[\"补充\",{\"0\":{\"17\":1},\"1\":{\"0\":1,\"15\":1}}],[\"总宽度为5\",{\"1\":{\"107\":1}}],[\"总的来说\",{\"1\":{\"7\":1}}],[\"四个空格和一个\",{\"1\":{\"107\":1}}],[\"自动地\",{\"1\":{\"203\":1}}],[\"自动地在每个程序中导入的一些通用的东西\",{\"1\":{\"164\":1}}],[\"自身\",{\"1\":{\"131\":1}}],[\"自己试试\",{\"1\":{\"105\":1}}],[\"自定义格式\",{\"1\":{\"256\":1}}],[\"自定义的析构函数就会被调用\",{\"1\":{\"142\":1}}],[\"自定义数据类型主要是通过下面这两个关键字来创建\",{\"1\":{\"6\":1}}],[\"自定义条件\",{\"0\":{\"200\":1},\"1\":{\"0\":1}}],[\"自定义类型\",{\"0\":{\"6\":1},\"1\":{\"0\":1,\"15\":1}}],[\"嵌套作用域\",{\"1\":{\"141\":1}}],[\"嵌套模块的可见性遵循相同的规则\",{\"1\":{\"133\":1}}],[\"嵌套\",{\"1\":{\"105\":1}}],[\"嵌套循环和标签\",{\"0\":{\"226\":1},\"1\":{\"0\":1}}],[\"行中\",{\"1\":{\"107\":1}}],[\"行注释则不能这样\",{\"1\":{\"105\":1}}],[\"行注释是推荐的注释格式\",{\"1\":{\"105\":1}}],[\"行首需要\",{\"1\":{\"76\":1}}],[\"现在需要\",{\"1\":{\"240\":2}}],[\"现在年龄就可以读取了\",{\"1\":{\"228\":1}}],[\"现在使用模式匹配而不是\",{\"1\":{\"225\":1}}],[\"现在我们推荐使用\",{\"1\":{\"222\":1}}],[\"现在让我们试试看起来更简单的\",{\"1\":{\"217\":1}}],[\"现在让我们开始学习吧\",{\"1\":{\"15\":1}}],[\"现在编译器知道\",{\"1\":{\"194\":1}}],[\"现在编译器还不知道\",{\"1\":{\"194\":1}}],[\"现在两者都指向\",{\"1\":{\"140\":1}}],[\"现在可以将所有权交给\",{\"1\":{\"138\":1}}],[\"现在该项目通常称为\",{\"1\":{\"124\":1}}],[\"现在请将上述语句的两条斜线删掉\",{\"1\":{\"105\":1}}],[\"帮助文档\",{\"1\":{\"105\":1}}],[\"普通注释\",{\"1\":{\"105\":1}}],[\"支持代码块\",{\"1\":{\"170\":1}}],[\"支持几种不同的注释方式\",{\"1\":{\"105\":1}}],[\"支持这一点\",{\"1\":{\"43\":1}}],[\"q\",{\"1\":{\"101\":4,\"263\":1}}],[\"qualified\",{\"1\":{\"181\":1}}],[\"quotes\",{\"1\":{\"153\":3}}],[\"quotient\",{\"1\":{\"147\":2}}],[\"qui\",{\"1\":{\"288\":2}}],[\"quis\",{\"1\":{\"288\":2}}],[\"quick\",{\"1\":{\"107\":1,\"152\":1,\"291\":1}}],[\"quit\",{\"1\":{\"81\":2}}],[\"qux\",{\"1\":{\"76\":4}}],[\"虚类型\",{\"1\":{\"101\":1}}],[\"虚类型参数\",{\"0\":{\"101\":1},\"1\":{\"0\":1}}],[\"舍去不满一年的部分\",{\"1\":{\"99\":1}}],[\"能使用\",{\"1\":{\"254\":1}}],[\"能做功能要求的事情\",{\"1\":{\"235\":1}}],[\"能够格式化成不同的形式\",{\"1\":{\"251\":1}}],[\"能够灵活地适应用例\",{\"1\":{\"235\":1}}],[\"能够与其他错误很好地整合\",{\"1\":{\"209\":1}}],[\"能够容纳错误的具体信息\",{\"1\":{\"209\":1}}],[\"能够容易地与其他类型比较\",{\"1\":{\"209\":1}}],[\"能够解释失败的原因\",{\"1\":{\"151\":1}}],[\"能够销毁是因为已经不存在对\",{\"1\":{\"138\":1}}],[\"能够执行的操作当然也不同\",{\"1\":{\"73\":1}}],[\"能保证在编译时\",{\"1\":{\"99\":1}}],[\"隔开\",{\"1\":{\"97\":1}}],[\"去掉此行注释\",{\"1\":{\"140\":2,\"247\":1}}],[\"去掉此行的注释\",{\"1\":{\"86\":1}}],[\"去掉这两行的注释\",{\"1\":{\"93\":1}}],[\"释放\",{\"1\":{\"93\":1}}],[\"丢弃\",{\"1\":{\"93\":1}}],[\"多个不同的\",{\"1\":{\"217\":1}}],[\"多亏了\",{\"1\":{\"154\":1}}],[\"多数情况下\",{\"1\":{\"138\":1}}],[\"多讨厌她自己的名字\",{\"1\":{\"118\":1}}],[\"多说一句\",{\"1\":{\"89\":1,\"238\":1}}],[\"多重约束\",{\"0\":{\"97\":1},\"1\":{\"0\":1,\"97\":1}}],[\"必须存在于当前路径中\",{\"1\":{\"290\":1}}],[\"必须手动为类型实现\",{\"1\":{\"256\":1}}],[\"必须指出\",{\"1\":{\"244\":1}}],[\"必须指出闭包的完整类型\",{\"1\":{\"240\":1}}],[\"必须为一个没有输入参数和返回值的闭包实现\",{\"1\":{\"233\":1}}],[\"必须是\",{\"1\":{\"249\":1}}],[\"必须是泛型的\",{\"1\":{\"233\":1}}],[\"必须是父模块\",{\"1\":{\"133\":1}}],[\"必须对\",{\"1\":{\"205\":1}}],[\"必须在堆上进行分配才能返回闭包\",{\"1\":{\"185\":1}}],[\"必须在类型之前写出来\",{\"1\":{\"95\":1}}],[\"必须实现\",{\"1\":{\"89\":3}}],[\"必须有\",{\"1\":{\"76\":1}}],[\"做法\",{\"1\":{\"87\":1}}],[\"联系起来的\",{\"1\":{\"87\":1}}],[\"亦即\",{\"1\":{\"86\":1}}],[\"消息并退出\",{\"1\":{\"148\":1}}],[\"消耗了该变量\",{\"1\":{\"235\":1}}],[\"消耗了\",{\"1\":{\"86\":1}}],[\"消耗\",{\"1\":{\"86\":1}}],[\"消除重叠\",{\"0\":{\"181\":1},\"1\":{\"0\":1}}],[\"都要生成一个\",{\"1\":{\"310\":1}}],[\"都要求实现至少一个可打印的\",{\"1\":{\"254\":1}}],[\"都必须比\",{\"1\":{\"270\":2}}],[\"都必须是合法的\",{\"1\":{\"153\":1}}],[\"都传进函数\",{\"1\":{\"266\":1}}],[\"都被实现了\",{\"1\":{\"256\":1}}],[\"都被抛弃\",{\"1\":{\"193\":1}}],[\"都能够实现\",{\"1\":{\"256\":1}}],[\"都没有实现\",{\"1\":{\"256\":1}}],[\"都实现了同一种输出样式\",{\"1\":{\"256\":1}}],[\"都实现了不少高阶函数\",{\"1\":{\"85\":1}}],[\"都会尝试尽可能明确\",{\"1\":{\"184\":1}}],[\"都需要相同的名称怎么办\",{\"1\":{\"181\":1}}],[\"都得到相同的结果\",{\"1\":{\"131\":1}}],[\"都可以独立使用\",{\"1\":{\"178\":1}}],[\"都可以在父模块外部访问\",{\"1\":{\"133\":1}}],[\"都可以让下面函数正常工作\",{\"1\":{\"89\":1}}],[\"都可访问\",{\"1\":{\"89\":1}}],[\"都是\",{\"1\":{\"67\":1}}],[\"迭代一个\",{\"1\":{\"154\":1}}],[\"迭代\",{\"1\":{\"85\":1}}],[\"迭代器元素自身\",{\"1\":{\"308\":1}}],[\"迭代器可以被收集到\",{\"1\":{\"154\":1}}],[\"迭代器\",{\"1\":{\"72\":1,\"73\":1,\"85\":1,\"295\":1}}],[\"编码的\",{\"1\":{\"153\":1}}],[\"编码\",{\"1\":{\"153\":1}}],[\"编程的风格\",{\"1\":{\"85\":1}}],[\"编译期错误\",{\"1\":{\"101\":2,\"249\":1}}],[\"编译时进行静态检查的类型参数\",{\"1\":{\"101\":1}}],[\"编译的\",{\"1\":{\"40\":1}}],[\"编译器将会完成余下的工作\",{\"1\":{\"284\":1}}],[\"编译器都将以限制最少的方式来捕获\",{\"1\":{\"240\":1}}],[\"编译器会隐式地创建一个匿名类型的结构体\",{\"1\":{\"233\":1}}],[\"编译器会提示我们\",{\"1\":{\"225\":1}}],[\"编译器会给出关于变量可变性的详细诊断信息\",{\"1\":{\"198\":1}}],[\"编译器会对整数使用\",{\"1\":{\"195\":1}}],[\"编译器会对未使用的变量绑定产生警告\",{\"1\":{\"35\":1}}],[\"编译器禁止使用未经初始化的变量\",{\"1\":{\"196\":1}}],[\"编译器和程序员皆大欢喜\",{\"1\":{\"194\":1}}],[\"编译器知道\",{\"1\":{\"194\":1}}],[\"编译器需要知道每个函数的返回类型需要多少空间\",{\"1\":{\"184\":1}}],[\"编译器能够提供某些\",{\"1\":{\"179\":1}}],[\"编译器能够从上下文推导出变量的类型\",{\"1\":{\"35\":1}}],[\"编译器\",{\"1\":{\"138\":1,\"139\":1}}],[\"编译器提供了\",{\"1\":{\"39\":1}}],[\"编译后将得到可执行文件\",{\"1\":{\"13\":1}}],[\"带上生命周期的函数签名有一些限制\",{\"1\":{\"268\":1}}],[\"带后缀的字面量\",{\"1\":{\"195\":1}}],[\"带有生命周期标注的结构体\",{\"1\":{\"279\":1}}],[\"带有生命周期参数\",{\"1\":{\"266\":1}}],[\"带有两个数字的结构体\",{\"1\":{\"256\":1}}],[\"带有两个字段的结构体\",{\"1\":{\"60\":1}}],[\"带有\",{\"1\":{\"174\":1}}],[\"带有共用代码的模块遵循和普通的模块一样的规则\",{\"1\":{\"173\":1}}],[\"带有私有字段的公有结构体不能使用字段名来构造\",{\"1\":{\"129\":1}}],[\"带有公有字段的公有结构体\",{\"1\":{\"129\":1}}],[\"带有一个生命周期参数\",{\"1\":{\"266\":1}}],[\"带有一个私有的字段\",{\"1\":{\"129\":1}}],[\"带有一个公有的字段\",{\"1\":{\"129\":1}}],[\"带来了函数式\",{\"1\":{\"85\":1}}],[\"虽然我们在线程之间传递了引用\",{\"1\":{\"293\":1}}],[\"虽然\",{\"1\":{\"240\":1}}],[\"虽然生命周期和作用域经常被一起提到\",{\"1\":{\"139\":1}}],[\"虽然这看起来像是一个抽象的概念\",{\"1\":{\"84\":1}}],[\"虽然返回值中没有信息\",{\"1\":{\"84\":1}}],[\"绝不会返回\",{\"1\":{\"84\":1}}],[\"据\",{\"1\":{\"83\":1}}],[\"被迭代的类型\",{\"1\":{\"306\":1,\"308\":1}}],[\"被借用的值在这里被重新使用\",{\"1\":{\"259\":1}}],[\"被实现了\",{\"1\":{\"256\":1}}],[\"被包装的错误类型只能在运行时了解\",{\"1\":{\"207\":1}}],[\"被包装到\",{\"1\":{\"147\":1}}],[\"被不可变的\",{\"1\":{\"197\":1}}],[\"被隐藏的行以\",{\"1\":{\"171\":1}}],[\"被创建的线程取得\",{\"1\":{\"158\":1}}],[\"被存储为由字节组成的\",{\"1\":{\"152\":1}}],[\"被删时\",{\"1\":{\"149\":1}}],[\"被装箱的值可以使用\",{\"1\":{\"145\":1}}],[\"被销毁且内存得到释放\",{\"1\":{\"140\":1}}],[\"被销毁前结束\",{\"1\":{\"139\":1}}],[\"被社区广泛采用\",{\"1\":{\"122\":1}}],[\"被指定为\",{\"1\":{\"101\":4}}],[\"被赋值给合适地命名的变量\",{\"1\":{\"83\":1}}],[\"被当作\",{\"1\":{\"5\":1}}],[\"替代\",{\"1\":{\"83\":1}}],[\"没有出错\",{\"1\":{\"310\":1}}],[\"没有参数\",{\"1\":{\"293\":1}}],[\"没有参数的闭包\",{\"1\":{\"83\":1}}],[\"没有传入参数\",{\"1\":{\"287\":1}}],[\"没有`\",{\"1\":{\"219\":1}}],[\"没有必要担心复杂的逻辑会导致混乱的显示\",{\"1\":{\"209\":1}}],[\"没有必要写类型说明\",{\"1\":{\"194\":1}}],[\"没有记录其内部原因\",{\"1\":{\"207\":1,\"209\":1}}],[\"没有资源用于移动\",{\"1\":{\"178\":1}}],[\"没有实现\",{\"1\":{\"107\":1}}],[\"没有被用作\",{\"1\":{\"91\":1}}],[\"没有\",{\"1\":{\"81\":1,\"189\":1,\"256\":1}}],[\"没有匹配到\",{\"1\":{\"76\":1}}],[\"肯定有更优雅的处理方式\",{\"1\":{\"81\":1}}],[\"95\",{\"1\":{\"251\":1}}],[\"956\",{\"1\":{\"146\":1}}],[\"90\",{\"1\":{\"105\":1,\"251\":1,\"252\":1}}],[\"9\",{\"1\":{\"81\":4,\"84\":2,\"136\":1,\"141\":1,\"266\":1,\"268\":1,\"275\":1}}],[\"93\",{\"1\":{\"63\":1,\"64\":1,\"65\":1,\"66\":2,\"67\":2,\"207\":2,\"209\":2,\"210\":4,\"211\":2,\"213\":2}}],[\"设计不是健壮的\",{\"1\":{\"225\":1}}],[\"设为\",{\"1\":{\"81\":2}}],[\"设置小数位的显示格式可以参考文档\",{\"1\":{\"108\":1}}],[\"设置\",{\"1\":{\"1\":1}}],[\"考虑下面这段使\",{\"1\":{\"81\":1}}],[\"改成\",{\"1\":{\"298\":1}}],[\"改变所有权\",{\"1\":{\"281\":1}}],[\"改为\",{\"1\":{\"135\":1,\"261\":1}}],[\"改写得好看一些\",{\"1\":{\"81\":1}}],[\"改正上面代码中的错误\",{\"1\":{\"108\":1}}],[\"改正\",{\"1\":{\"35\":1,\"39\":1,\"55\":1,\"138\":1,\"154\":2,\"193\":1,\"196\":1,\"197\":1,\"198\":1,\"199\":1,\"260\":1,\"261\":1,\"285\":1}}],[\"小于\",{\"1\":{\"80\":1}}],[\"译者补充\",{\"1\":{\"80\":1}}],[\"译注\",{\"1\":{\"8\":1,\"11\":1,\"21\":1,\"44\":1,\"50\":1,\"55\":1,\"73\":1,\"76\":1,\"83\":2,\"87\":1,\"99\":1,\"105\":1,\"134\":1,\"135\":1,\"138\":3,\"139\":1,\"164\":1,\"193\":1,\"205\":1,\"225\":1,\"240\":2,\"273\":1,\"293\":1,\"298\":4,\"306\":4,\"308\":2}}],[\"添加到质数列表中\",{\"1\":{\"79\":1}}],[\"跳过这次迭代的剩下内容\",{\"1\":{\"78\":1}}],[\"跳过循环体的剩余部分并开始下一轮循环\",{\"1\":{\"78\":1}}],[\"允许使用泛型类型\",{\"1\":{\"244\":1}}],[\"允许我们创建别名\",{\"1\":{\"223\":1}}],[\"允许我们定义自己的错误类型\",{\"1\":{\"209\":1}}],[\"允许这种类型进行相等测试\",{\"1\":{\"101\":2}}],[\"允许在\",{\"1\":{\"87\":1}}],[\"允许匹配枚举非参数化的变量\",{\"1\":{\"76\":1}}],[\"允许一种类型定义\",{\"1\":{\"47\":1}}],[\"切食物\",{\"1\":{\"217\":1}}],[\"切换到\",{\"1\":{\"137\":1}}],[\"切换到失败情形\",{\"1\":{\"76\":1}}],[\"切片中\",{\"1\":{\"300\":1}}],[\"切片是一个双字对象\",{\"1\":{\"134\":1}}],[\"切片\",{\"0\":{\"300\":1},\"1\":{\"0\":1,\"134\":1,\"154\":1}}],[\"全部都是\",{\"1\":{\"76\":1}}],[\"全局变量是在所有其他作用域之外声明的\",{\"1\":{\"55\":1}}],[\"全局导入\",{\"1\":{\"1\":1}}],[\"层缩进\",{\"1\":{\"76\":1}}],[\"定长数组\",{\"1\":{\"134\":1}}],[\"定为\",{\"1\":{\"76\":1}}],[\"定义两个非引用的变量\",{\"1\":{\"298\":1}}],[\"定义了\",{\"1\":{\"249\":1}}],[\"定义我们的错误类型\",{\"1\":{\"209\":1}}],[\"定义方法\",{\"1\":{\"205\":1}}],[\"定义为另一个\",{\"1\":{\"189\":1}}],[\"定义的\",{\"1\":{\"178\":1}}],[\"定义的方法集\",{\"1\":{\"15\":1,\"30\":1}}],[\"定义泛型类型或泛型函数之类的东西时\",{\"1\":{\"11\":1}}],[\"定义一个包含单个\",{\"1\":{\"310\":1}}],[\"定义一个含有具名字段的结构体\",{\"1\":{\"256\":1}}],[\"定义一个满足\",{\"1\":{\"238\":2}}],[\"定义一个泛型别名\",{\"1\":{\"223\":1}}],[\"定义一个错误类型\",{\"0\":{\"209\":1}}],[\"定义一个调用者的方法\",{\"1\":{\"93\":1}}],[\"定义一个函数\",{\"1\":{\"89\":1,\"91\":4,\"238\":1}}],[\"定义一个枚举类型\",{\"1\":{\"6\":1}}],[\"定义一个结构体\",{\"1\":{\"6\":1,\"256\":1}}],[\"定义一种错误类型\",{\"1\":{\"0\":1}}],[\"条件部分是一个卫语句\",{\"1\":{\"231\":1}}],[\"条件的值为\",{\"1\":{\"76\":1}}],[\"条件选择是一个表达式\",{\"1\":{\"75\":1}}],[\"条件编译可能通过两种不同的操作符实现\",{\"1\":{\"36\":1}}],[\"分割\",{\"1\":{\"256\":2}}],[\"分为两种\",{\"1\":{\"164\":1}}],[\"分配新内存并存储修改过的字符串\",{\"1\":{\"152\":1}}],[\"分句来表达\",{\"1\":{\"103\":1}}],[\"分句来形成约束\",{\"1\":{\"89\":1}}],[\"分句\",{\"0\":{\"103\":1},\"1\":{\"81\":1}}],[\"分支展开成\",{\"1\":{\"286\":1}}],[\"分支展开成提前返回的\",{\"1\":{\"286\":1}}],[\"分支中绑定匹配值到\",{\"1\":{\"228\":1}}],[\"分支必须覆盖所有可能的值\",{\"1\":{\"79\":1}}],[\"分支判断和其他语言类似\",{\"1\":{\"75\":1}}],[\"分号结束了这个表达式\",{\"1\":{\"8\":1}}],[\"集合\",{\"1\":{\"285\":1}}],[\"集合类型\",{\"1\":{\"285\":1}}],[\"集合中的数据本身会被提供\",{\"1\":{\"73\":1}}],[\"集成\",{\"1\":{\"2\":1,\"28\":1}}],[\"集成测试的目的是检验你的库的各部分是否能够正确地协同工作\",{\"1\":{\"173\":1}}],[\"集成测试是\",{\"1\":{\"173\":1}}],[\"集成测试\",{\"0\":{\"173\":1},\"1\":{\"0\":1}}],[\"互动\",{\"1\":{\"73\":1}}],[\"互相独立\",{\"1\":{\"57\":1}}],[\"代码中仍会看到\",{\"1\":{\"310\":1}}],[\"代码可以分成一些叫做模块\",{\"1\":{\"195\":1}}],[\"代码的网络接口\",{\"1\":{\"124\":1}}],[\"代码块能以多种方式解构物件\",{\"1\":{\"230\":1}}],[\"代码块结束\",{\"1\":{\"199\":1}}],[\"代码块是一个被\",{\"1\":{\"199\":1}}],[\"代码块用三个反引号开启\",{\"1\":{\"170\":1}}],[\"代码块链接到\",{\"1\":{\"159\":1}}],[\"代码块\",{\"1\":{\"113\":1,\"183\":2}}],[\"代码块中声明\",{\"1\":{\"159\":1}}],[\"代码块中定义\",{\"1\":{\"86\":1,\"186\":1}}],[\"代码块中的最后一个语句是代码块中实际执行的最后一个语句\",{\"1\":{\"8\":1}}],[\"代码块中的最后一个表达式将赋给适当的表达式\",{\"1\":{\"8\":1}}],[\"代码块也是表达式\",{\"1\":{\"8\":1,\"110\":1}}],[\"代表人的名字\",{\"1\":{\"118\":1}}],[\"代表泛型\",{\"1\":{\"95\":1}}],[\"代替\",{\"1\":{\"72\":1}}],[\"步长为\",{\"1\":{\"72\":1}}],[\"留给\",{\"1\":{\"70\":1}}],[\"产生一个整型给\",{\"1\":{\"275\":1}}],[\"产生一个拥有\",{\"1\":{\"275\":2}}],[\"产生一个\",{\"1\":{\"186\":1,\"275\":1}}],[\"产生一个错误\",{\"1\":{\"70\":1}}],[\"产生二进制可执行文件\",{\"1\":{\"5\":1}}],[\"预期结果是\",{\"1\":{\"70\":1}}],[\"按日常书写习惯就是\",{\"1\":{\"193\":1}}],[\"按照定义\",{\"1\":{\"242\":1}}],[\"按照\",{\"1\":{\"140\":1}}],[\"按照约定\",{\"1\":{\"70\":1}}],[\"按钮并观察输出结果\",{\"1\":{\"14\":1}}],[\"按钮可以使代码恢复到初始状态\",{\"1\":{\"13\":1}}],[\"元素的方法\",{\"1\":{\"186\":2}}],[\"元素\",{\"1\":{\"70\":2,\"256\":1}}],[\"元组赋予不同的名字\",{\"1\":{\"296\":1}}],[\"元组的字段的引用\",{\"1\":{\"263\":1}}],[\"元组可以在\",{\"1\":{\"304\":1}}],[\"元组可以被解构\",{\"1\":{\"136\":1}}],[\"元组可以打印\",{\"1\":{\"136\":1}}],[\"元组可以充当函数的参数和返回值\",{\"1\":{\"136\":1}}],[\"元组也可以充当元组的元素\",{\"1\":{\"136\":1}}],[\"元组使用括号\",{\"1\":{\"136\":1}}],[\"元组是一个可以包含各种类型值的组合\",{\"1\":{\"136\":1}}],[\"元组结构体\",{\"1\":{\"60\":2,\"102\":1,\"147\":1,\"205\":1}}],[\"元组\",{\"0\":{\"136\":1,\"304\":1},\"1\":{\"0\":2,\"21\":1,\"232\":1,\"305\":1}}],[\"描述的是可能的错误而不是可能的不存在\",{\"1\":{\"70\":1}}],[\"公主讨厌蛇\",{\"1\":{\"69\":1}}],[\"公有项\",{\"1\":{\"133\":1}}],[\"公有\",{\"1\":{\"18\":1}}],[\"任意符合该约束的泛型的实例\",{\"1\":{\"89\":1}}],[\"任务\",{\"1\":{\"69\":1,\"148\":1}}],[\"任何实现了\",{\"1\":{\"284\":1}}],[\"任何被返回的引用都必须有和某个输入量相同的生命周期或是静态类型\",{\"1\":{\"268\":1}}],[\"任何被借用的输入量都必须比借用者生存得更长\",{\"1\":{\"266\":1}}],[\"任何引用都必须拥有标注好的生命周期\",{\"1\":{\"268\":1}}],[\"任何通过引用的捕获都被丢弃\",{\"1\":{\"242\":1}}],[\"任何的用法都要求是泛型的\",{\"1\":{\"233\":1}}],[\"任何一个在\",{\"1\":{\"57\":1}}],[\"任何用泛型类型参数表示的类型都是泛型\",{\"1\":{\"11\":1}}],[\"任何编程语言都包含的一个必要部分就是改变控制流程\",{\"1\":{\"9\":1}}],[\"开启服务器等等\",{\"1\":{\"173\":1}}],[\"开始保留\",{\"1\":{\"193\":1}}],[\"开始主函数\",{\"1\":{\"171\":1}}],[\"开始\",{\"1\":{\"107\":1,\"134\":1,\"154\":1,\"171\":1,\"201\":1}}],[\"开始回退\",{\"1\":{\"69\":1}}],[\"开发依赖\",{\"0\":{\"168\":1},\"1\":{\"0\":1}}],[\"恐慌\",{\"1\":{\"68\":1,\"148\":1}}],[\"养在深闺人未识的公主见到蛇就会\",{\"1\":{\"68\":1}}],[\"收集每个子线程的返回值\",{\"1\":{\"293\":1}}],[\"收集中间结果\",{\"1\":{\"293\":1}}],[\"收集所有合法的值与错误\",{\"0\":{\"66\":1}}],[\"收到什么礼物都能应对\",{\"1\":{\"68\":1}}],[\"同一时间内只允许一次可变借用\",{\"1\":{\"259\":1}}],[\"同一模块中的错误常常会有相同的\",{\"1\":{\"223\":1}}],[\"同一个堆分配的数据\",{\"1\":{\"140\":1}}],[\"同级别的\",{\"1\":{\"173\":1}}],[\"同时为这个未知类型的结构体实现函数功能\",{\"1\":{\"233\":1}}],[\"同时具有\",{\"1\":{\"181\":1}}],[\"同时增加引用计数器\",{\"1\":{\"144\":1}}],[\"同时不取得其所有权\",{\"1\":{\"138\":1}}],[\"同时如果需要的话\",{\"1\":{\"68\":1}}],[\"同样有效\",{\"1\":{\"263\":1}}],[\"同样为\",{\"1\":{\"205\":1}}],[\"同样的变量\",{\"1\":{\"251\":1}}],[\"同样的规则也适用于函数\",{\"1\":{\"91\":1}}],[\"同样的技巧可以对\",{\"1\":{\"65\":1}}],[\"同样\",{\"1\":{\"76\":1,\"105\":1}}],[\"信息是可能的\",{\"1\":{\"68\":1}}],[\"信道\",{\"1\":{\"26\":1}}],[\"找到了多个`get`\",{\"1\":{\"181\":1}}],[\"找到\",{\"1\":{\"70\":2}}],[\"找到一个属于\",{\"1\":{\"68\":1}}],[\"找不到相应元素\",{\"1\":{\"68\":1}}],[\"却没收到呢\",{\"1\":{\"68\":1}}],[\"上使用\",{\"1\":{\"310\":1}}],[\"上面代码是无效的\",{\"1\":{\"268\":1}}],[\"上面的代码使用了一些还没有讨论过的概念\",{\"1\":{\"195\":1}}],[\"上面的代码可以写成\",{\"1\":{\"72\":1}}],[\"上面的例子中纵向都有\",{\"1\":{\"105\":1}}],[\"上\",{\"1\":{\"228\":1}}],[\"上一节的\",{\"1\":{\"225\":1}}],[\"上一个例子中的\",{\"1\":{\"222\":1}}],[\"上例使用了\",{\"1\":{\"107\":1}}],[\"上的\",{\"1\":{\"80\":1}}],[\"上个例子展示了如何主动地引入程序失败\",{\"1\":{\"68\":1}}],[\"上找到很多很棒的\",{\"1\":{\"44\":1}}],[\"错误的生成与它如何显示是完全没关系的\",{\"1\":{\"209\":1}}],[\"错误类型应当\",{\"1\":{\"209\":1}}],[\"错误\",{\"1\":{\"151\":1,\"193\":1,\"198\":1}}],[\"错误2\",{\"1\":{\"67\":1}}],[\"错误1\",{\"1\":{\"67\":1}}],[\"错误处理类型\",{\"1\":{\"24\":1}}],[\"错误处理\",{\"0\":{\"7\":1},\"1\":{\"0\":1,\"7\":1,\"15\":1}}],[\"会像是这样\",{\"1\":{\"310\":1}}],[\"会怎样\",{\"1\":{\"298\":1}}],[\"会锁住标准输出\",{\"1\":{\"293\":1}}],[\"会获取所捕获变量的所有权\",{\"1\":{\"293\":1}}],[\"会把当前的迭代计数与被迭代的元素以元组\",{\"1\":{\"293\":1}}],[\"会把类型说明像实参一样使用\",{\"1\":{\"11\":1}}],[\"会保证数据存活至线程退出\",{\"1\":{\"293\":1}}],[\"会要求\",{\"1\":{\"249\":1}}],[\"会被确定为\",{\"1\":{\"246\":1}}],[\"会被任意变量内容所替换\",{\"1\":{\"107\":1}}],[\"会导致闭包以不可变方式借用\",{\"1\":{\"235\":1}}],[\"会导致出现嵌套形式\",{\"1\":{\"215\":1}}],[\"会强制闭包取得被捕获变量的所有权\",{\"1\":{\"235\":1}}],[\"会一直保持被借用状态直到\",{\"1\":{\"235\":1}}],[\"会不断加上或减去\",{\"1\":{\"193\":1}}],[\"会重载运算符的\",{\"1\":{\"187\":1}}],[\"会产生一个\",{\"1\":{\"215\":1}}],[\"会产生未定义行为的情形\",{\"1\":{\"193\":1}}],[\"会产生\",{\"1\":{\"186\":1}}],[\"会隐式地在其中添加\",{\"1\":{\"170\":1}}],[\"会选择并输出符合平台类型的\",{\"1\":{\"164\":1}}],[\"会立即继续进行\",{\"1\":{\"158\":1}}],[\"会给\",{\"1\":{\"154\":1}}],[\"会引发\",{\"1\":{\"148\":1}}],[\"会发生转移\",{\"1\":{\"140\":1}}],[\"会得到如下的输出\",{\"1\":{\"137\":1}}],[\"会检查使用到的参数数量是否正确\",{\"1\":{\"107\":1}}],[\"会分配存储空间\",{\"1\":{\"101\":1}}],[\"会失败的原因\",{\"1\":{\"76\":1}}],[\"会出错\",{\"1\":{\"76\":1}}],[\"会消耗集合\",{\"1\":{\"73\":1}}],[\"会退出我们的程序\",{\"1\":{\"70\":1}}],[\"会调用一个函数\",{\"1\":{\"64\":1}}],[\"长于函数的生命周期\",{\"1\":{\"266\":1}}],[\"长和宽都对应于\",{\"1\":{\"61\":1}}],[\"长方形\",{\"1\":{\"61\":2}}],[\"面积的函数\",{\"1\":{\"61\":1}}],[\"与原来的\",{\"1\":{\"211\":1}}],[\"与其他语言不同\",{\"1\":{\"184\":1}}],[\"与其让程序崩溃\",{\"1\":{\"151\":1}}],[\"与散列表\",{\"1\":{\"146\":1}}],[\"与迭代器\",{\"0\":{\"73\":1}}],[\"与区间\",{\"0\":{\"72\":1}}],[\"与\",{\"1\":{\"60\":1,\"107\":4,\"301\":1}}],[\"与许多编程语言一样\",{\"1\":{\"40\":1}}],[\"访问元组结构体的字段\",{\"1\":{\"60\":1}}],[\"访问\",{\"1\":{\"60\":1}}],[\"事实上拥有相同的签名\",{\"1\":{\"264\":1}}],[\"事实上这些\",{\"1\":{\"247\":1}}],[\"事实上是在满足使用需求的前提下尽量以限制最多的方式捕获\",{\"1\":{\"240\":1}}],[\"事实上\",{\"1\":{\"233\":1}}],[\"事实上的处理方式是\",{\"1\":{\"193\":1}}],[\"事实上就是具名元组而已\",{\"1\":{\"60\":1}}],[\"事件分类\",{\"1\":{\"57\":1}}],[\"避免使用又长又不方便的枚举名字\",{\"1\":{\"58\":1}}],[\"里就不能是\",{\"1\":{\"298\":1}}],[\"里面每个元素的下标也能够打印出来\",{\"1\":{\"311\":1}}],[\"里面有很多匹配\",{\"1\":{\"286\":1}}],[\"里面通过\",{\"1\":{\"246\":1}}],[\"里面的值被销毁后\",{\"1\":{\"138\":1}}],[\"里面的值之后在作用域中被借用时\",{\"1\":{\"138\":1}}],[\"里面所定义的一系列宏来处理\",{\"1\":{\"107\":1}}],[\"里面含有\",{\"1\":{\"5\":1}}],[\"里出现了\",{\"1\":{\"87\":1}}],[\"里解构出\",{\"1\":{\"57\":1}}],[\"称为\",{\"1\":{\"57\":1}}],[\"该引用必须比\",{\"1\":{\"277\":1}}],[\"该引用不能再使用\",{\"1\":{\"275\":1}}],[\"该引用不取\",{\"1\":{\"275\":1}}],[\"该变量的变化就意味着闭包内部发生了变化\",{\"1\":{\"235\":1}}],[\"该变量将被删除\",{\"1\":{\"144\":1}}],[\"该闭包立即借用\",{\"1\":{\"235\":1}}],[\"该怎么办呢\",{\"1\":{\"223\":1}}],[\"该字符串是堆分配的\",{\"1\":{\"205\":1}}],[\"该函数将闭包作为参数并调用它\",{\"1\":{\"240\":1}}],[\"该函数组合了两个\",{\"1\":{\"185\":1}}],[\"该函数的参数是一个通过值捕获变量的闭包\",{\"1\":{\"167\":1}}],[\"该迭代器会对每个参数举出一个字符串\",{\"1\":{\"156\":1}}],[\"该迭代器以任意顺序举出\",{\"1\":{\"146\":1}}],[\"该借用拥有一个生命周期\",{\"1\":{\"139\":1}}],[\"该对象不能被销毁\",{\"1\":{\"138\":1}}],[\"该按钮在\",{\"1\":{\"126\":1}}],[\"该类型可以充当标记\",{\"1\":{\"101\":1}}],[\"该类型也可以访问同一个\",{\"1\":{\"30\":1}}],[\"该实现中那些占位符对应什么具体类型\",{\"1\":{\"87\":1}}],[\"该枚举故意未注明\",{\"1\":{\"76\":1}}],[\"该功能已在\",{\"1\":{\"58\":1}}],[\"该属性用于隐藏对未使用代码的警告\",{\"1\":{\"57\":1,\"201\":1,\"203\":1}}],[\"主函数\",{\"1\":{\"55\":1}}],[\"主要用于测试\",{\"1\":{\"7\":1}}],[\"须使用static\",{\"1\":{\"55\":1}}],[\"具有\",{\"1\":{\"55\":1}}],[\"具体类型\",{\"1\":{\"91\":3,\"95\":1}}],[\"具体地说\",{\"1\":{\"32\":1}}],[\"具体化\",{\"1\":{\"11\":1}}],[\"覆盖\",{\"1\":{\"53\":1}}],[\"前给出\",{\"1\":{\"91\":1}}],[\"前面例子中的\",{\"1\":{\"298\":1}}],[\"前面需要加上\",{\"1\":{\"235\":1}}],[\"前面的匹配可以用\",{\"1\":{\"161\":1}}],[\"前面的\",{\"1\":{\"86\":1}}],[\"前面出现的例子都是很方便的情况\",{\"1\":{\"67\":1}}],[\"前面加上\",{\"1\":{\"53\":1}}],[\"前缀\",{\"1\":{\"53\":1}}],[\"前出现\",{\"1\":{\"11\":1}}],[\"86967897737416471853297327050364959\",{\"1\":{\"293\":1}}],[\"8291\",{\"1\":{\"146\":1}}],[\"80\",{\"1\":{\"57\":1}}],[\"8i32\",{\"1\":{\"52\":1}}],[\"8\",{\"1\":{\"52\":3,\"107\":1,\"136\":1,\"141\":1,\"152\":2,\"153\":3,\"164\":2,\"174\":1,\"193\":1}}],[\"89\",{\"1\":{\"45\":1}}],[\"型\",{\"1\":{\"52\":1}}],[\"把所有中间结果加起来\",{\"1\":{\"293\":1}}],[\"把每个线程产生的中间结果收入一个新的向量中\",{\"1\":{\"293\":1}}],[\"把数据分段\",{\"1\":{\"293\":2}}],[\"把数字放出来\",{\"1\":{\"70\":1}}],[\"把上面的逻辑改写得更紧凑\",{\"1\":{\"215\":1}}],[\"把对象和\",{\"1\":{\"187\":1}}],[\"把它解构成\",{\"1\":{\"306\":1}}],[\"把它和\",{\"1\":{\"293\":1}}],[\"把它隐藏起来\",{\"1\":{\"171\":1}}],[\"把它转换成一个迭代器\",{\"1\":{\"73\":1}}],[\"把字符转成数字\",{\"1\":{\"293\":1}}],[\"把字符串转换成目标类型\",{\"1\":{\"51\":1}}],[\"把字节串转换为\",{\"1\":{\"153\":1}}],[\"把一个元组的成员绑定到一些变量\",{\"1\":{\"136\":1}}],[\"把模式这样\",{\"1\":{\"114\":1}}],[\"把表达式\",{\"1\":{\"110\":1}}],[\"把\",{\"1\":{\"57\":1,\"140\":1,\"286\":1}}],[\"把错误装箱这种做法也可以改成把它包裹到你自己的错误类型中\",{\"1\":{\"213\":1}}],[\"把错误换成我们的新类型\",{\"1\":{\"209\":1}}],[\"把错误\",{\"0\":{\"207\":1},\"1\":{\"0\":1}}],[\"涡轮鱼\",{\"1\":{\"51\":1,\"293\":1}}],[\"您还可以使用\",{\"1\":{\"185\":1}}],[\"您还可以查阅本网站的源代码\",{\"1\":{\"15\":1}}],[\"您应该实现fmt\",{\"1\":{\"50\":1}}],[\"试着分别用一用\",{\"1\":{\"240\":1}}],[\"试着加上一个分号来结束这条表达式\",{\"1\":{\"75\":1}}],[\"试图重新借用将导致错误\",{\"1\":{\"235\":1}}],[\"试试不使用自定义的\",{\"1\":{\"200\":1}}],[\"试试删除类型注释\",{\"1\":{\"48\":1}}],[\"试一试去掉此行注释\",{\"1\":{\"259\":3}}],[\"试一试\",{\"1\":{\"30\":1,\"75\":1,\"79\":4,\"86\":2,\"89\":1,\"93\":1,\"97\":1,\"129\":2,\"133\":4,\"135\":1,\"136\":1,\"140\":2,\"149\":1,\"178\":2,\"179\":2,\"183\":1,\"191\":1,\"194\":1,\"231\":1,\"235\":2,\"240\":1,\"247\":1,\"293\":3,\"296\":1,\"304\":1}}],[\"倒过来而已\",{\"1\":{\"48\":1}}],[\"规定原生类型及其他常见类型的转换功能\",{\"1\":{\"47\":1}}],[\"规定说明文档\",{\"1\":{\"42\":1}}],[\"怎么办\",{\"1\":{\"254\":1}}],[\"怎么根据另一种类型生成自己\",{\"1\":{\"47\":1}}],[\"怎么使用构建脚本\",{\"0\":{\"42\":1}}],[\"需要在匹配前解引用\",{\"1\":{\"298\":1}}],[\"需要一个泛型\",{\"1\":{\"290\":1}}],[\"需要一些模板化的代码\",{\"1\":{\"66\":1}}],[\"需要显式标注来确定引用的生命周期应该是什么样的\",{\"1\":{\"266\":1}}],[\"需要\",{\"1\":{\"256\":1,\"296\":1}}],[\"需要手动实现\",{\"1\":{\"254\":1}}],[\"需要转换成\",{\"1\":{\"213\":1}}],[\"需要你同时\",{\"1\":{\"189\":1}}],[\"需要你也\",{\"1\":{\"189\":1}}],[\"需要更多的步骤\",{\"1\":{\"107\":1}}],[\"需要两个参数\",{\"1\":{\"86\":1}}],[\"需要三层缩进\",{\"1\":{\"81\":1}}],[\"需要覆盖全部情况\",{\"1\":{\"76\":1}}],[\"需要和result<t\",{\"1\":{\"67\":1}}],[\"需要和\",{\"1\":{\"67\":1}}],[\"需要注意的一点是\",{\"1\":{\"45\":1}}],[\"需要将死代码清除掉\",{\"1\":{\"39\":1}}],[\"目录\",{\"1\":{\"173\":1}}],[\"目录寻找集成测试\",{\"1\":{\"173\":1}}],[\"目录的信息\",{\"1\":{\"164\":1}}],[\"目录的最终状态为\",{\"1\":{\"161\":1}}],[\"目录的层次结构中\",{\"1\":{\"128\":1}}],[\"目录下的每个文件都是一个单独的集成测试\",{\"1\":{\"45\":1}}],[\"目录中的每一个\",{\"1\":{\"173\":1}}],[\"目录中\",{\"1\":{\"45\":1}}],[\"目录中来添加其他二进制可执行文件\",{\"1\":{\"43\":1}}],[\"││\",{\"1\":{\"139\":4}}],[\"│\",{\"1\":{\"45\":1,\"139\":6}}],[\"瞧\",{\"1\":{\"44\":1}}],[\"类\",{\"1\":{\"135\":1}}],[\"类似地使用\",{\"1\":{\"298\":1}}],[\"类似地对\",{\"1\":{\"256\":1}}],[\"类似地\",{\"1\":{\"128\":1,\"153\":1,\"264\":1,\"302\":1}}],[\"类似于\",{\"1\":{\"52\":1}}],[\"类似\",{\"1\":{\"44\":1,\"76\":1,\"81\":1,\"107\":4,\"146\":1,\"154\":1,\"205\":1,\"251\":1,\"254\":1}}],[\"类型返回第一个满足谓词的元素\",{\"1\":{\"308\":1}}],[\"类型取决于所匹配的值的类型\",{\"1\":{\"300\":1}}],[\"类型就是一个指向\",{\"1\":{\"277\":1}}],[\"类型并返回一个\",{\"1\":{\"272\":1}}],[\"类型必须实现\",{\"1\":{\"270\":1}}],[\"类型实现了这个\",{\"1\":{\"244\":1}}],[\"类型本身\",{\"1\":{\"235\":1}}],[\"类型赋给单元类型变量\",{\"1\":{\"225\":1}}],[\"类型被指定为parseinterror\",{\"1\":{\"225\":1}}],[\"类型使用fromstr\",{\"1\":{\"225\":1}}],[\"类型时\",{\"1\":{\"223\":1}}],[\"类型要好过匹配引用\",{\"1\":{\"205\":1}}],[\"类型无法写出\",{\"1\":{\"185\":1}}],[\"类型创建\",{\"1\":{\"164\":1}}],[\"类型拥有两个取值\",{\"1\":{\"151\":1}}],[\"类型标注是可选的\",{\"1\":{\"158\":1}}],[\"类型标注和函数的一样\",{\"1\":{\"83\":1}}],[\"类型标记是多余的\",{\"1\":{\"134\":1}}],[\"类型和数组类似\",{\"1\":{\"134\":1}}],[\"类型为泛型\",{\"1\":{\"129\":2}}],[\"类型为例\",{\"1\":{\"76\":1}}],[\"类型type\",{\"1\":{\"110\":1}}],[\"类型不匹配\",{\"1\":{\"101\":2,\"249\":1}}],[\"类型不同\",{\"1\":{\"84\":1}}],[\"类型之间使用\",{\"1\":{\"97\":1}}],[\"类型参数常常必须使用\",{\"1\":{\"89\":1}}],[\"类型的引用\",{\"1\":{\"261\":2,\"277\":1,\"298\":1}}],[\"类型的\",{\"1\":{\"249\":1,\"275\":1,\"306\":1}}],[\"类型的别名\",{\"1\":{\"191\":1}}],[\"类型的名字必须遵循驼峰命名法\",{\"1\":{\"191\":1}}],[\"类型的右操作数加起来的\",{\"1\":{\"187\":1}}],[\"类型的右操作数\",{\"1\":{\"187\":1}}],[\"类型的值\",{\"1\":{\"145\":1,\"147\":1}}],[\"类型的实例\",{\"1\":{\"145\":1}}],[\"类型的表达式\",{\"1\":{\"110\":1}}],[\"类型的参数\",{\"1\":{\"91\":4}}],[\"类型的方法\",{\"1\":{\"70\":1,\"86\":1}}],[\"类型的更丰富的版本\",{\"1\":{\"70\":1}}],[\"类型的元素\",{\"1\":{\"68\":1}}],[\"类型的变量\",{\"1\":{\"11\":1}}],[\"类型别名枚举变量\",{\"1\":{\"59\":1}}],[\"类型别名\",{\"0\":{\"58\":1}}],[\"类型也可根据上下文自动推断\",{\"1\":{\"21\":1}}],[\"类型\",{\"1\":{\"11\":3,\"21\":4,\"75\":2,\"76\":2,\"81\":2,\"83\":1,\"86\":1,\"95\":1,\"99\":2,\"101\":2,\"138\":3,\"151\":2,\"153\":1,\"160\":1,\"163\":1,\"171\":1,\"186\":1,\"205\":4,\"223\":2,\"244\":1,\"246\":2,\"249\":3,\"261\":1,\"268\":1,\"272\":1,\"277\":1,\"291\":2,\"298\":2,\"306\":1,\"308\":8}}],[\"类型是为了值是可选的\",{\"1\":{\"7\":1}}],[\"类型匿名\",{\"0\":{\"233\":1},\"1\":{\"0\":1}}],[\"类型推断\",{\"0\":{\"194\":1},\"1\":{\"0\":1,\"22\":1}}],[\"类型转换\",{\"0\":{\"4\":1,\"193\":1},\"1\":{\"0\":2,\"15\":1,\"202\":1}}],[\"类型系统\",{\"0\":{\"31\":1},\"1\":{\"0\":1,\"15\":1}}],[\"执行语句块\",{\"1\":{\"81\":1}}],[\"执行\",{\"1\":{\"44\":1,\"170\":1}}],[\"格式规范中\",{\"1\":{\"44\":1}}],[\"格式化的方式是通过格式字符串来指定的\",{\"1\":{\"251\":1}}],[\"格式化文本以供调试使用\",{\"1\":{\"107\":1}}],[\"格式化\",{\"0\":{\"251\":1},\"1\":{\"0\":1,\"137\":2}}],[\"格式化输出\",{\"0\":{\"107\":1},\"1\":{\"0\":1}}],[\"浏览\",{\"1\":{\"44\":1}}],[\"项\",{\"1\":{\"186\":2}}],[\"项只能在指定的模块中访问\",{\"1\":{\"133\":1}}],[\"项可以在同一个\",{\"1\":{\"133\":1}}],[\"项可以访问其它项\",{\"1\":{\"133\":1}}],[\"项可以从模块外的作用域访问\",{\"1\":{\"133\":1}}],[\"项可以是\",{\"1\":{\"18\":1}}],[\"项后面将以下内容添加进来\",{\"1\":{\"44\":1}}],[\"项目\",{\"1\":{\"44\":1}}],[\"工程编写文档的主要方式是在源代码中写注释\",{\"1\":{\"170\":1}}],[\"工程都使用\",{\"1\":{\"38\":1}}],[\"工具\",{\"1\":{\"44\":1}}],[\"幸运的是\",{\"1\":{\"44\":1,\"171\":1,\"225\":1,\"286\":1}}],[\"大多数单元测试都会被放到一个叫\",{\"1\":{\"174\":1}}],[\"大多数程序都会依赖于某些库\",{\"1\":{\"44\":1}}],[\"大部分\",{\"1\":{\"8\":1}}],[\"正是为这种情况准备的\",{\"1\":{\"221\":1}}],[\"正确的实现需要处理所有的\",{\"1\":{\"310\":1}}],[\"正确的缩进是好的\",{\"1\":{\"76\":1}}],[\"正确代码\",{\"1\":{\"198\":1}}],[\"正好帮助我们完成这任务\",{\"1\":{\"178\":1}}],[\"正常运行\",{\"1\":{\"86\":1,\"197\":1,\"259\":1,\"260\":1,\"298\":1}}],[\"正常构建还是不够的\",{\"1\":{\"41\":1}}],[\"正如我们之前看到的\",{\"1\":{\"43\":1}}],[\"很相似\",{\"1\":{\"256\":1}}],[\"很多运算符可以通过\",{\"1\":{\"187\":1}}],[\"很多用户会复制文档中的代码来用\",{\"1\":{\"171\":1}}],[\"很多时候你需要在一些地方针对不同\",{\"1\":{\"16\":1}}],[\"很注重正确性\",{\"1\":{\"170\":1}}],[\"很容易\",{\"1\":{\"154\":1}}],[\"很自然地提供了一种便捷的方法来运行所有测试\",{\"1\":{\"45\":1}}],[\"很显然\",{\"1\":{\"43\":1}}],[\"└──\",{\"1\":{\"43\":5,\"44\":2,\"45\":3}}],[\"├──\",{\"1\":{\"43\":3,\"44\":1,\"45\":3}}],[\"请修改程序\",{\"1\":{\"294\":1}}],[\"请把\",{\"1\":{\"285\":1}}],[\"请把它复制到任何编辑器中\",{\"1\":{\"139\":1}}],[\"请改用\",{\"1\":{\"251\":1}}],[\"请这样调用程序\",{\"1\":{\"156\":1}}],[\"请使用\",{\"1\":{\"153\":1,\"175\":1,\"293\":1}}],[\"请使用字节串\",{\"1\":{\"153\":1}}],[\"请在两边加一对\",{\"1\":{\"153\":1}}],[\"请运行一下\",{\"1\":{\"105\":1}}],[\"请看例子\",{\"1\":{\"171\":1}}],[\"请看\",{\"1\":{\"89\":1}}],[\"请注意函数自身就是一个作用域\",{\"1\":{\"138\":1}}],[\"请注意\",{\"1\":{\"44\":2,\"68\":1}}],[\"请阅读\",{\"1\":{\"42\":1}}],[\"请不要这样做\",{\"1\":{\"7\":1}}],[\"打开一个文件\",{\"1\":{\"288\":1,\"289\":1}}],[\"打开文件\",{\"0\":{\"289\":1},\"1\":{\"0\":1}}],[\"打印和使用\",{\"1\":{\"254\":1}}],[\"打印\",{\"1\":{\"254\":1,\"285\":1}}],[\"打印出来\",{\"1\":{\"110\":1}}],[\"打印操作由\",{\"1\":{\"107\":1}}],[\"打印的所有行都写入到\",{\"1\":{\"42\":1}}],[\"优先进行编译和调用\",{\"1\":{\"42\":1}}],[\"英文原文\",{\"1\":{\"42\":1}}],[\"英文原文为\",{\"1\":{\"41\":1}}],[\"英文版每天都会自动同步一次官方的最新版本\",{\"1\":{\"15\":1}}],[\"要区分开\",{\"1\":{\"298\":1}}],[\"要求你对此类型推导\",{\"1\":{\"284\":1}}],[\"要求\",{\"1\":{\"235\":1,\"256\":1}}],[\"要求恰好一样\",{\"1\":{\"233\":1}}],[\"要做到这点\",{\"1\":{\"235\":1}}],[\"要做一份好菜\",{\"1\":{\"215\":1}}],[\"要么\",{\"1\":{\"211\":1}}],[\"要么就\",{\"1\":{\"68\":1,\"70\":1}}],[\"要运行多个测试\",{\"1\":{\"176\":1}}],[\"要运行特定的测试\",{\"1\":{\"176\":1}}],[\"要运行测试\",{\"1\":{\"118\":1}}],[\"要取出它们\",{\"1\":{\"66\":1}}],[\"要将一个\",{\"1\":{\"54\":1}}],[\"要把任何类型转换成\",{\"1\":{\"50\":1}}],[\"要构建我们的项目\",{\"1\":{\"44\":1}}],[\"要在程序中添加依赖\",{\"1\":{\"44\":1}}],[\"要向包中添加构建脚本\",{\"1\":{\"41\":1}}],[\"要尽可能减少不安全代码的量\",{\"1\":{\"32\":1}}],[\"|c|\",{\"1\":{\"293\":1}}],[\"|chopped\",{\"1\":{\"217\":2}}],[\"|needle|\",{\"1\":{\"235\":1}}],[\"|n|\",{\"1\":{\"85\":1,\"210\":2}}],[\"|peeled\",{\"1\":{\"217\":1}}],[\"|first\",{\"1\":{\"223\":1,\"225\":1}}],[\"|first|\",{\"1\":{\"210\":2}}],[\"|f|\",{\"1\":{\"217\":1}}],[\"|r|\",{\"1\":{\"210\":1}}],[\"|x|\",{\"1\":{\"185\":2,\"240\":1,\"306\":1}}],[\"|x\",{\"1\":{\"185\":1}}],[\"|e|\",{\"1\":{\"166\":1,\"207\":1,\"211\":1}}],[\"|why|\",{\"1\":{\"161\":6}}],[\"|second\",{\"1\":{\"223\":1,\"225\":1}}],[\"|sum\",{\"1\":{\"85\":1}}],[\"|s|\",{\"1\":{\"63\":1,\"64\":1,\"65\":1,\"66\":2,\"207\":1,\"209\":1,\"211\":1}}],[\"|i|\",{\"1\":{\"207\":1,\"209\":1}}],[\"|i\",{\"1\":{\"83\":2}}],[\"||\",{\"1\":{\"83\":2,\"113\":1,\"135\":1,\"144\":1,\"158\":1,\"167\":1,\"207\":1,\"233\":1,\"235\":3,\"238\":1,\"240\":1,\"242\":3,\"293\":3}}],[\"|val|\",{\"1\":{\"83\":1}}],[\"|\",{\"1\":{\"40\":3,\"79\":4,\"83\":1,\"85\":2,\"89\":1,\"128\":6,\"135\":1,\"161\":1,\"209\":2,\"217\":3,\"235\":1,\"306\":3,\"308\":4}}],[\"版或更早版本需要这个导入语句\",{\"1\":{\"54\":1}}],[\"版本号\",{\"1\":{\"44\":1}}],[\"版本的新功能中保留下来\",{\"1\":{\"40\":1}}],[\"版本和类型\",{\"1\":{\"1\":1}}],[\"版\",{\"1\":{\"40\":1}}],[\"拥有生命周期限制\",{\"1\":{\"270\":1}}],[\"拥有一个未知的生命周期\",{\"1\":{\"270\":1}}],[\"拥有不同生命周期的多个元素\",{\"1\":{\"268\":1}}],[\"拥有虚类型参数\",{\"1\":{\"249\":2}}],[\"拥有显式辨别值\",{\"1\":{\"201\":1}}],[\"拥有隐式辨别值\",{\"1\":{\"201\":1}}],[\"拥有它\",{\"1\":{\"140\":1}}],[\"拥有资源\",{\"1\":{\"86\":1,\"289\":1}}],[\"拥有\",{\"1\":{\"40\":1,\"151\":2,\"285\":1,\"291\":1}}],[\"无需解构\",{\"1\":{\"306\":1}}],[\"无需类型说明就能在大多数时候完成变量捕获\",{\"1\":{\"240\":1}}],[\"无法打印\",{\"1\":{\"259\":1}}],[\"无法修改已冻结的数据\",{\"1\":{\"197\":1}}],[\"无意义的运算当然会失败\",{\"1\":{\"249\":1}}],[\"无后缀的字面量\",{\"1\":{\"195\":1}}],[\"无后缀的数值字面量\",{\"1\":{\"195\":1}}],[\"无论什么类型\",{\"1\":{\"89\":1}}],[\"无限循环\",{\"1\":{\"78\":1}}],[\"无返回值\",{\"1\":{\"57\":1}}],[\"无效代码\",{\"1\":{\"39\":1}}],[\"无符号整数\",{\"1\":{\"20\":1}}],[\"无符号整型和其他原生类型\",{\"1\":{\"15\":1}}],[\"由\",{\"1\":{\"178\":1}}],[\"由处理器架构决定\",{\"1\":{\"134\":1}}],[\"由于约束\",{\"1\":{\"247\":1}}],[\"由于这个结构体的类型未知\",{\"1\":{\"233\":1}}],[\"由于不可能把\",{\"1\":{\"225\":1}}],[\"由于目前用于获取类型的函数仍然是不\",{\"1\":{\"225\":1}}],[\"由于每个\",{\"1\":{\"181\":1}}],[\"由于在进行文件\",{\"1\":{\"160\":1,\"163\":1}}],[\"由于调用其他语言的函数被认为是不安全的\",{\"1\":{\"159\":1}}],[\"由于使用了arc\",{\"1\":{\"144\":1}}],[\"由于它在线程之间共享所有权\",{\"1\":{\"144\":1}}],[\"由于\",{\"1\":{\"91\":1,\"211\":1,\"249\":1}}],[\"由于本书的例子是交互性的\",{\"1\":{\"39\":1}}],[\"由于大多数\",{\"1\":{\"38\":1}}],[\"由一系列语句构成\",{\"1\":{\"8\":1}}],[\"两者即使拥有\",{\"1\":{\"268\":1}}],[\"两者的子类\",{\"1\":{\"189\":1}}],[\"两层装箱\",{\"1\":{\"145\":1}}],[\"两种形式使用的参数语法都相同\",{\"1\":{\"36\":1}}],[\"两个集合的所有元素\",{\"1\":{\"285\":1}}],[\"两个变量的借用\",{\"1\":{\"266\":1}}],[\"两个值各自都可以使用\",{\"1\":{\"140\":1}}],[\"两个堆分配的整型\",{\"1\":{\"86\":1}}],[\"两个\",{\"1\":{\"4\":1,\"46\":1,\"178\":1}}],[\"复制语义\",{\"1\":{\"179\":1}}],[\"复制字符到一个\",{\"1\":{\"152\":1}}],[\"复制\",{\"1\":{\"140\":1,\"178\":1}}],[\"复制到\",{\"1\":{\"35\":1,\"140\":1}}],[\"复习\",{\"1\":{\"137\":1}}],[\"复合类型\",{\"0\":{\"21\":1}}],[\"到了线程中\",{\"1\":{\"293\":1}}],[\"到闭包中\",{\"1\":{\"235\":1}}],[\"到匿名类型中\",{\"1\":{\"233\":1}}],[\"到现在为止\",{\"1\":{\"221\":1}}],[\"到此为止\",{\"1\":{\"220\":1}}],[\"到装箱错误\",{\"1\":{\"211\":1}}],[\"到一个变量需要类型标注\",{\"1\":{\"147\":1}}],[\"到代码块中\",{\"1\":{\"125\":1}}],[\"到无穷大\",{\"1\":{\"85\":1}}],[\"到\",{\"1\":{\"72\":1,\"140\":2,\"213\":1}}],[\"到变量\",{\"1\":{\"35\":1}}],[\"到本地并查阅官方标准库文档\",{\"1\":{\"15\":1}}],[\"于是\",{\"1\":{\"139\":1}}],[\"于是以下是默认的分支\",{\"1\":{\"76\":1}}],[\"于是我们就不能预测会发生些什么了\",{\"1\":{\"34\":1}}],[\"于是将\",{\"1\":{\"8\":1}}],[\"否则\",{\"1\":{\"288\":1,\"310\":1}}],[\"否则无论函数是否正在执行都将终止且返回\",{\"1\":{\"219\":1}}],[\"否则编译器将给出警告\",{\"1\":{\"191\":1}}],[\"否则返回错误\",{\"1\":{\"225\":1}}],[\"否则返回切好的食物\",{\"1\":{\"217\":1}}],[\"否则返回削好皮的食物\",{\"1\":{\"217\":1}}],[\"否则返回\",{\"1\":{\"146\":1,\"306\":1}}],[\"否则我们会给出错误的约束\",{\"1\":{\"103\":1}}],[\"否则就要表达成\",{\"1\":{\"103\":1}}],[\"否则就\",{\"1\":{\"81\":1}}],[\"否则程序的行为是未定义的\",{\"1\":{\"34\":1}}],[\"否则会按默认方式决定类型\",{\"1\":{\"21\":1}}],[\"且避免产生\",{\"1\":{\"221\":1}}],[\"且更加紧凑\",{\"1\":{\"217\":1}}],[\"且可能失败\",{\"1\":{\"164\":1}}],[\"且\",{\"1\":{\"161\":1}}],[\"且该代码块要带有一个包含库名称的\",{\"1\":{\"159\":1}}],[\"且不是零结尾的\",{\"1\":{\"152\":1}}],[\"且它们的大小在编译时会被确定\",{\"1\":{\"134\":1}}],[\"且仅在\",{\"1\":{\"101\":1}}],[\"且在\",{\"1\":{\"91\":1}}],[\"且每个条件后面都跟着一个代码块\",{\"1\":{\"75\":1}}],[\"且通常会退出程序\",{\"1\":{\"69\":1}}],[\"且你想要对其重命名\",{\"1\":{\"58\":1}}],[\"且被指向的内存具有正确的数据类型\",{\"1\":{\"34\":1}}],[\"且应当由调用者处理时\",{\"1\":{\"7\":1}}],[\"裸指针\",{\"1\":{\"33\":1}}],[\"接着立即使用\",{\"1\":{\"293\":1}}],[\"接着我们进入学习\",{\"1\":{\"32\":1}}],[\"接下来数行是详细文档\",{\"1\":{\"170\":1}}],[\"接下来会讲到\",{\"1\":{\"31\":1}}],[\"接收端\",{\"1\":{\"158\":1}}],[\"接受\",{\"1\":{\"306\":1,\"308\":1}}],[\"接受两个\",{\"1\":{\"266\":1}}],[\"接受一个引用并返回\",{\"1\":{\"146\":1}}],[\"接受一个额外的参数\",{\"1\":{\"93\":1}}],[\"接受一个\",{\"1\":{\"91\":4}}],[\"接受一个类型为泛型\",{\"1\":{\"89\":1}}],[\"接受的参数是一个\",{\"1\":{\"61\":1}}],[\"默认的行为是在赋值或函数调用的同时将它们转移\",{\"1\":{\"178\":1}}],[\"默认二进制名称是\",{\"1\":{\"43\":1}}],[\"默认\",{\"1\":{\"30\":1}}],[\"默认情况下\",{\"1\":{\"5\":1,\"53\":1,\"107\":1,\"133\":1}}],[\"什么时候资源可以释放\",{\"1\":{\"23\":1}}],[\"什么样的具体类型是合法的\",{\"1\":{\"11\":1}}],[\"报错\",{\"1\":{\"21\":1,\"54\":1,\"55\":1,\"86\":2,\"89\":2,\"129\":2,\"133\":4,\"138\":1,\"140\":2,\"149\":1,\"154\":1,\"178\":2,\"179\":2,\"196\":1,\"197\":1,\"199\":1,\"256\":1,\"259\":3,\"260\":1,\"261\":1,\"266\":1,\"282\":1}}],[\"根据用户输入的数据来决定线程的数量是不明智的\",{\"1\":{\"294\":1}}],[\"根据使用的参数类型是\",{\"1\":{\"251\":1}}],[\"根据你调用它的方式\",{\"1\":{\"113\":1}}],[\"根据下一行的赋值推断为\",{\"1\":{\"21\":1}}],[\"根据格式化字符串的不同\",{\"1\":{\"16\":1}}],[\"70856234701860851907960690014725639\",{\"1\":{\"293\":1}}],[\"75\",{\"1\":{\"251\":1}}],[\"7i32\",{\"1\":{\"197\":1,\"260\":1}}],[\"7689\",{\"1\":{\"146\":2}}],[\"798\",{\"1\":{\"146\":2}}],[\"7\",{\"1\":{\"21\":1,\"76\":2,\"79\":1,\"116\":2,\"136\":1,\"170\":1,\"186\":1,\"233\":1,\"254\":1,\"256\":1,\"257\":2,\"268\":1,\"270\":1}}],[\"后总是立即将错误从标准库的错误\",{\"1\":{\"211\":1}}],[\"后缀表明字面量是一个\",{\"1\":{\"135\":1}}],[\"后缀来表明字面量是一个\",{\"1\":{\"135\":1}}],[\"后缀说明\",{\"1\":{\"21\":1}}],[\"后者只有一个可能的值\",{\"1\":{\"84\":1}}],[\"后面不能整体使用父级变量\",{\"1\":{\"282\":1}}],[\"后面才将它们初始化\",{\"1\":{\"196\":1}}],[\"后面的\",{\"1\":{\"114\":1}}],[\"后面跟着至少一个\",{\"1\":{\"114\":1}}],[\"后面指定格式字符\",{\"1\":{\"107\":1}}],[\"后面将做更多介绍\",{\"1\":{\"44\":1}}],[\"后面再定义它\",{\"1\":{\"10\":1}}],[\"常规说明\",{\"1\":{\"21\":1}}],[\"常量\",{\"0\":{\"55\":1},\"1\":{\"0\":1,\"55\":1,\"276\":1}}],[\"才能改变它的值\",{\"1\":{\"298\":1}}],[\"才能获取线程的返回值\",{\"1\":{\"293\":1}}],[\"才按默认方式取整型数值为\",{\"1\":{\"21\":1}}],[\"才会被编译\",{\"1\":{\"5\":1}}],[\"则旧内容将被销毁\",{\"1\":{\"288\":1}}],[\"则须遵守类型规范要求\",{\"1\":{\"244\":1}}],[\"则闭包也有能力使用其他方式借用变量\",{\"1\":{\"240\":1}}],[\"则是拿到了变量的所有权而非借用\",{\"1\":{\"240\":1}}],[\"则匹配\",{\"1\":{\"228\":1}}],[\"则不经过重新绑定就无法在分支中再使用它\",{\"1\":{\"228\":1}}],[\"则不能编写返回\",{\"1\":{\"184\":1}}],[\"则可能需要将其传递给代码的其余部分\",{\"1\":{\"227\":1}}],[\"则可以\",{\"1\":{\"284\":1}}],[\"则可以改变变量\",{\"1\":{\"240\":1}}],[\"则可以添加\",{\"1\":{\"125\":1}}],[\"则可以通过其别名引用每个枚举变量\",{\"1\":{\"58\":1}}],[\"则继续处理错误\",{\"1\":{\"210\":1}}],[\"则该类型中还需要加入更多数据\",{\"1\":{\"213\":1}}],[\"则该值为负\",{\"1\":{\"193\":1}}],[\"则该整数会自动推断为\",{\"1\":{\"21\":1}}],[\"则无法写出显式的返回类型\",{\"1\":{\"185\":1}}],[\"则需要使用\",{\"1\":{\"184\":1}}],[\"则会收到一条错误消息\",{\"1\":{\"181\":1}}],[\"则\",{\"1\":{\"174\":1,\"284\":1}}],[\"则两个\",{\"1\":{\"149\":1}}],[\"则在上一行的代码中\",{\"1\":{\"138\":1}}],[\"则启用此功能\",{\"1\":{\"126\":1}}],[\"则执行\",{\"1\":{\"76\":1}}],[\"则应该将它们写入不同的文件\",{\"1\":{\"45\":1}}],[\"则返回值为\",{\"1\":{\"8\":1}}],[\"还必须使用\",{\"1\":{\"242\":1}}],[\"还是未指定\",{\"1\":{\"251\":1}}],[\"还是\",{\"1\":{\"193\":1}}],[\"还可以使用\",{\"1\":{\"78\":1}}],[\"还可以根据上下文来推断\",{\"1\":{\"21\":1}}],[\"还有一个更通用的\",{\"1\":{\"288\":1}}],[\"还有它的容量\",{\"1\":{\"154\":1}}],[\"还有\",{\"1\":{\"67\":1,\"164\":1}}],[\"还支持其他类型的依赖\",{\"1\":{\"44\":1}}],[\"还支持更多功能\",{\"1\":{\"43\":1}}],[\"还表示可以接受一个或多个泛型类型参数\",{\"1\":{\"11\":1}}],[\"浮点精度误差会很容易导致错误\",{\"1\":{\"284\":1}}],[\"浮点型默认为\",{\"1\":{\"21\":1}}],[\"浮点数值为\",{\"1\":{\"21\":1}}],[\"浮点数\",{\"1\":{\"20\":1,\"135\":1}}],[\"整型并返回一个\",{\"1\":{\"240\":1}}],[\"整型的函数\",{\"1\":{\"240\":1}}],[\"整型之间的转换大体遵循\",{\"1\":{\"193\":1}}],[\"整型除法\",{\"1\":{\"148\":1}}],[\"整型\",{\"1\":{\"146\":1,\"240\":1}}],[\"整型默认为\",{\"1\":{\"21\":1}}],[\"整数相减\",{\"1\":{\"135\":1}}],[\"整数相加\",{\"1\":{\"135\":1}}],[\"整数\",{\"1\":{\"135\":1}}],[\"整数和浮点数\",{\"1\":{\"15\":1}}],[\"数据的可变性可能发生改变\",{\"1\":{\"281\":1}}],[\"数据仍然存在于二进制文件里面\",{\"1\":{\"275\":1}}],[\"数据在离开作用域时删掉\",{\"1\":{\"268\":1}}],[\"数据可以通过引用或原始类型来访问\",{\"1\":{\"259\":1}}],[\"数据可以多次不可变借用\",{\"1\":{\"259\":1}}],[\"数据\",{\"1\":{\"168\":1}}],[\"数据类型实现\",{\"1\":{\"30\":1}}],[\"数字可以用十六进制\",{\"1\":{\"135\":1}}],[\"数字的平方\",{\"1\":{\"85\":1}}],[\"数字还可以通过后缀\",{\"1\":{\"21\":1}}],[\"数组可以自动被借用成为\",{\"1\":{\"134\":1}}],[\"数组是在栈中分配的\",{\"1\":{\"134\":1}}],[\"数组的类型标记为\",{\"1\":{\"134\":1}}],[\"数组使用中括号\",{\"1\":{\"134\":1}}],[\"数组\",{\"0\":{\"300\":1},\"1\":{\"0\":1,\"21\":1,\"134\":1}}],[\"数组和切片也可以这样解构\",{\"1\":{\"300\":1}}],[\"数组和切片\",{\"0\":{\"134\":1},\"1\":{\"0\":1,\"301\":1}}],[\"尽管单元类型的值是个元组\",{\"1\":{\"20\":1}}],[\"其取值不是\",{\"1\":{\"277\":1}}],[\"其语法会像是\",{\"1\":{\"266\":1}}],[\"其受限制程度按以下顺序递减\",{\"1\":{\"240\":1}}],[\"其类型取决于如何使用它们\",{\"1\":{\"195\":1}}],[\"其类型取决于怎样使用它们\",{\"1\":{\"195\":1}}],[\"其类型在初始化时已经知道了\",{\"1\":{\"195\":1}}],[\"其值是\",{\"1\":{\"193\":1}}],[\"其值可以改变\",{\"1\":{\"21\":1}}],[\"其余的参数是被传递给程序的命令行参数\",{\"1\":{\"156\":1}}],[\"其意义是隐藏信息\",{\"1\":{\"129\":1}}],[\"其参数的数目是由格式化字符串指定的\",{\"1\":{\"116\":1}}],[\"其内容将被解析成\",{\"1\":{\"105\":1}}],[\"其内容将被编译器忽略掉\",{\"1\":{\"105\":1}}],[\"其他情况\",{\"1\":{\"186\":1}}],[\"其他情况必须加上\",{\"1\":{\"83\":1}}],[\"其他的特点包括\",{\"1\":{\"83\":1}}],[\"其他的方法有\",{\"1\":{\"73\":1}}],[\"其他的引用类型都必须特地声明\",{\"1\":{\"55\":1}}],[\"其他的类型都是具体\",{\"1\":{\"11\":1}}],[\"其左上角位于该点上\",{\"1\":{\"61\":1}}],[\"其返回值是\",{\"1\":{\"52\":1}}],[\"其中的元素需要一个接一个地处理到\",{\"1\":{\"310\":1}}],[\"其中将展开\",{\"1\":{\"171\":1}}],[\"其中每个值都能被修改\",{\"1\":{\"154\":1}}],[\"其中大部分是文本\",{\"1\":{\"153\":1}}],[\"其中返回\",{\"1\":{\"151\":1}}],[\"其中重要的两种\",{\"1\":{\"107\":1}}],[\"其中名称匹配一个模式\",{\"1\":{\"45\":1}}],[\"其中一个受欢迎的包是\",{\"1\":{\"44\":1}}],[\"其中\",{\"1\":{\"43\":1,\"86\":1,\"89\":1,\"136\":1,\"158\":1,\"266\":1,\"268\":1,\"270\":2,\"286\":1}}],[\"其唯一可能的值就是\",{\"1\":{\"20\":1}}],[\"404\",{\"1\":{\"313\":1}}],[\"40\",{\"1\":{\"296\":1}}],[\"49\",{\"1\":{\"251\":1}}],[\"4i64\",{\"1\":{\"136\":1}}],[\"4i32\",{\"1\":{\"113\":1,\"141\":1}}],[\"4u64\",{\"1\":{\"136\":2}}],[\"4u32\",{\"1\":{\"114\":1}}],[\"439222222\",{\"1\":{\"219\":1}}],[\"4321\",{\"1\":{\"193\":1}}],[\"435\",{\"1\":{\"146\":1}}],[\"43\",{\"1\":{\"107\":1,\"287\":1}}],[\"42i32\",{\"1\":{\"195\":1}}],[\"42\",{\"1\":{\"67\":1,\"195\":1,\"207\":1,\"209\":1,\"210\":2,\"211\":1,\"213\":1,\"228\":3,\"287\":4}}],[\"4294967296i64\",{\"1\":{\"21\":1}}],[\"4\",{\"1\":{\"20\":1,\"34\":1,\"40\":3,\"60\":1,\"86\":1,\"89\":2,\"107\":1,\"112\":2,\"116\":2,\"134\":2,\"136\":2,\"145\":1,\"147\":1,\"154\":2,\"177\":1,\"185\":2,\"186\":3,\"235\":1,\"266\":1,\"281\":2,\"285\":8,\"298\":2,\"306\":2,\"308\":2}}],[\"∞\",{\"1\":{\"20\":1}}],[\"α\",{\"1\":{\"20\":1}}],[\"如前面学过的\",{\"1\":{\"135\":1}}],[\"如网络服务器\",{\"1\":{\"84\":1}}],[\"如下面例子\",{\"1\":{\"84\":1}}],[\"如下所示\",{\"1\":{\"41\":1,\"302\":1,\"304\":1}}],[\"如基准测试\",{\"1\":{\"43\":1}}],[\"如\",{\"1\":{\"20\":1,\"21\":2,\"24\":1,\"84\":2,\"105\":1,\"191\":1,\"288\":1}}],[\"如果一开始就不用引用\",{\"1\":{\"298\":1}}],[\"如果去掉匹配的\",{\"1\":{\"298\":1}}],[\"如果用\",{\"1\":{\"298\":1}}],[\"如果用户输入的数据中有一大堆空格怎么办\",{\"1\":{\"294\":1}}],[\"如果值已经存在\",{\"1\":{\"285\":1}}],[\"如果值是合法的\",{\"1\":{\"225\":1}}],[\"如果插入的值已经存在于\",{\"1\":{\"285\":1}}],[\"如果感到疑惑\",{\"1\":{\"252\":1}}],[\"如果存储的数字和给定的相等则为真\",{\"1\":{\"244\":1}}],[\"如果存在的话\",{\"1\":{\"219\":1}}],[\"如果对实现了它的容器类型是泛型的\",{\"1\":{\"244\":1}}],[\"如果参数的类型说明是\",{\"1\":{\"240\":1}}],[\"如果它们包含的类型都分别实现了\",{\"1\":{\"284\":1}}],[\"如果它们都输出到文件\",{\"1\":{\"45\":1}}],[\"如果它的值\",{\"1\":{\"228\":1}}],[\"如果使用\",{\"1\":{\"222\":1,\"284\":1}}],[\"如果使用名为的\",{\"1\":{\"126\":1}}],[\"如果发生错误\",{\"1\":{\"220\":1}}],[\"如果在这里使用\",{\"1\":{\"215\":1}}],[\"如果在错误可转换成返回类型地方使用\",{\"1\":{\"211\":1}}],[\"如果以返回类型是\",{\"1\":{\"215\":1}}],[\"如果有省略写法就好了\",{\"1\":{\"211\":1}}],[\"如果不想用\",{\"1\":{\"298\":1}}],[\"如果不修改我们的错误类型定义的话\",{\"1\":{\"209\":1}}],[\"如果不用where\",{\"1\":{\"103\":1}}],[\"如果又想写简单的代码\",{\"1\":{\"207\":1}}],[\"如果没有输入的函数返回引用\",{\"1\":{\"268\":1}}],[\"如果没有食物\",{\"1\":{\"217\":2}}],[\"如果没有限制\",{\"1\":{\"195\":1}}],[\"如果没有特别指定\",{\"1\":{\"73\":1}}],[\"如果函数返回实现了\",{\"1\":{\"185\":1}}],[\"如果函数返回一个值\",{\"1\":{\"10\":1}}],[\"如果取消注释此行\",{\"1\":{\"181\":1}}],[\"如果两个\",{\"1\":{\"181\":1}}],[\"如果两者内部的值相等的话\",{\"1\":{\"149\":1}}],[\"如果需要更复杂的行为\",{\"1\":{\"179\":1}}],[\"如果表达式的值是\",{\"1\":{\"174\":1}}],[\"如果第二个参数是\",{\"1\":{\"170\":1}}],[\"如果字符串中需要写\",{\"1\":{\"153\":1}}],[\"如果被插入的值为新内容\",{\"1\":{\"146\":1}}],[\"如果代码中的生命周期示意图乱掉了\",{\"1\":{\"139\":1}}],[\"如果代码块的最后一个表达式结尾处有分号\",{\"1\":{\"8\":1}}],[\"如果此处不借用\",{\"1\":{\"138\":1}}],[\"如果想要\",{\"1\":{\"125\":1}}],[\"如果向\",{\"1\":{\"118\":1}}],[\"如果觉得这里的说法很别扭的话\",{\"1\":{\"87\":1}}],[\"如果是奇数就计数\",{\"1\":{\"85\":1}}],[\"如果要指明失败情形\",{\"1\":{\"76\":1}}],[\"如果要转换到用户定义类型\",{\"1\":{\"51\":1}}],[\"如果公主期待收到礼物\",{\"1\":{\"68\":1}}],[\"如果你想等待一个\",{\"1\":{\"292\":1}}],[\"如果你想控制更多的细节\",{\"1\":{\"284\":1}}],[\"如果你不想要一样东西出现多于一次\",{\"1\":{\"285\":1}}],[\"如果你声明一个接受闭包作为参数的函数\",{\"1\":{\"238\":1}}],[\"如果你的函数以这种方式返回指向堆的\",{\"1\":{\"184\":1}}],[\"如果你的函数能以多种方式\",{\"1\":{\"175\":1}}],[\"如果你有个像\",{\"1\":{\"184\":1}}],[\"如果你要在原始字符串中写引号\",{\"1\":{\"153\":1}}],[\"如果你需要反斜杠字符\",{\"1\":{\"153\":1}}],[\"如果你为你的类型实现了\",{\"1\":{\"48\":1}}],[\"如果你曾经手动管理过库依赖\",{\"1\":{\"44\":1}}],[\"如果我们能够从类型\",{\"1\":{\"46\":1}}],[\"如果您发布\",{\"1\":{\"44\":1}}],[\"如果继续使用这个无效的输入\",{\"1\":{\"7\":1}}],[\"如果\",{\"1\":{\"5\":1,\"81\":1,\"193\":1,\"215\":1,\"219\":3,\"246\":1,\"286\":2}}],[\"甚至是不可打印的字符以及你不知道如何输入的字符\",{\"1\":{\"153\":1}}],[\"甚至是哪种类型的库\",{\"1\":{\"38\":1}}],[\"甚至其它模块\",{\"1\":{\"18\":1}}],[\"甚至可以在循环或\",{\"1\":{\"10\":1}}],[\"块注释可以\",{\"1\":{\"105\":1}}],[\"块注释\",{\"1\":{\"105\":2}}],[\"块要想实现泛型\",{\"1\":{\"95\":1}}],[\"块中使用\",{\"1\":{\"58\":1}}],[\"块\",{\"1\":{\"18\":1,\"181\":1}}],[\"系统\",{\"1\":{\"18\":1,\"164\":1}}],[\"对每个元素\",{\"1\":{\"310\":1}}],[\"对一个\",{\"1\":{\"310\":1}}],[\"对一个结构体实现\",{\"1\":{\"310\":1}}],[\"对迭代器举出的元素的引用是\",{\"1\":{\"308\":2}}],[\"对数组的\",{\"1\":{\"306\":2,\"308\":2}}],[\"对数值字面量\",{\"1\":{\"195\":1}}],[\"对这种情况提供了\",{\"1\":{\"298\":1}}],[\"对指针来说\",{\"1\":{\"298\":1}}],[\"对返回的数字类型的迭代器求和\",{\"1\":{\"293\":1}}],[\"对该段中的字符进行迭代\",{\"1\":{\"293\":1}}],[\"对分段的数据进行迭代\",{\"1\":{\"293\":1}}],[\"对称差\",{\"1\":{\"285\":1}}],[\"对自定义类型可以轻松地实现\",{\"1\":{\"284\":1}}],[\"对下面这种情形\",{\"1\":{\"268\":1}}],[\"对闭包所要捕获的每个变量\",{\"1\":{\"240\":1}}],[\"对有些人来说\",{\"1\":{\"220\":1}}],[\"对x\",{\"1\":{\"219\":1}}],[\"对任何实现了\",{\"1\":{\"207\":1}}],[\"对任何数据类型都可以实现\",{\"1\":{\"30\":1}}],[\"对浮点数使用\",{\"1\":{\"195\":1}}],[\"对正数\",{\"1\":{\"193\":1}}],[\"对象\",{\"1\":{\"184\":1,\"213\":1}}],[\"对象可以通过引用\",{\"1\":{\"138\":1}}],[\"对内存错误进行仔细检查\",{\"1\":{\"141\":1}}],[\"对文档来说\",{\"1\":{\"122\":1}}],[\"对被叫到的\",{\"1\":{\"118\":1}}],[\"对泛型的调用者类型\",{\"1\":{\"93\":1}}],[\"对关联类型的定义是\",{\"1\":{\"87\":1}}],[\"对于所有的集合类\",{\"1\":{\"284\":1}}],[\"对于省略的详细描述\",{\"1\":{\"264\":1}}],[\"对于约束该结构体的类型而言就已经足够了\",{\"1\":{\"233\":1}}],[\"对于\",{\"1\":{\"107\":1,\"256\":1}}],[\"对于泛型\",{\"1\":{\"101\":1}}],[\"对于实现了它的容器类型是泛型的\",{\"1\":{\"87\":1}}],[\"对于单个表达式是可选的\",{\"1\":{\"83\":1}}],[\"对于事件的处理\",{\"1\":{\"70\":1}}],[\"对于本章的其余部分\",{\"1\":{\"44\":1}}],[\"对单元和集成测试提供一流的支持\",{\"1\":{\"45\":1}}],[\"对\",{\"1\":{\"30\":1,\"111\":1,\"114\":1,\"146\":1,\"221\":1,\"306\":2,\"308\":2,\"310\":2}}],[\"对功能进行基准测试\",{\"1\":{\"17\":1}}],[\"对类型\",{\"1\":{\"11\":1}}],[\"生成帮助文档\",{\"1\":{\"105\":1}}],[\"生成错误\",{\"1\":{\"67\":2}}],[\"生成库文档给用户\",{\"1\":{\"17\":1}}],[\"生命周期也可被强制转换成一个更短的生命周期\",{\"1\":{\"275\":1}}],[\"生命周期是可能的生命周期中最长的\",{\"1\":{\"275\":1}}],[\"生命周期比\",{\"1\":{\"266\":1}}],[\"生命周期会被隐式地添加进\",{\"1\":{\"264\":1}}],[\"生命周期的常量\",{\"1\":{\"275\":1}}],[\"生命周期的\",{\"1\":{\"55\":1}}],[\"生命周期\",{\"0\":{\"139\":1},\"1\":{\"0\":1,\"55\":1,\"56\":1,\"139\":1,\"270\":1,\"275\":2}}],[\"使数据的并行化处理非常简单\",{\"1\":{\"293\":1}}],[\"使它在一个通常情况下不能工作的作用域内也能正常工作\",{\"1\":{\"272\":1}}],[\"使它可以没有错误地运行\",{\"1\":{\"108\":1}}],[\"使这个\",{\"1\":{\"254\":1}}],[\"使这项工作变得相当简单\",{\"1\":{\"254\":1}}],[\"使闭包在没有类型标注的情况下运行\",{\"1\":{\"235\":1}}],[\"使类型具有\",{\"1\":{\"179\":1}}],[\"使得数据总是被分成有限数目的段\",{\"1\":{\"294\":1}}],[\"使得仅显示\",{\"1\":{\"256\":1}}],[\"使得函数只在当前\",{\"1\":{\"133\":1}}],[\"使得它们可组合且易于交互\",{\"1\":{\"67\":1}}],[\"使得软件对每个人都变得更易用\",{\"1\":{\"17\":1}}],[\"使整个操作失败\",{\"0\":{\"65\":1}}],[\"使之拥有\",{\"1\":{\"55\":1}}],[\"使用元组的下标获取值\",{\"1\":{\"310\":1}}],[\"使用涡轮鱼写法帮助类型推断\",{\"1\":{\"295\":1}}],[\"使用迭代器\",{\"1\":{\"290\":1}}],[\"使用生命周期需要泛型\",{\"1\":{\"266\":1}}],[\"使用省略仅仅是因为这些模式太普遍了\",{\"1\":{\"264\":1}}],[\"使用一样的方式打印\",{\"1\":{\"257\":1}}],[\"使用与下面的函数完全一致的函数签名\",{\"1\":{\"256\":1}}],[\"使用关联类型\",{\"1\":{\"246\":1}}],[\"使用可变借用调用闭包\",{\"1\":{\"235\":1}}],[\"使用借用来调用闭包\",{\"1\":{\"235\":1}}],[\"使用未限定类型的参数\",{\"1\":{\"233\":1}}],[\"使用简单的\",{\"1\":{\"225\":1}}],[\"使用简单的写法初始化字段\",{\"1\":{\"60\":1}}],[\"使用下面的代码\",{\"1\":{\"225\":1}}],[\"使用下划线改善数字的可读性\",{\"1\":{\"135\":1}}],[\"使用上面定义过的别名来表示上一节中的\",{\"1\":{\"223\":1}}],[\"使用被\",{\"1\":{\"215\":1}}],[\"使用自定义的\",{\"1\":{\"200\":1}}],[\"使用了未初始化的绑定\",{\"1\":{\"196\":1}}],[\"使用了借用\",{\"1\":{\"138\":1}}],[\"使用共用模块\",{\"1\":{\"173\":1}}],[\"使用操作系统特定的分隔符来合并路径到一个字节容器\",{\"1\":{\"164\":1}}],[\"使用独立变量\",{\"1\":{\"154\":1}}],[\"使用此属性来告诉\",{\"1\":{\"122\":1}}],[\"使用非泛型函数\",{\"1\":{\"91\":1}}],[\"使用显式指定的类型参数会像是这样\",{\"1\":{\"91\":1}}],[\"使用时相当方便\",{\"1\":{\"83\":1}}],[\"使用的缩进更少\",{\"1\":{\"81\":1}}],[\"使用结构体更新语法创建新的\",{\"1\":{\"60\":1}}],[\"使用原始标志符重写上述代码\",{\"1\":{\"40\":1}}],[\"使用旧版\",{\"1\":{\"40\":1}}],[\"使用类型推断\",{\"1\":{\"31\":1}}],[\"使用模块来组织代码\",{\"1\":{\"15\":1}}],[\"使用在上面定义的\",{\"1\":{\"11\":1}}],[\"使用场景也不尽相同\",{\"1\":{\"7\":1}}],[\"使用库\",{\"0\":{\"54\":1},\"1\":{\"0\":1}}],[\"使用\",{\"0\":{\"16\":1,\"64\":1,\"65\":1,\"66\":1,\"125\":1,\"184\":1,\"203\":1,\"219\":1},\"1\":{\"0\":4,\"4\":1,\"7\":2,\"10\":1,\"11\":2,\"13\":2,\"35\":1,\"40\":1,\"48\":1,\"60\":2,\"65\":1,\"76\":3,\"81\":1,\"103\":1,\"107\":2,\"108\":1,\"114\":1,\"133\":4,\"154\":1,\"173\":1,\"178\":1,\"179\":1,\"203\":1,\"246\":1,\"254\":2,\"256\":4,\"270\":1,\"275\":2,\"298\":1,\"310\":3}}],[\"为上面的\",{\"1\":{\"252\":1}}],[\"为带有错误类型\",{\"1\":{\"223\":1}}],[\"为它们提供了到\",{\"1\":{\"207\":1}}],[\"为方便起见\",{\"1\":{\"186\":1}}],[\"为测试这种行为\",{\"1\":{\"175\":1}}],[\"为线程之间的通信提供了异步的通道\",{\"1\":{\"158\":1}}],[\"为做到这点\",{\"1\":{\"151\":1}}],[\"为避免中文的显示问题\",{\"1\":{\"139\":1}}],[\"为实现这点\",{\"1\":{\"138\":1}}],[\"为元素类型\",{\"1\":{\"134\":1}}],[\"为注释所属于的项\",{\"1\":{\"105\":1}}],[\"为接下来的项生成帮助文档\",{\"1\":{\"105\":1}}],[\"为\",{\"1\":{\"86\":2,\"91\":2,\"107\":1,\"170\":1,\"186\":1,\"205\":3,\"207\":1,\"209\":1,\"211\":1,\"246\":1,\"249\":1}}],[\"为什么必须写这样的语句呢\",{\"1\":{\"81\":1}}],[\"为什么宏是有用的\",{\"1\":{\"16\":1}}],[\"为空\",{\"1\":{\"67\":1}}],[\"为了试验\",{\"1\":{\"284\":1}}],[\"为了比较\",{\"1\":{\"256\":1}}],[\"为了使用\",{\"1\":{\"256\":1}}],[\"为了使得\",{\"1\":{\"43\":1}}],[\"为了确定\",{\"1\":{\"225\":1}}],[\"为了消除它们之间的歧义\",{\"1\":{\"181\":1}}],[\"为了改善可读性\",{\"1\":{\"135\":1}}],[\"为了改善错误消息的质量\",{\"1\":{\"70\":1}}],[\"为了达到练习目的\",{\"1\":{\"108\":1}}],[\"为了解决这个问题\",{\"1\":{\"41\":1}}],[\"为前缀的行将由\",{\"1\":{\"42\":1}}],[\"为库创建测试套件\",{\"1\":{\"17\":1}}],[\"为把\",{\"1\":{\"11\":1}}],[\"此方法必须将格式化后的字符串写入其中\",{\"1\":{\"251\":1}}],[\"此方法获得两个传入参数的所有权\",{\"1\":{\"93\":1}}],[\"此绑定同样\",{\"1\":{\"199\":1}}],[\"此绑定\",{\"1\":{\"199\":1}}],[\"此绑定只存在于本代码块\",{\"1\":{\"199\":1}}],[\"此绑定生存于\",{\"1\":{\"199\":1}}],[\"此容量指明了要为这个\",{\"1\":{\"154\":1}}],[\"此操作是有效的\",{\"1\":{\"151\":1}}],[\"此操作将会失败\",{\"1\":{\"151\":1}}],[\"此操作将会引发一个任务失败\",{\"1\":{\"148\":1}}],[\"此时堆内存已经被释放\",{\"1\":{\"140\":1}}],[\"此生命周期由它声明的位置决定\",{\"1\":{\"139\":1}}],[\"此函数接受一个对可变的\",{\"1\":{\"261\":1}}],[\"此函数接受一个对\",{\"1\":{\"261\":1}}],[\"此函数处理可能失败的除法\",{\"1\":{\"147\":1}}],[\"此函数从\",{\"1\":{\"140\":1}}],[\"此函数取得堆分配的内存的所有权\",{\"1\":{\"140\":1}}],[\"此函数取得一个\",{\"1\":{\"138\":1}}],[\"此函数借用了一个\",{\"1\":{\"138\":1}}],[\"此函数借用一个\",{\"1\":{\"134\":1}}],[\"此函数将一个\",{\"1\":{\"57\":1}}],[\"此\",{\"1\":{\"132\":1,\"256\":1}}],[\"此作用域中一个名为\",{\"1\":{\"128\":1}}],[\"此声明将会查找名为\",{\"1\":{\"128\":1}}],[\"此外\",{\"1\":{\"125\":1}}],[\"此宏接受一个\",{\"1\":{\"110\":2}}],[\"此宏将会展开成这个代码块里面的内容\",{\"1\":{\"16\":1}}],[\"此次泛型具体化失败\",{\"1\":{\"89\":1}}],[\"此元素不能解析成数字\",{\"1\":{\"67\":1}}],[\"此模块的操作通常与任何其他模块相同\",{\"1\":{\"54\":1}}],[\"此脚本通过\",{\"1\":{\"42\":1}}],[\"此文件可实现满足\",{\"1\":{\"42\":1}}],[\"此文件将在编译包中的任何其他内容之前\",{\"1\":{\"42\":1}}],[\"此关键字\",{\"1\":{\"40\":1}}],[\"此处的\",{\"1\":{\"246\":1}}],[\"此处的关键是将单词添加\",{\"1\":{\"125\":1}}],[\"此处我们显式地指定了类型参数\",{\"1\":{\"95\":1}}],[\"此处\",{\"1\":{\"11\":1}}],[\"表明变量是通过值传递给闭包\",{\"1\":{\"306\":1}}],[\"表明函数的调用者可以被借用和修改\",{\"1\":{\"306\":1,\"308\":1}}],[\"表明链表结束\",{\"1\":{\"205\":1}}],[\"表明失败或缺少值\",{\"1\":{\"147\":1}}],[\"表示不将值绑定到变量\",{\"1\":{\"304\":1}}],[\"表示被捕获的变量最多只能被修改\",{\"1\":{\"306\":1,\"308\":1}}],[\"表示被\",{\"1\":{\"298\":1}}],[\"表示取引用\",{\"1\":{\"298\":1}}],[\"表示\",{\"1\":{\"249\":1}}],[\"表示捕获方式为通过值\",{\"1\":{\"240\":1}}],[\"表示捕获方式为通过可变引用\",{\"1\":{\"240\":1}}],[\"表示捕获方式为通过引用\",{\"1\":{\"240\":1}}],[\"表示操作失败\",{\"1\":{\"151\":1}}],[\"表示操作成功\",{\"1\":{\"151\":1}}],[\"表示数组大小\",{\"1\":{\"134\":1}}],[\"表示可能的失败\",{\"1\":{\"70\":1}}],[\"表示实现者类型\",{\"1\":{\"30\":1}}],[\"表示此宏不接受任何参数\",{\"1\":{\"16\":1}}],[\"表达式语言\",{\"1\":{\"293\":1}}],[\"表达式返回\",{\"1\":{\"227\":1}}],[\"表达式求值将返回底层值\",{\"1\":{\"219\":1}}],[\"表达式不返回\",{\"1\":{\"84\":1}}],[\"表达式的返回值必须为\",{\"1\":{\"84\":1}}],[\"表达式或者\",{\"1\":{\"83\":1}}],[\"表达式\",{\"0\":{\"8\":1},\"1\":{\"0\":1,\"8\":1,\"15\":1,\"286\":1}}],[\"名为\",{\"1\":{\"16\":1}}],[\"名称\",{\"1\":{\"1\":1}}],[\"只支持返回具体\",{\"1\":{\"242\":1}}],[\"只知道它是某种东西构成的向量\",{\"1\":{\"194\":1}}],[\"只需加上一行代码\",{\"1\":{\"284\":1}}],[\"只需传引用就能使用\",{\"1\":{\"235\":1}}],[\"只需要写\",{\"1\":{\"195\":1}}],[\"只需要实现那个类型的\",{\"1\":{\"50\":1}}],[\"只需定义一个能返回\",{\"1\":{\"186\":1}}],[\"只需定义一个返回\",{\"1\":{\"186\":1}}],[\"只是它的一个实现\",{\"1\":{\"285\":1}}],[\"只是引用\",{\"1\":{\"282\":1}}],[\"只是获取了不可变的引用\",{\"1\":{\"240\":1}}],[\"只是对堆中某些内存的引用\",{\"1\":{\"184\":1}}],[\"只是因为好玩\",{\"1\":{\"141\":1}}],[\"只适用于它后面的模块\",{\"1\":{\"107\":1}}],[\"只要为我们的错误类型实现\",{\"1\":{\"211\":1}}],[\"只要为那些需要自己的析构函数逻辑的类型实现就可以了\",{\"1\":{\"142\":1}}],[\"只要把类型作为后缀加上去\",{\"1\":{\"195\":1}}],[\"只要把测试名称传给\",{\"1\":{\"176\":1}}],[\"只要该借用在出借者\",{\"1\":{\"139\":1}}],[\"只要满足这点\",{\"1\":{\"89\":1}}],[\"只要手动实现fromstr\",{\"1\":{\"51\":1}}],[\"只要对目标类型实现了\",{\"1\":{\"51\":1}}],[\"只编译或运行这个二进制可执行文件\",{\"1\":{\"43\":1}}],[\"只能是\",{\"1\":{\"20\":1}}],[\"只不过名称末尾有一个感叹号\",{\"1\":{\"16\":1}}],[\"只有一个方法\",{\"1\":{\"183\":1}}],[\"只有从结构体被定义的模块之外访问其字段时\",{\"1\":{\"129\":1}}],[\"只有实现了fmt\",{\"1\":{\"107\":1}}],[\"只有\",{\"1\":{\"5\":1}}],[\"提示\",{\"1\":{\"108\":1,\"181\":1}}],[\"提供类型提示\",{\"1\":{\"293\":1}}],[\"提供额外的类型安全\",{\"1\":{\"191\":1}}],[\"提供一个\",{\"1\":{\"167\":1}}],[\"提供的\",{\"1\":{\"142\":1}}],[\"提供给程序的都是正确的类型\",{\"1\":{\"99\":1}}],[\"提供另一种失败情况下的条件\",{\"1\":{\"76\":1}}],[\"提供输出\",{\"1\":{\"42\":1}}],[\"提供了到\",{\"1\":{\"159\":1}}],[\"提供了编写命令行应用的额外功能\",{\"1\":{\"157\":1}}],[\"提供了高阶函数\",{\"1\":{\"85\":1}}],[\"提供了\",{\"1\":{\"78\":1,\"228\":1,\"254\":1}}],[\"提供了多种机制\",{\"1\":{\"31\":1}}],[\"提供了多种原生类型\",{\"1\":{\"19\":1}}],[\"提供了一系列的运算符\",{\"1\":{\"135\":1}}],[\"提供了一套强大的模块\",{\"1\":{\"18\":1}}],[\"提供了一个强大的宏系统\",{\"1\":{\"16\":1}}],[\"提前返回\",{\"0\":{\"220\":1},\"1\":{\"0\":1,\"10\":1}}],[\"处理混合错误类型的最基本的手段就是让它们互相包含\",{\"1\":{\"210\":1}}],[\"处理一个\",{\"1\":{\"205\":1}}],[\"处理其他情况\",{\"1\":{\"79\":1}}],[\"处理\",{\"1\":{\"15\":1}}],[\"处理多种错误类型\",{\"0\":{\"67\":1},\"1\":{\"0\":1}}],[\"特别是处理更大的文件\",{\"1\":{\"290\":1}}],[\"特别是当操作只对一种输入是有效的时\",{\"1\":{\"217\":1}}],[\"特征\",{\"1\":{\"107\":1}}],[\"特性会自动实现\",{\"1\":{\"107\":1}}],[\"特性\",{\"1\":{\"15\":1}}],[\"特质\",{\"0\":{\"30\":1},\"1\":{\"0\":1,\"107\":1}}],[\"了实现了\",{\"1\":{\"249\":1}}],[\"了前面的绑定\",{\"1\":{\"199\":1}}],[\"了外面的绑定\",{\"1\":{\"199\":1}}],[\"了两个父\",{\"1\":{\"189\":1}}],[\"了资源\",{\"1\":{\"178\":1}}],[\"了\",{\"1\":{\"44\":1,\"73\":1,\"153\":1,\"174\":1,\"189\":1,\"221\":1,\"246\":1,\"286\":2,\"291\":1}}],[\"了解列举到的各个方法\",{\"1\":{\"275\":1}}],[\"了解显式生命周期标注的运用\",{\"1\":{\"266\":1}}],[\"了解如何进入不安全操作块\",{\"1\":{\"15\":1}}],[\"了解表达式以及如何使用\",{\"1\":{\"15\":1}}],[\"了错误\",{\"1\":{\"7\":1}}],[\"学习\",{\"1\":{\"15\":2}}],[\"学习编写能够适用于多种类型参数的函数或数据类型\",{\"1\":{\"15\":1}}],[\"学习官方的\",{\"1\":{\"15\":1}}],[\"学习创建一个库\",{\"1\":{\"15\":1}}],[\"学习方法\",{\"1\":{\"15\":1}}],[\"学习改变和定义类型\",{\"1\":{\"15\":1}}],[\"学习有符号整型\",{\"1\":{\"15\":1}}],[\"内存得到释放\",{\"1\":{\"141\":3}}],[\"内部是空的\",{\"1\":{\"247\":1}}],[\"内部的\",{\"1\":{\"219\":1}}],[\"内部的各个名称\",{\"1\":{\"203\":1}}],[\"内部的对象会被销毁\",{\"1\":{\"145\":1}}],[\"内部的另一个模块\",{\"1\":{\"131\":1}}],[\"内部的元素\",{\"1\":{\"68\":1}}],[\"内部定义新的项\",{\"1\":{\"87\":1}}],[\"内部使用\",{\"1\":{\"10\":1}}],[\"内联汇编\",{\"1\":{\"32\":1}}],[\"内容由一系列可运行的实例组成\",{\"1\":{\"15\":1}}],[\"速度\",{\"1\":{\"15\":1}}],[\"感谢您的支持和帮助\",{\"1\":{\"15\":1}}],[\"若发生错误\",{\"1\":{\"310\":1}}],[\"若发现本页表达错误或帮助我们改进翻译\",{\"1\":{\"15\":1}}],[\"若传给它一个迭代器\",{\"1\":{\"306\":1}}],[\"若文件已经存在\",{\"1\":{\"288\":1}}],[\"若一个集合\",{\"1\":{\"285\":1}}],[\"若要给类型显式地标注生命周期\",{\"1\":{\"266\":1}}],[\"若要打印自定义类型的文本\",{\"1\":{\"107\":1}}],[\"若使用闭包作为函数参数\",{\"1\":{\"233\":1}}],[\"若使用类型别名\",{\"1\":{\"58\":1}}],[\"若间接地访问一个变量\",{\"1\":{\"228\":1}}],[\"若操作返回一个值\",{\"1\":{\"227\":1}}],[\"若某个\",{\"1\":{\"223\":1}}],[\"若想用\",{\"1\":{\"254\":1}}],[\"若想用键盘操作\",{\"1\":{\"13\":1}}],[\"若想提供更多信息\",{\"1\":{\"213\":1}}],[\"若无可用消息的话\",{\"1\":{\"158\":1}}],[\"若需要在编码间转换\",{\"1\":{\"153\":1}}],[\"若大于上限则退出循环\",{\"1\":{\"85\":1}}],[\"若\",{\"1\":{\"76\":1,\"284\":1}}],[\"点击页面右上角语言图标可切换到相同章节的英文页面\",{\"1\":{\"15\":1}}],[\"翻译项目和源码\",{\"1\":{\"15\":1}}],[\"翻译自\",{\"1\":{\"15\":1}}],[\"查看此书的\",{\"1\":{\"15\":1}}],[\"查看更多\",{\"1\":{\"15\":1}}],[\"本指南不包含实现\",{\"1\":{\"284\":1}}],[\"本小节列出几个标准库中使用闭包的例子\",{\"1\":{\"237\":1}}],[\"本身\",{\"1\":{\"235\":1}}],[\"本例中我们会使它失败\",{\"1\":{\"174\":1}}],[\"本例中的\",{\"1\":{\"103\":1}}],[\"本句采用意译\",{\"1\":{\"41\":1}}],[\"本站支持文档中英文切换\",{\"1\":{\"15\":1}}],[\"本站还提供了\",{\"1\":{\"15\":1}}],[\"本章将介绍一些快速入门的基础知识\",{\"1\":{\"2\":1}}],[\"权威指南\",{\"1\":{\"15\":1}}],[\"👉\",{\"1\":{\"15\":1}}],[\"😉\",{\"1\":{\"8\":1}}],[\"动态分发\",{\"1\":{\"208\":1}}],[\"动态数组\",{\"0\":{\"154\":1},\"1\":{\"0\":1}}],[\"动手试一试\",{\"0\":{\"14\":1,\"61\":1,\"108\":1,\"137\":1,\"252\":1,\"257\":1,\"311\":1},\"1\":{\"136\":1}}],[\"$right\",{\"1\":{\"113\":6}}],[\"$left\",{\"1\":{\"113\":6}}],[\"$es\",{\"1\":{\"116\":2}}],[\"$e\",{\"1\":{\"112\":3,\"116\":5}}],[\"$expression\",{\"1\":{\"110\":3}}],[\"$z\",{\"1\":{\"111\":2}}],[\"$y\",{\"1\":{\"111\":2,\"114\":2}}],[\"$x\",{\"1\":{\"111\":2,\"114\":4}}],[\"$method\",{\"1\":{\"111\":3}}],[\"$op\",{\"1\":{\"111\":4}}],[\"$bound<t\",{\"1\":{\"111\":1}}],[\"$bound\",{\"1\":{\"111\":2}}],[\"$b\",{\"1\":{\"111\":3}}],[\"$a\",{\"1\":{\"111\":3}}],[\"$func<t\",{\"1\":{\"111\":1}}],[\"$func\",{\"1\":{\"110\":3,\"111\":7}}],[\"$\",{\"1\":{\"13\":2,\"38\":2,\"45\":2,\"53\":2,\"54\":1,\"110\":1,\"111\":1,\"114\":3,\"116\":2,\"118\":2,\"128\":2,\"141\":1,\"148\":1,\"156\":2,\"161\":2,\"170\":1,\"173\":1,\"174\":1,\"175\":1,\"176\":2,\"177\":2,\"200\":2,\"287\":5,\"288\":3,\"289\":2,\"290\":2,\"292\":1}}],[\"调用了我们对\",{\"1\":{\"249\":1}}],[\"调用了针对\",{\"1\":{\"249\":1}}],[\"调用闭包时\",{\"1\":{\"235\":1}}],[\"调用可以串起来\",{\"1\":{\"217\":1}}],[\"调用都换成\",{\"1\":{\"211\":1}}],[\"调用并展开\",{\"1\":{\"171\":1}}],[\"调用外部语言函数是不安全操作\",{\"1\":{\"159\":1}}],[\"调用者本身和一个输入参数\",{\"1\":{\"93\":1}}],[\"调用者的资源\",{\"1\":{\"86\":1}}],[\"调用泛型函数有时需要显式地指明类型参量\",{\"1\":{\"91\":1}}],[\"调用\",{\"1\":{\"86\":1,\"131\":1,\"195\":1}}],[\"调用一个闭包和调用一个函数完全相同\",{\"1\":{\"83\":1}}],[\"调用不安全操作的安全的\",{\"1\":{\"159\":1}}],[\"调用不安全函数\",{\"0\":{\"34\":1}}],[\"调用不安全的函数\",{\"1\":{\"32\":1}}],[\"调用函数时\",{\"1\":{\"91\":1}}],[\"调用函数和闭包\",{\"1\":{\"83\":1}}],[\"调用函数\",{\"1\":{\"32\":1,\"240\":1}}],[\"调用编译生成的可执行文件时\",{\"1\":{\"13\":1}}],[\"调试\",{\"0\":{\"254\":1},\"1\":{\"0\":1}}],[\"通常举出\",{\"1\":{\"308\":1}}],[\"通常看起来不太简洁\",{\"1\":{\"256\":1}}],[\"通常特殊字符是使用反斜杠字符\",{\"1\":{\"153\":1}}],[\"通常情况下\",{\"1\":{\"107\":1}}],[\"通常\",{\"1\":{\"76\":1,\"178\":1}}],[\"通常使用这种\",{\"1\":{\"55\":1}}],[\"通常要求指明要转换到的类型\",{\"1\":{\"48\":1}}],[\"通过用\",{\"1\":{\"306\":1}}],[\"通过不可变引用\",{\"1\":{\"261\":1}}],[\"通过实现一个带虚类型参数的\",{\"1\":{\"249\":1}}],[\"通过把容器内部的类型放到\",{\"1\":{\"246\":1}}],[\"通过值捕获\",{\"1\":{\"240\":1}}],[\"通过值\",{\"1\":{\"235\":1}}],[\"通过可变引用来改变\",{\"1\":{\"263\":1}}],[\"通过可变引用来修改数据\",{\"1\":{\"259\":1}}],[\"通过可变引用\",{\"1\":{\"235\":1}}],[\"通过引用捕获\",{\"1\":{\"240\":2}}],[\"通过引用\",{\"1\":{\"235\":2}}],[\"通过这个属性屏蔽警告\",{\"1\":{\"191\":1}}],[\"通过这些例子阐明了各种\",{\"1\":{\"15\":1}}],[\"通过颠倒类型\",{\"1\":{\"187\":1}}],[\"通过转义\",{\"1\":{\"153\":1}}],[\"通过键\",{\"1\":{\"146\":1}}],[\"通过整型下标来存储值\",{\"1\":{\"146\":1}}],[\"通过创建\",{\"1\":{\"145\":1}}],[\"通过借用检查\",{\"1\":{\"138\":1}}],[\"通过元组的下标来访问具体的值\",{\"1\":{\"136\":1}}],[\"通过加前缀\",{\"1\":{\"135\":1}}],[\"通过提取函数或测试集的公共部分\",{\"1\":{\"111\":1}}],[\"通过控制显示的小数位数来打印\",{\"1\":{\"108\":1}}],[\"通过在\",{\"1\":{\"107\":1}}],[\"通过点运算符来访问结构体字段\",{\"1\":{\"86\":1}}],[\"通过闭包和函数分别实现自增\",{\"1\":{\"83\":1}}],[\"通过上面链接的关于测试章节\",{\"1\":{\"45\":1}}],[\"通过此处指定的可以使用的环境变量为脚本提供输入\",{\"1\":{\"42\":1}}],[\"通过静态类型确保类型安全\",{\"1\":{\"35\":1}}],[\"通过\",{\"1\":{\"32\":1,\"79\":1,\"167\":1,\"179\":1,\"207\":1,\"233\":1,\"298\":1}}],[\"通过附带的\",{\"1\":{\"17\":1}}],[\"通过内存安全来实现以上目标\",{\"1\":{\"15\":1}}],[\"通过例子学\",{\"0\":{\"15\":1},\"1\":{\"15\":2}}],[\"通过单击\",{\"1\":{\"13\":1}}],[\"通道有两个端点\",{\"1\":{\"158\":1}}],[\"通道允许两个端点之间信息的单向流动\",{\"1\":{\"158\":1}}],[\"通道\",{\"0\":{\"158\":1},\"1\":{\"0\":1}}],[\"你仍然可以用它作为约束\",{\"1\":{\"247\":1}}],[\"你很可能想知道函数是否也可以呢\",{\"1\":{\"238\":1}}],[\"你就可以轻松地做到这一点\",{\"1\":{\"185\":1}}],[\"你就可以在程序中开始使用\",{\"1\":{\"44\":1}}],[\"你无需为每种类型都实现\",{\"1\":{\"142\":1}}],[\"你看到结果了吗\",{\"1\":{\"105\":1}}],[\"你想挑战一下吗\",{\"1\":{\"76\":1}}],[\"你可能会问\",{\"1\":{\"285\":1}}],[\"你可能会遇到返回\",{\"1\":{\"70\":1}}],[\"你可能需要多次列出每个颜色\",{\"1\":{\"252\":1}}],[\"你可以手动实现\",{\"1\":{\"284\":1}}],[\"你可以通过手动实现\",{\"1\":{\"254\":1}}],[\"你可以将多个\",{\"1\":{\"219\":1}}],[\"你可以使用\",{\"1\":{\"219\":1,\"252\":1}}],[\"你可以写\",{\"1\":{\"171\":1}}],[\"你可以让示例代码运行和编辑\",{\"1\":{\"125\":1}}],[\"你可以书写代码块\",{\"1\":{\"118\":1}}],[\"你可以直接从周围变量捕获参数\",{\"1\":{\"107\":1}}],[\"你可以在数字左边补\",{\"1\":{\"107\":1}}],[\"你可以在\",{\"1\":{\"44\":1}}],[\"你可以自由地修改代码\",{\"1\":{\"13\":1}}],[\"你会发现所有东西还在\",{\"1\":{\"66\":1}}],[\"你还可以运行如下测试\",{\"1\":{\"45\":1}}],[\"你将会看到像这样的输出\",{\"1\":{\"45\":1}}],[\"你已经在前面的章节中看到\",{\"1\":{\"16\":1}}],[\"你也可以使用\",{\"1\":{\"310\":1}}],[\"你也可以使用绑定来\",{\"1\":{\"228\":1}}],[\"你也可以绑定一些而忽略其余的\",{\"1\":{\"300\":1}}],[\"你也可以\",{\"1\":{\"7\":1}}],[\"参考\",{\"0\":{\"202\":1}}],[\"参考中的\",{\"1\":{\"153\":1}}],[\"参数并调用它\",{\"1\":{\"238\":1}}],[\"参数\",{\"1\":{\"118\":2,\"306\":1,\"308\":1}}],[\"参数可以任意组合\",{\"1\":{\"113\":1}}],[\"参数不需要使用逗号隔开\",{\"1\":{\"113\":1}}],[\"参数从紧接在格式字符串之后的\",{\"1\":{\"107\":1}}],[\"参数是一种在运行时不出现\",{\"1\":{\"101\":1}}],[\"参数解析\",{\"0\":{\"287\":1},\"1\":{\"0\":1}}],[\"参见\",{\"0\":{\"12\":1,\"22\":1,\"25\":1,\"27\":1,\"29\":1,\"37\":1,\"56\":1,\"59\":1,\"62\":1,\"74\":1,\"77\":1,\"82\":1,\"88\":1,\"90\":1,\"92\":1,\"94\":1,\"96\":1,\"98\":1,\"102\":1,\"104\":1,\"106\":1,\"109\":1,\"123\":1,\"127\":1,\"130\":1,\"143\":1,\"150\":1,\"162\":1,\"165\":1,\"169\":1,\"172\":1,\"180\":1,\"182\":1,\"188\":1,\"190\":1,\"192\":1,\"204\":1,\"206\":1,\"208\":1,\"212\":1,\"216\":1,\"218\":1,\"224\":1,\"229\":1,\"232\":1,\"234\":1,\"236\":1,\"239\":1,\"241\":1,\"243\":1,\"245\":1,\"248\":1,\"250\":1,\"253\":1,\"255\":1,\"258\":1,\"262\":1,\"265\":1,\"267\":1,\"269\":1,\"271\":1,\"274\":1,\"276\":1,\"278\":1,\"280\":1,\"283\":1,\"295\":1,\"297\":1,\"299\":1,\"301\":1,\"303\":1,\"305\":1,\"307\":1,\"309\":1,\"312\":1},\"1\":{\"45\":1,\"285\":1}}],[\"61\",{\"1\":{\"219\":2}}],[\"65\",{\"1\":{\"193\":1}}],[\"6743\",{\"1\":{\"146\":1}}],[\"69920216438980873548808413720956532\",{\"1\":{\"293\":1}}],[\"696\",{\"1\":{\"141\":1}}],[\"69420\",{\"1\":{\"107\":5}}],[\"648\",{\"1\":{\"148\":1}}],[\"645\",{\"1\":{\"146\":2}}],[\"64\",{\"1\":{\"134\":2}}],[\"6u32\",{\"1\":{\"111\":1}}],[\"6\",{\"1\":{\"11\":1,\"50\":2,\"91\":1,\"136\":1,\"138\":1,\"251\":1,\"298\":1,\"300\":1,\"306\":2,\"308\":2}}],[\"并用\",{\"1\":{\"310\":1}}],[\"并用逗号分隔\",{\"1\":{\"125\":1}}],[\"并进行初始化处理\",{\"1\":{\"293\":1}}],[\"并集\",{\"1\":{\"285\":1}}],[\"并为它实现\",{\"1\":{\"233\":1}}],[\"并不是\",{\"1\":{\"191\":1}}],[\"并不能\",{\"1\":{\"191\":1}}],[\"并在其上返回一个迭代器\",{\"1\":{\"185\":1}}],[\"并在它们放到各自的模块中\",{\"1\":{\"128\":1}}],[\"并返回该\",{\"1\":{\"205\":1}}],[\"并返回新的路径\",{\"1\":{\"164\":1}}],[\"并返回一个指向它的指针\",{\"1\":{\"145\":1}}],[\"并返回一个右上\",{\"1\":{\"137\":1}}],[\"并返回一个\",{\"1\":{\"61\":1,\"310\":1}}],[\"并非零开销的\",{\"1\":{\"164\":1}}],[\"并鼓励主动去处理这些情形\",{\"1\":{\"163\":1}}],[\"并赋予了针对底层文件的读和\",{\"1\":{\"163\":1}}],[\"并赋予了对所表示的文件的读写能力\",{\"1\":{\"160\":1}}],[\"并被鼓励主动地处理这些情形\",{\"1\":{\"160\":1}}],[\"并被销毁\",{\"1\":{\"138\":1}}],[\"并可用来查看\",{\"1\":{\"152\":1}}],[\"并包装\",{\"1\":{\"151\":1}}],[\"并包装操作返回的\",{\"1\":{\"151\":1}}],[\"并增加计数\",{\"1\":{\"149\":1}}],[\"并开始回退\",{\"1\":{\"148\":1}}],[\"并支持\",{\"1\":{\"118\":1}}],[\"并将其余的值存储在一个数组中\",{\"1\":{\"300\":1}}],[\"并将该借用和\",{\"1\":{\"235\":1}}],[\"并将该文件的内容放到\",{\"1\":{\"128\":1}}],[\"并将它作为字符串\",{\"1\":{\"110\":1}}],[\"并将集成测试放在源码中\",{\"1\":{\"45\":1}}],[\"并创建一个\",{\"1\":{\"310\":1}}],[\"并创建一个名为\",{\"1\":{\"110\":1}}],[\"并创建结构体\",{\"1\":{\"60\":1}}],[\"并使用一个指示符\",{\"1\":{\"110\":1}}],[\"并重新运行\",{\"1\":{\"105\":1}}],[\"并释放它们\",{\"1\":{\"93\":1}}],[\"并立即使之离开作用域\",{\"1\":{\"91\":1}}],[\"并提供一个让人很不爽的错误消息\",{\"1\":{\"70\":1}}],[\"并且拥有相同的散列值\",{\"1\":{\"285\":1}}],[\"并且在\",{\"1\":{\"270\":2}}],[\"并且能够获得容器的第一个或最后一个值\",{\"1\":{\"244\":1,\"246\":1}}],[\"并且能测试私有代码\",{\"1\":{\"173\":1}}],[\"并且仅在需要时使用其他方式\",{\"1\":{\"235\":1}}],[\"并且仅使用\",{\"1\":{\"173\":1}}],[\"并且是不允许的\",{\"1\":{\"233\":1}}],[\"并且标签必须传递给\",{\"1\":{\"226\":1}}],[\"并且不产生\",{\"1\":{\"220\":1}}],[\"并且不用显式地处理失败情况\",{\"1\":{\"81\":1}}],[\"并且每个\",{\"1\":{\"186\":1}}],[\"并且编译器可以保证引用指向已分配的堆\",{\"1\":{\"184\":1}}],[\"并且它提供数种方法\",{\"1\":{\"164\":1}}],[\"并且它们的字段可以正常访问到\",{\"1\":{\"129\":1}}],[\"并且一个结构体中的私有字段不能访问到\",{\"1\":{\"129\":1}}],[\"并且带有隐藏参数\",{\"1\":{\"101\":2}}],[\"并且\",{\"1\":{\"85\":1,\"289\":1}}],[\"并且所有可能的值都必须被覆盖\",{\"1\":{\"79\":1}}],[\"并且所有分支都必须返回相同的类型\",{\"1\":{\"75\":1}}],[\"并且也没为其实现\",{\"1\":{\"76\":1}}],[\"并且允许指明数种失败情形下的选项\",{\"1\":{\"76\":1}}],[\"并且还可以用来打印类型\",{\"1\":{\"50\":1}}],[\"并且显式地使用类型\",{\"1\":{\"11\":1}}],[\"并构建所有内容\",{\"1\":{\"44\":1}}],[\"并管理这些模块之间的可见性\",{\"1\":{\"18\":1}}],[\"并和程序的其余部分一起被编译\",{\"1\":{\"16\":1}}],[\"并令其值为\",{\"1\":{\"11\":1}}],[\"创建指向所需的文件的路径\",{\"1\":{\"289\":1}}],[\"创建空枚举类型来表示单位\",{\"1\":{\"249\":1}}],[\"创建数据类型的一个空实例\",{\"1\":{\"179\":1}}],[\"创建副本\",{\"1\":{\"179\":1}}],[\"创建具有一定初始容量的\",{\"1\":{\"146\":1}}],[\"创建一大堆\",{\"1\":{\"141\":1}}],[\"创建一个向量\",{\"1\":{\"293\":1}}],[\"创建一个名为\",{\"1\":{\"261\":1}}],[\"创建一个空链表\",{\"1\":{\"205\":1}}],[\"创建一个空的\",{\"1\":{\"205\":1}}],[\"创建一个空的且可增长的\",{\"1\":{\"152\":1}}],[\"创建一个空向量\",{\"1\":{\"194\":1}}],[\"创建一个符号链接\",{\"1\":{\"161\":1}}],[\"创建一个目录\",{\"1\":{\"161\":1}}],[\"创建一个装箱的\",{\"1\":{\"138\":1}}],[\"创建一个类型别名\",{\"1\":{\"58\":1}}],[\"创建一个\",{\"1\":{\"11\":1,\"57\":1,\"164\":1,\"261\":1}}],[\"创建单元素元组需要一个额外的逗号\",{\"1\":{\"136\":1}}],[\"创建包含不同数据类型的元组\",{\"1\":{\"101\":1}}],[\"创建变量\",{\"1\":{\"76\":1,\"266\":1}}],[\"创建迭代器的一个最简单的方法是使用区间标记\",{\"1\":{\"72\":1}}],[\"创建文件\",{\"0\":{\"288\":1},\"1\":{\"0\":1}}],[\"^1\",{\"1\":{\"266\":2}}],[\"^^^\",{\"1\":{\"40\":1}}],[\"^\",{\"1\":{\"11\":1,\"30\":1,\"35\":1,\"39\":1,\"55\":1,\"75\":2,\"76\":3,\"79\":4,\"81\":4,\"86\":2,\"89\":1,\"93\":1,\"97\":1,\"107\":2,\"113\":1,\"129\":2,\"133\":4,\"135\":2,\"136\":1,\"138\":1,\"140\":2,\"149\":1,\"154\":2,\"178\":2,\"179\":2,\"183\":1,\"191\":1,\"193\":1,\"194\":1,\"196\":1,\"197\":1,\"198\":1,\"199\":1,\"221\":1,\"222\":1,\"231\":2,\"235\":3,\"240\":1,\"247\":1,\"259\":3,\"260\":1,\"261\":1,\"285\":1,\"296\":1,\"298\":1,\"304\":1}}],[\"取八位的二进制补码\",{\"1\":{\"193\":1}}],[\"取值种类\",{\"1\":{\"205\":1}}],[\"取值中\",{\"1\":{\"147\":1}}],[\"取值\",{\"1\":{\"147\":1}}],[\"取值的种类\",{\"1\":{\"57\":1}}],[\"取得一个对\",{\"1\":{\"138\":1}}],[\"取消上面的注释也不会导致错误\",{\"1\":{\"235\":1}}],[\"取消上面一行的注释将导致编译时错误\",{\"1\":{\"235\":1}}],[\"取消上面两行的注释\",{\"1\":{\"136\":1}}],[\"取消上述语句的注释\",{\"1\":{\"89\":1}}],[\"取消此行的注释\",{\"1\":{\"133\":2}}],[\"取消此行注释\",{\"1\":{\"129\":2,\"133\":1,\"178\":1,\"179\":2}}],[\"取消该行的注释\",{\"1\":{\"133\":1}}],[\"取消最后一行的注释\",{\"1\":{\"99\":1}}],[\"取奇数\",{\"1\":{\"85\":1}}],[\"取小于上限的\",{\"1\":{\"85\":1}}],[\"取上面的定义\",{\"1\":{\"11\":1}}],[\"取别名\",{\"0\":{\"223\":1},\"1\":{\"0\":1,\"207\":1,\"211\":1}}],[\"即用于匹配的模式\",{\"1\":{\"298\":1}}],[\"即一个可变引用\",{\"1\":{\"293\":1}}],[\"即文件描述符\",{\"1\":{\"289\":1}}],[\"即自动创建\",{\"1\":{\"254\":1}}],[\"即第一个参数f\",{\"1\":{\"251\":1}}],[\"即不定长的\",{\"1\":{\"194\":1}}],[\"即父\",{\"1\":{\"189\":1}}],[\"即\",{\"1\":{\"145\":1,\"157\":1,\"249\":1,\"293\":1,\"298\":1}}],[\"即便它是嵌套在公有模块内部的\",{\"1\":{\"133\":1}}],[\"即便常见的情况也可能会用到特别的\",{\"1\":{\"4\":1}}],[\"即封装\",{\"1\":{\"129\":1}}],[\"即为不同种类的数据分别定义新的类型\",{\"1\":{\"99\":1}}],[\"即枚举未注明\",{\"1\":{\"76\":1}}],[\"即表示错误的类型\",{\"1\":{\"70\":1}}],[\"即使一个\",{\"1\":{\"247\":1}}],[\"即使它是私有的\",{\"1\":{\"133\":1}}],[\"即使\",{\"1\":{\"11\":1}}],[\"非泛型\",{\"1\":{\"11\":1,\"242\":1}}],[\"来返回错误\",{\"1\":{\"310\":1}}],[\"来解构\",{\"1\":{\"296\":1}}],[\"来解包并产生\",{\"1\":{\"70\":1}}],[\"来指定\",{\"1\":{\"296\":1}}],[\"来指定的\",{\"1\":{\"11\":1}}],[\"来消除警告\",{\"1\":{\"296\":1}}],[\"来为\",{\"1\":{\"293\":1}}],[\"来改变\",{\"1\":{\"263\":1}}],[\"来借用数据\",{\"1\":{\"261\":1}}],[\"来借用一个变量\",{\"1\":{\"139\":1}}],[\"来做到\",{\"1\":{\"256\":1}}],[\"来控制显示效果\",{\"1\":{\"254\":1}}],[\"来控制文字显示\",{\"1\":{\"107\":1}}],[\"来进行打印\",{\"1\":{\"254\":1}}],[\"来过滤分支\",{\"1\":{\"231\":1}}],[\"来注明\",{\"1\":{\"226\":1}}],[\"来注明类型\",{\"1\":{\"110\":1}}],[\"来试验\",{\"1\":{\"225\":1}}],[\"来达到同样的效果\",{\"1\":{\"220\":1}}],[\"来替代\",{\"1\":{\"217\":1}}],[\"来替换它\",{\"1\":{\"76\":1}}],[\"来表达这个逻辑\",{\"1\":{\"215\":1}}],[\"来表示各个数据\",{\"1\":{\"256\":1}}],[\"来表示该参数可能出现零次或多次\",{\"1\":{\"114\":1}}],[\"来表示一个参数可能出现一次或多次\",{\"1\":{\"114\":1}}],[\"来表示\",{\"1\":{\"11\":1,\"135\":1}}],[\"来说是一个无效类型\",{\"1\":{\"215\":1}}],[\"来代替它\",{\"1\":{\"211\":1}}],[\"来重载\",{\"1\":{\"187\":1}}],[\"来定义数列\",{\"1\":{\"186\":1}}],[\"来释放资源的类型\",{\"1\":{\"183\":1}}],[\"来格式化一个值\",{\"1\":{\"179\":1}}],[\"来销毁原始的\",{\"1\":{\"178\":1}}],[\"来存放所创建的子线程\",{\"1\":{\"167\":1}}],[\"来存储值\",{\"1\":{\"146\":1}}],[\"来记录迭代次数\",{\"1\":{\"154\":1}}],[\"来转义的\",{\"1\":{\"153\":1}}],[\"来获得一个带有默认初始容量的\",{\"1\":{\"146\":1}}],[\"来使它在堆上分配\",{\"1\":{\"145\":1}}],[\"来传递\",{\"1\":{\"138\":2}}],[\"来构造\",{\"1\":{\"136\":1}}],[\"来构建和运行\",{\"1\":{\"44\":1}}],[\"来创建\",{\"1\":{\"134\":1}}],[\"来创建宏\",{\"0\":{\"16\":1},\"1\":{\"0\":1}}],[\"来访问\",{\"1\":{\"131\":1}}],[\"来访问对象中的数据和其他\",{\"1\":{\"86\":1}}],[\"来约束\",{\"1\":{\"89\":1}}],[\"来打印内容\",{\"1\":{\"270\":1}}],[\"来打印\",{\"1\":{\"89\":1,\"254\":1}}],[\"来明确规定类型应实现哪些功能\",{\"1\":{\"89\":1}}],[\"来围住函数体都是可选的\",{\"1\":{\"83\":1}}],[\"来判断是否满足上面提供的条件\",{\"1\":{\"76\":1}}],[\"来写\",{\"1\":{\"72\":1}}],[\"来处理\",{\"1\":{\"68\":1}}],[\"来了解更多有关枚举和类型别名的知识\",{\"1\":{\"58\":1}}],[\"来对\",{\"1\":{\"57\":1}}],[\"来自本地文件系统的路径\",{\"1\":{\"44\":1}}],[\"来自网上的仓库\",{\"1\":{\"44\":1}}],[\"来自\",{\"1\":{\"44\":1,\"121\":1,\"122\":1}}],[\"来覆盖前面的变量\",{\"1\":{\"21\":1}}],[\"来运行测试\",{\"1\":{\"174\":1}}],[\"来运行\",{\"1\":{\"13\":1}}],[\"来测试这段代码\",{\"1\":{\"13\":1}}],[\"就很简单了\",{\"1\":{\"310\":1}}],[\"就相当于做这样的比较\",{\"1\":{\"298\":1}}],[\"就自动地避免了别的线程对它的操作\",{\"1\":{\"293\":1}}],[\"就必须调用\",{\"1\":{\"292\":1}}],[\"就不会开始处理我们刚刚发送的输入\",{\"1\":{\"291\":1}}],[\"就不再需要给\",{\"1\":{\"38\":1}}],[\"就如泛型类型能够被约束一样\",{\"1\":{\"270\":1}}],[\"就如同\",{\"1\":{\"152\":1}}],[\"就需要不同的生命周期了\",{\"1\":{\"268\":1}}],[\"就取\",{\"1\":{\"249\":1}}],[\"就包含了\",{\"1\":{\"244\":1}}],[\"就包含了所要求的生命周期\",{\"1\":{\"55\":1}}],[\"就等于一个会返回\",{\"1\":{\"221\":1}}],[\"就意味着它已经不能被处理了\",{\"1\":{\"221\":1}}],[\"就返回\",{\"1\":{\"217\":2}}],[\"就无法指明是哪个字符串解析失败了\",{\"1\":{\"209\":1}}],[\"就无法直接表达\",{\"1\":{\"103\":1}}],[\"就完成了类型说明\",{\"1\":{\"195\":1}}],[\"就直接把它放进去\",{\"1\":{\"193\":1}}],[\"就调用析构函数\",{\"1\":{\"142\":1}}],[\"就被调用\",{\"1\":{\"141\":1}}],[\"就可以不再使用\",{\"1\":{\"211\":1}}],[\"就可以不写出名称的完整路径了\",{\"1\":{\"203\":1}}],[\"就可以随意增长\",{\"1\":{\"154\":1}}],[\"就可以\",{\"1\":{\"116\":1}}],[\"就可以匹配一个或多个用逗号隔开的表达式\",{\"1\":{\"114\":1}}],[\"就可以发现提供给\",{\"1\":{\"99\":1}}],[\"就可以用\",{\"1\":{\"51\":1}}],[\"就变成了泛型\",{\"1\":{\"91\":1}}],[\"就\",{\"1\":{\"81\":1}}],[\"就执行下面语句块\",{\"1\":{\"81\":1}}],[\"就使用\",{\"1\":{\"76\":1}}],[\"就行\",{\"1\":{\"51\":1}}],[\"就像独立的函数一样\",{\"1\":{\"273\":1}}],[\"就像其他使用该\",{\"1\":{\"173\":1}}],[\"就像上面一样\",{\"1\":{\"107\":1}}],[\"就像处理蛇那样\",{\"1\":{\"68\":1}}],[\"就像\",{\"1\":{\"50\":1,\"225\":1}}],[\"就像函数的形参一样\",{\"1\":{\"11\":1}}],[\"就是\",{\"1\":{\"251\":1}}],[\"就是二进制的最低位\",{\"1\":{\"193\":1}}],[\"就是二进制的最高位\",{\"1\":{\"193\":1}}],[\"就是把\",{\"1\":{\"48\":1}}],[\"就是这样的\",{\"1\":{\"247\":1}}],[\"就是这样\",{\"1\":{\"44\":1}}],[\"就是泛型类型\",{\"1\":{\"11\":1}}],[\"就和其他枚举类型一样\",{\"1\":{\"147\":1}}],[\"就和前面的一样\",{\"1\":{\"128\":1}}],[\"就和上面例子中的\",{\"1\":{\"76\":1}}],[\"就和平常一样\",{\"1\":{\"44\":1}}],[\"就和变量一样\",{\"1\":{\"10\":1}}],[\"<u32>\",{\"1\":{\"293\":1}}],[\"<integer>\",{\"1\":{\"287\":3}}],[\"<i32>`\",{\"1\":{\"185\":1}}],[\"<i32>\",{\"1\":{\"11\":1,\"51\":1,\"63\":1,\"64\":1,\"65\":1,\"66\":2,\"67\":2,\"70\":2,\"147\":1,\"207\":1,\"209\":1,\"210\":2,\"211\":2,\"213\":1,\"220\":2,\"221\":2,\"222\":2,\"223\":2,\"225\":5}}],[\"<string>\",{\"1\":{\"287\":3}}],[\"<vec<\",{\"1\":{\"285\":4}}],[\"<form\",{\"1\":{\"181\":2}}],[\"<cratename>`\",{\"1\":{\"170\":1}}],[\"<char>\",{\"1\":{\"91\":1}}],[\"<main>\",{\"1\":{\"148\":1}}],[\"<<\",{\"1\":{\"135\":2}}],[\"<\",{\"1\":{\"75\":2,\"80\":1,\"85\":1,\"151\":2,\"153\":1,\"159\":1,\"175\":1,\"179\":1,\"184\":1,\"286\":2}}],[\"<>\",{\"1\":{\"51\":1,\"293\":1}}],[\"<pkg>\",{\"1\":{\"42\":1}}],[\"<a\",{\"1\":{\"91\":1,\"103\":2}}],[\"<aaa\",{\"1\":{\"11\":1}}],[\"<a>\",{\"1\":{\"11\":2}}],[\"<t>\",{\"1\":{\"11\":5,\"91\":1,\"95\":2,\"233\":1}}],[\"也实现了\",{\"1\":{\"284\":1}}],[\"也可能有生命周期的标注\",{\"1\":{\"279\":1}}],[\"也可以忽略某些变量\",{\"1\":{\"302\":1}}],[\"也可以通过声明不同的生命周期的形式实现\",{\"1\":{\"272\":1}}],[\"也可以打印\",{\"1\":{\"254\":1}}],[\"也可以介于二者之间\",{\"1\":{\"209\":1}}],[\"也可以在类型中完全采用底层的错误实现\",{\"1\":{\"209\":1}}],[\"也可以在函数内使用\",{\"1\":{\"10\":1}}],[\"也可以像\",{\"1\":{\"201\":1}}],[\"也可以为任何自定义数据类型手动实现\",{\"1\":{\"183\":1}}],[\"也可以为我们自己的类型定义转换机制\",{\"1\":{\"47\":1}}],[\"也可以手动实现\",{\"1\":{\"179\":1}}],[\"也可以使用约束\",{\"1\":{\"270\":1}}],[\"也可以使用\",{\"1\":{\"146\":1,\"153\":1,\"215\":1}}],[\"也可以加上\",{\"1\":{\"129\":1}}],[\"也可以对其进行修改和调整\",{\"1\":{\"125\":1}}],[\"也可以供编译时类型检查使用\",{\"1\":{\"101\":1}}],[\"也可以是泛型的\",{\"1\":{\"93\":1}}],[\"也可以把别扭的\",{\"1\":{\"81\":1}}],[\"也可以用于能够确定\",{\"1\":{\"7\":1}}],[\"也要比函数活得更长\",{\"1\":{\"270\":1}}],[\"也没问题\",{\"1\":{\"268\":1}}],[\"也没有运行时行为\",{\"1\":{\"101\":1}}],[\"也拥有相同的签名\",{\"1\":{\"264\":1}}],[\"也通过\",{\"1\":{\"254\":1}}],[\"也能够打印\",{\"1\":{\"254\":1}}],[\"也应该是可能的\",{\"1\":{\"242\":1}}],[\"也就是如果没有在实现中另行指定\",{\"1\":{\"249\":1}}],[\"也就是\",{\"1\":{\"187\":1,\"285\":1}}],[\"也就是说\",{\"1\":{\"11\":1,\"23\":1,\"48\":1,\"70\":1,\"89\":1,\"138\":1,\"187\":1,\"209\":1,\"211\":1,\"266\":1}}],[\"也有很多\",{\"1\":{\"157\":1}}],[\"也被一起删除\",{\"1\":{\"149\":1}}],[\"也是可增长的\",{\"1\":{\"146\":1}}],[\"也是一个表达式\",{\"1\":{\"79\":1}}],[\"也需要很仔细\",{\"1\":{\"95\":1}}],[\"也叫做\",{\"1\":{\"83\":1}}],[\"也正因如此\",{\"1\":{\"52\":1}}],[\"也许你的\",{\"1\":{\"41\":1}}],[\"也支持在测试中指定额外的依赖\",{\"1\":{\"28\":1}}],[\"g\",{\"1\":{\"296\":2}}],[\"gödel\",{\"1\":{\"261\":1}}],[\"guard\",{\"1\":{\"231\":1}}],[\"guide\",{\"1\":{\"123\":1}}],[\"green\",{\"1\":{\"201\":1,\"235\":1,\"251\":4,\"296\":4}}],[\"greeting\",{\"1\":{\"189\":1,\"240\":2}}],[\"greater\",{\"1\":{\"81\":2}}],[\"gpl\",{\"1\":{\"141\":1,\"148\":1}}],[\"gnu\",{\"1\":{\"141\":1,\"148\":1}}],[\"goodbye\",{\"1\":{\"240\":1}}],[\"got\",{\"1\":{\"156\":2,\"298\":3}}],[\"go\",{\"1\":{\"76\":3}}],[\"gift\",{\"1\":{\"68\":5,\"69\":3}}],[\"given\",{\"1\":{\"287\":6}}],[\"gives\",{\"1\":{\"163\":1}}],[\"give\",{\"1\":{\"68\":7,\"69\":3}}],[\"git\",{\"1\":{\"44\":1,\"189\":3}}],[\"github\",{\"1\":{\"15\":1,\"44\":1}}],[\"get\",{\"1\":{\"146\":3,\"181\":9,\"215\":2,\"284\":2}}],[\"gets\",{\"1\":{\"30\":1}}],[\"genval\",{\"1\":{\"95\":2}}],[\"genval<t>\",{\"1\":{\"95\":2}}],[\"gen\",{\"1\":{\"91\":4,\"95\":3}}],[\"generics\",{\"0\":{\"323\":1}}],[\"genericval<s>\",{\"1\":{\"95\":1}}],[\"genericval<f32>\",{\"1\":{\"95\":1}}],[\"genericval<t>\",{\"1\":{\"95\":2}}],[\"genericval\",{\"1\":{\"95\":1}}],[\"generic<t>\",{\"1\":{\"91\":1}}],[\"generic\",{\"1\":{\"11\":1,\"91\":2,\"256\":1}}],[\"gc\",{\"1\":{\"15\":1}}],[\"garbage\",{\"1\":{\"15\":1}}],[\"glob\",{\"1\":{\"1\":1}}],[\"38397966707106094172783238747669219\",{\"1\":{\"293\":1}}],[\"347778\",{\"1\":{\"251\":1}}],[\"3735928559\",{\"1\":{\"251\":1}}],[\"3<f>\",{\"1\":{\"240\":1}}],[\"3f32\",{\"1\":{\"195\":1}}],[\"3`\",{\"1\":{\"186\":1,\"240\":1}}],[\"32\",{\"1\":{\"135\":2,\"293\":1}}],[\"31\",{\"1\":{\"107\":1,\"170\":1}}],[\"365\",{\"1\":{\"99\":2}}],[\"3i32\",{\"1\":{\"95\":1,\"136\":1,\"141\":1}}],[\"300\",{\"1\":{\"256\":2}}],[\"30\",{\"1\":{\"47\":1}}],[\"35\",{\"1\":{\"45\":1}}],[\"3u32\",{\"1\":{\"35\":1,\"111\":3,\"136\":1,\"263\":1}}],[\"3\",{\"1\":{\"10\":1,\"21\":2,\"24\":1,\"34\":1,\"45\":2,\"60\":2,\"72\":2,\"78\":1,\"79\":1,\"80\":1,\"86\":1,\"89\":2,\"95\":1,\"97\":2,\"103\":1,\"107\":1,\"108\":3,\"111\":2,\"112\":3,\"114\":1,\"116\":5,\"134\":1,\"136\":1,\"139\":1,\"141\":1,\"145\":1,\"148\":2,\"154\":4,\"156\":3,\"158\":1,\"168\":1,\"170\":3,\"173\":2,\"174\":2,\"175\":2,\"185\":3,\"186\":6,\"197\":1,\"205\":1,\"235\":2,\"240\":3,\"244\":1,\"246\":1,\"251\":3,\"252\":1,\"254\":1,\"256\":5,\"257\":4,\"260\":1,\"264\":1,\"268\":1,\"272\":1,\"285\":4,\"287\":1,\"298\":2,\"300\":2,\"302\":1,\"304\":1,\"306\":2,\"308\":2,\"310\":1,\"311\":1}}],[\"n192\",{\"1\":{\"290\":1}}],[\"nisi\",{\"1\":{\"288\":2}}],[\"nine\",{\"1\":{\"266\":2}}],[\"nil`\",{\"1\":{\"205\":1}}],[\"nil\",{\"1\":{\"178\":7,\"205\":6}}],[\"nice\",{\"1\":{\"68\":1}}],[\"nthreads\",{\"1\":{\"158\":4,\"167\":2}}],[\"n|\",{\"1\":{\"85\":2}}],[\"needle\",{\"1\":{\"235\":1}}],[\"next`\",{\"1\":{\"186\":1}}],[\"next\",{\"1\":{\"185\":5,\"186\":14,\"219\":4}}],[\"ne\",{\"1\":{\"174\":1}}],[\"nested`\",{\"1\":{\"128\":1,\"133\":1}}],[\"nested\",{\"1\":{\"128\":7,\"132\":7,\"133\":17}}],[\"never\",{\"1\":{\"84\":4,\"226\":1}}],[\"negativesquareroot\",{\"1\":{\"151\":2,\"286\":3}}],[\"negativelogarithm\",{\"1\":{\"151\":2,\"286\":3}}],[\"negative\",{\"1\":{\"75\":1,\"286\":2}}],[\"new\",{\"0\":{\"99\":1},\"1\":{\"30\":3,\"44\":2,\"86\":5,\"118\":3,\"129\":2,\"138\":1,\"140\":1,\"141\":3,\"144\":1,\"145\":4,\"146\":2,\"148\":1,\"149\":1,\"152\":1,\"161\":6,\"164\":5,\"166\":1,\"178\":2,\"184\":2,\"186\":2,\"194\":1,\"205\":3,\"235\":1,\"259\":4,\"261\":3,\"263\":1,\"281\":1,\"284\":1,\"288\":1,\"289\":2,\"290\":1,\"291\":2,\"292\":1}}],[\"newtype\",{\"1\":{\"0\":1,\"99\":1}}],[\"nulla\",{\"1\":{\"288\":2}}],[\"null\",{\"1\":{\"93\":5,\"152\":1}}],[\"num`\",{\"1\":{\"275\":1}}],[\"num\",{\"1\":{\"47\":2,\"48\":2,\"210\":2,\"213\":1,\"220\":1,\"221\":1,\"222\":1,\"223\":1,\"225\":3,\"275\":6,\"277\":2,\"287\":2}}],[\"number`\",{\"1\":{\"256\":1}}],[\"number|\",{\"1\":{\"223\":2,\"225\":2}}],[\"number=1\",{\"1\":{\"107\":4}}],[\"numbers\",{\"1\":{\"63\":2,\"64\":2,\"65\":2,\"66\":8,\"67\":2,\"84\":3,\"85\":3,\"185\":2,\"207\":2,\"209\":2,\"210\":4,\"211\":2,\"213\":2}}],[\"number\",{\"1\":{\"47\":5,\"48\":5,\"70\":8,\"75\":3,\"76\":4,\"79\":3,\"107\":6,\"146\":10,\"167\":1,\"184\":4,\"201\":3,\"210\":1,\"219\":5,\"220\":12,\"221\":8,\"222\":8,\"223\":6,\"225\":14,\"228\":2,\"244\":14,\"246\":14,\"277\":2,\"286\":2,\"287\":7}}],[\"nursery\",{\"1\":{\"44\":1}}],[\"n>\",{\"1\":{\"38\":1,\"53\":1,\"128\":1,\"131\":1,\"133\":2}}],[\"nostrud\",{\"1\":{\"288\":2}}],[\"now\",{\"1\":{\"240\":1,\"254\":2,\"259\":1,\"281\":1}}],[\"non\",{\"1\":{\"158\":1,\"175\":4,\"191\":1,\"235\":1,\"288\":2}}],[\"none\",{\"1\":{\"64\":1,\"68\":4,\"76\":2,\"81\":2,\"147\":9,\"151\":1,\"164\":1,\"207\":1,\"209\":1,\"210\":2,\"213\":1,\"215\":9,\"217\":7,\"219\":1}}],[\"normal\",{\"1\":{\"153\":1}}],[\"no\",{\"1\":{\"68\":1,\"121\":1,\"141\":1,\"148\":1,\"153\":1,\"200\":1,\"203\":1,\"215\":1,\"217\":1,\"231\":1}}],[\"nobackup\",{\"1\":{\"45\":2}}],[\"note\",{\"1\":{\"174\":1,\"225\":1}}],[\"nothing\",{\"1\":{\"68\":2}}],[\"not\",{\"1\":{\"36\":3,\"135\":1,\"153\":2,\"164\":1,\"228\":1,\"277\":1,\"287\":4,\"298\":1,\"313\":1}}],[\"noisy\",{\"1\":{\"35\":1,\"39\":1}}],[\"noise\",{\"1\":{\"30\":4,\"184\":4}}],[\"nanoseconds\",{\"1\":{\"191\":4}}],[\"nanosecond\",{\"1\":{\"191\":2}}],[\"native\",{\"1\":{\"167\":1}}],[\"namedborrowed\",{\"1\":{\"277\":1}}],[\"namedborrowed<\",{\"1\":{\"277\":1}}],[\"name`\",{\"1\":{\"110\":1}}],[\"nameless\",{\"1\":{\"83\":1}}],[\"names\",{\"1\":{\"73\":8}}],[\"name\",{\"1\":{\"30\":12,\"38\":3,\"44\":3,\"53\":1,\"60\":3,\"73\":9,\"107\":1,\"110\":3,\"118\":8,\"146\":1,\"153\":2,\"159\":1,\"183\":6,\"189\":3,\"251\":5,\"254\":4,\"282\":5,\"284\":4,\"287\":1}}],[\"naked\",{\"1\":{\"30\":8}}],[\"n\",{\"1\":{\"10\":8,\"55\":5,\"72\":10,\"75\":13,\"80\":7,\"85\":13,\"133\":1,\"137\":2,\"153\":1,\"166\":2,\"186\":2,\"207\":2,\"209\":2,\"210\":2,\"211\":2,\"213\":2,\"220\":3,\"221\":3,\"222\":3,\"223\":3,\"225\":6,\"228\":10,\"251\":1,\"287\":2,\"289\":1,\"290\":1,\"291\":2}}],[\"实例\",{\"1\":{\"205\":1,\"261\":1}}],[\"实例方法签名\",{\"1\":{\"184\":1}}],[\"实例方法通过点运算符来调用\",{\"1\":{\"86\":1}}],[\"实例化\",{\"1\":{\"178\":2}}],[\"实例化一个元组结构体\",{\"1\":{\"60\":1}}],[\"实例化一个单元结构体\",{\"1\":{\"60\":1}}],[\"实例化结构体\",{\"1\":{\"60\":1}}],[\"实际上只是对\",{\"1\":{\"285\":1}}],[\"实际上是指\",{\"1\":{\"211\":1}}],[\"实际上这并不是必须的\",{\"1\":{\"105\":1}}],[\"实际上这是它们实现的一部分\",{\"1\":{\"46\":1}}],[\"实际上会返回一个单元类型\",{\"1\":{\"10\":1}}],[\"实现方式看起来像这样\",{\"1\":{\"256\":1}}],[\"实现的\",{\"1\":{\"249\":1,\"251\":1}}],[\"实现的代码块\",{\"1\":{\"86\":1}}],[\"实现从\",{\"1\":{\"213\":1}}],[\"实现迭代器\",{\"1\":{\"186\":1}}],[\"实现添加了打印到控制台的功能\",{\"1\":{\"183\":1}}],[\"实现都有自己的\",{\"1\":{\"181\":1}}],[\"实现可以为内存堆中的值的位置创建一个引用指针\",{\"1\":{\"144\":1}}],[\"实现并测试了关于\",{\"1\":{\"111\":1}}],[\"实现一个\",{\"1\":{\"99\":1}}],[\"实现了hash\",{\"1\":{\"284\":1}}],[\"实现了\",{\"1\":{\"65\":1,\"225\":2,\"270\":1}}],[\"实现者可以使用它的\",{\"1\":{\"30\":1}}],[\"实现\",{\"0\":{\"95\":1},\"1\":{\"0\":1,\"30\":1,\"51\":1,\"93\":1,\"107\":1,\"111\":1,\"184\":2,\"186\":1,\"189\":2,\"209\":1,\"249\":1,\"254\":1,\"256\":2,\"310\":1}}],[\"02补零使位数为\",{\"1\":{\"252\":1}}],[\"06x\",{\"1\":{\"201\":2}}],[\"0i\",{\"1\":{\"159\":1}}],[\"0i32\",{\"1\":{\"148\":1}}],[\"0f32\",{\"1\":{\"147\":1}}],[\"013\",{\"1\":{\"141\":2}}],[\"0101\",{\"1\":{\"135\":3}}],[\"04b\",{\"1\":{\"135\":3}}],[\"0011\",{\"1\":{\"135\":3}}],[\"001\",{\"1\":{\"135\":1}}],[\"000u32\",{\"1\":{\"135\":1}}],[\"000\",{\"1\":{\"135\":3,\"141\":1}}],[\"000001\",{\"1\":{\"107\":1,\"135\":1}}],[\"00001\",{\"1\":{\"107\":1}}],[\"0b0101\",{\"1\":{\"135\":3}}],[\"0b0011u32\",{\"1\":{\"135\":3}}],[\"0b\",{\"1\":{\"135\":1}}],[\"0o33653337357\",{\"1\":{\"251\":1}}],[\"0o\",{\"1\":{\"135\":1,\"251\":1}}],[\"0xdeadbeef\",{\"1\":{\"251\":1}}],[\"0x000000\",{\"1\":{\"252\":1}}],[\"0x0000ff\",{\"1\":{\"201\":1}}],[\"0x0003fe\",{\"1\":{\"252\":1}}],[\"0x00ff00\",{\"1\":{\"201\":1}}],[\"0xff0000\",{\"1\":{\"201\":1}}],[\"0x80ff5a\",{\"1\":{\"252\":1}}],[\"0x80u32\",{\"1\":{\"135\":1}}],[\"0x80\",{\"1\":{\"135\":1}}],[\"0x\",{\"1\":{\"135\":2,\"251\":1}}],[\"0usize\",{\"1\":{\"111\":1}}],[\"0u32\",{\"1\":{\"78\":1,\"141\":1}}],[\"0>width$\",{\"1\":{\"107\":1}}],[\"0>5\",{\"1\":{\"107\":1}}],[\"0<5\",{\"1\":{\"107\":1}}],[\"0\",{\"1\":{\"10\":2,\"21\":2,\"44\":4,\"45\":11,\"52\":1,\"60\":3,\"72\":6,\"75\":2,\"79\":1,\"80\":3,\"81\":2,\"84\":2,\"85\":5,\"86\":14,\"89\":4,\"95\":1,\"99\":3,\"107\":7,\"111\":3,\"112\":1,\"134\":4,\"135\":2,\"136\":3,\"141\":5,\"144\":1,\"145\":10,\"147\":2,\"148\":10,\"149\":1,\"151\":8,\"154\":4,\"156\":1,\"158\":2,\"159\":2,\"167\":1,\"170\":13,\"171\":1,\"173\":16,\"174\":3,\"175\":12,\"176\":18,\"177\":23,\"179\":1,\"184\":2,\"185\":1,\"186\":5,\"195\":1,\"201\":1,\"205\":2,\"227\":1,\"228\":1,\"231\":1,\"235\":1,\"244\":2,\"246\":2,\"249\":6,\"251\":8,\"252\":4,\"254\":1,\"256\":3,\"259\":3,\"263\":2,\"273\":2,\"286\":8,\"290\":6,\"300\":7,\"304\":2,\"310\":2,\"311\":1}}],[\"边界情况\",{\"1\":{\"10\":1}}],[\"btreeset\",{\"1\":{\"285\":1}}],[\"b`\",{\"1\":{\"246\":1,\"266\":2,\"272\":1}}],[\"bcd60824f5fbfe19\",{\"1\":{\"173\":1}}],[\"black\",{\"1\":{\"296\":1}}],[\"blah\",{\"1\":{\"45\":6}}],[\"bleu\",{\"1\":{\"215\":3}}],[\"blue>\",{\"1\":{\"247\":1}}],[\"blue<t\",{\"1\":{\"247\":1}}],[\"bluejay\",{\"1\":{\"247\":3}}],[\"blue\",{\"1\":{\"201\":2,\"247\":8,\"251\":4,\"296\":4}}],[\"blocking\",{\"1\":{\"158\":1}}],[\"blocks\",{\"1\":{\"141\":2,\"148\":2}}],[\"block\",{\"1\":{\"110\":1,\"132\":2,\"183\":4,\"199\":1}}],[\"b>`\",{\"1\":{\"272\":1}}],[\"b>\",{\"1\":{\"101\":2,\"244\":2,\"246\":1,\"266\":2,\"268\":2,\"272\":1}}],[\"br\",{\"1\":{\"153\":2}}],[\"brown\",{\"1\":{\"107\":1,\"152\":1,\"291\":1}}],[\"break\",{\"1\":{\"78\":2,\"81\":1,\"85\":1,\"226\":4,\"227\":2}}],[\"briefly\",{\"1\":{\"30\":1}}],[\"birthday\",{\"1\":{\"219\":1,\"228\":1}}],[\"bird\",{\"1\":{\"68\":2}}],[\"bit\",{\"1\":{\"193\":1}}],[\"bits\",{\"1\":{\"193\":1}}],[\"bigger\",{\"1\":{\"179\":1}}],[\"big\",{\"1\":{\"55\":3,\"75\":3,\"256\":5}}],[\"bin\",{\"1\":{\"43\":6,\"256\":1}}],[\"bindings\",{\"0\":{\"335\":1}}],[\"binding`\",{\"1\":{\"199\":1}}],[\"binding\",{\"1\":{\"196\":10,\"198\":6,\"199\":9}}],[\"bind\",{\"1\":{\"35\":1}}],[\"binary`\",{\"1\":{\"256\":1}}],[\"binary\",{\"1\":{\"5\":1,\"79\":2,\"107\":1,\"256\":3}}],[\"b\",{\"1\":{\"46\":2,\"72\":2,\"76\":4,\"91\":1,\"107\":1,\"136\":2,\"140\":4,\"149\":9,\"153\":4,\"161\":16,\"164\":1,\"168\":2,\"170\":5,\"171\":3,\"173\":2,\"174\":4,\"175\":4,\"177\":2,\"183\":5,\"187\":2,\"244\":5,\"246\":7,\"256\":2,\"266\":2,\"268\":2,\"272\":5,\"279\":3,\"285\":10,\"296\":2,\"302\":3}}],[\"before\",{\"1\":{\"198\":1}}],[\"behavior\",{\"1\":{\"196\":1}}],[\"been\",{\"1\":{\"163\":1}}],[\"being\",{\"1\":{\"142\":1}}],[\"beta\",{\"1\":{\"83\":1}}],[\"bear\",{\"1\":{\"69\":1}}],[\"be\",{\"1\":{\"42\":1,\"116\":1,\"146\":1,\"148\":1,\"153\":1,\"209\":1,\"219\":1,\"226\":1,\"293\":1}}],[\"benchmark\",{\"1\":{\"17\":1}}],[\"bufreader\",{\"1\":{\"290\":1}}],[\"bufreader<file>>>\",{\"1\":{\"290\":1}}],[\"bufread\",{\"1\":{\"290\":1}}],[\"buffer\",{\"1\":{\"251\":1}}],[\"builder\",{\"1\":{\"166\":1}}],[\"build\",{\"1\":{\"41\":4,\"42\":1,\"44\":1}}],[\"buzz\",{\"1\":{\"10\":1,\"72\":2,\"80\":1}}],[\"bach\",{\"1\":{\"261\":1}}],[\"backtrace\",{\"1\":{\"174\":1}}],[\"backtrace=1`\",{\"1\":{\"174\":1}}],[\"badchar\",{\"1\":{\"209\":1}}],[\"bad\",{\"1\":{\"174\":7}}],[\"baz\",{\"1\":{\"45\":1,\"76\":2}}],[\"barfoo`\",{\"1\":{\"187\":1}}],[\"barfoo\",{\"1\":{\"187\":4}}],[\"bar==a`\",{\"1\":{\"76\":1}}],[\"bar==a\",{\"1\":{\"76\":1}}],[\"bar\",{\"1\":{\"44\":2,\"45\":3,\"76\":10,\"110\":2,\"120\":6,\"187\":10}}],[\"base\",{\"1\":{\"32\":1,\"107\":4,\"205\":1}}],[\"baaaaah\",{\"1\":{\"30\":2,\"184\":1}}],[\"boilerplate\",{\"1\":{\"191\":1}}],[\"book\",{\"1\":{\"127\":1,\"261\":17}}],[\"boolean\",{\"1\":{\"35\":3,\"79\":3,\"136\":2}}],[\"bool\",{\"1\":{\"10\":1,\"20\":1,\"21\":1,\"30\":2,\"55\":1,\"85\":1,\"99\":1,\"136\":2,\"244\":2,\"246\":3,\"284\":1,\"306\":2,\"308\":1}}],[\"bond\",{\"1\":{\"107\":1}}],[\"bounds\",{\"0\":{\"345\":1},\"1\":{\"97\":1,\"250\":1}}],[\"bound\",{\"1\":{\"89\":1}}],[\"box3`\",{\"1\":{\"141\":1}}],[\"box3\",{\"1\":{\"141\":1}}],[\"box2`\",{\"1\":{\"141\":1}}],[\"box2\",{\"1\":{\"141\":1}}],[\"box1`\",{\"1\":{\"141\":1}}],[\"box1\",{\"1\":{\"141\":1}}],[\"box<error>\",{\"1\":{\"207\":1}}],[\"box<list>\",{\"1\":{\"205\":1}}],[\"box<dyn\",{\"1\":{\"184\":2,\"207\":1,\"211\":1}}],[\"box<box<point>>\",{\"1\":{\"145\":1}}],[\"box<rectangle>\",{\"1\":{\"145\":1}}],[\"box<point>\",{\"1\":{\"145\":2}}],[\"box<t>\",{\"1\":{\"141\":1,\"145\":2}}],[\"box<i32>\",{\"1\":{\"24\":1,\"86\":2,\"138\":1,\"140\":1,\"178\":2}}],[\"boxed\",{\"1\":{\"138\":8,\"145\":11}}],[\"box\",{\"1\":{\"86\":2,\"129\":7,\"138\":11,\"140\":4,\"141\":6,\"143\":1,\"145\":11,\"148\":1,\"178\":2,\"183\":1,\"184\":4,\"205\":1,\"206\":1,\"207\":2,\"235\":1,\"236\":1,\"263\":1,\"281\":14}}],[\"bob\",{\"1\":{\"73\":3,\"107\":1,\"152\":3}}],[\"bottom\",{\"1\":{\"60\":6}}],[\"borrow`\",{\"1\":{\"266\":1}}],[\"borrow<\",{\"1\":{\"266\":1}}],[\"borrow2\",{\"1\":{\"139\":3}}],[\"borrow1\",{\"1\":{\"139\":3}}],[\"borrowed<\",{\"1\":{\"277\":1,\"279\":2}}],[\"borrowed\",{\"1\":{\"138\":2,\"259\":7,\"260\":1,\"261\":2,\"277\":5,\"279\":1}}],[\"borrow\",{\"0\":{\"348\":1},\"1\":{\"23\":1,\"134\":2,\"138\":4,\"235\":1,\"259\":11,\"261\":3,\"266\":1}}],[\"borrowing\",{\"1\":{\"15\":1,\"138\":1,\"250\":1}}],[\"bbb\",{\"1\":{\"11\":1}}],[\"byte\",{\"1\":{\"153\":4}}],[\"bytestring\",{\"1\":{\"153\":7}}],[\"bytes\",{\"1\":{\"134\":1,\"141\":2,\"145\":6,\"148\":2,\"153\":2,\"161\":1,\"195\":5,\"288\":1,\"291\":1}}],[\"by\",{\"1\":{\"10\":4,\"15\":4,\"41\":1,\"141\":1,\"148\":3,\"170\":2,\"171\":1,\"175\":1,\"195\":2,\"282\":2,\"286\":1,\"287\":3}}],[\"一览表和它们的参数类型\",{\"1\":{\"251\":1}}],[\"一般地\",{\"1\":{\"225\":1}}],[\"一般来说\",{\"1\":{\"209\":1}}],[\"一般而言\",{\"1\":{\"105\":1}}],[\"一些只读引用\",{\"1\":{\"293\":1}}],[\"一些库可以帮你处理模板化代码的问题\",{\"1\":{\"213\":1}}],[\"一些组合算子可以让我们轻松地交换\",{\"1\":{\"210\":1}}],[\"一些函数应当在特定条件下\",{\"1\":{\"175\":1}}],[\"一些函数可以声明为不安全的\",{\"1\":{\"34\":1}}],[\"一些配置代码\",{\"1\":{\"173\":1}}],[\"一章详细地列出了书写字符串字面量和转义字符的方法\",{\"1\":{\"153\":1}}],[\"一种方式是创建具有公用函数的模块\",{\"1\":{\"173\":1}}],[\"一种将类型占位符与\",{\"1\":{\"87\":1}}],[\"一种是声明绑定变量\",{\"1\":{\"8\":1}}],[\"一旦集合被消耗了\",{\"1\":{\"73\":1}}],[\"一旦找到一个\",{\"1\":{\"65\":1}}],[\"一节包含完整的方法列表\",{\"1\":{\"225\":1}}],[\"一节中的例子的代码拆分到多个文件中\",{\"1\":{\"128\":1}}],[\"一节中讨论的那样\",{\"1\":{\"50\":1}}],[\"一节将会谈到\",{\"1\":{\"73\":1}}],[\"一样可以直接打印\",{\"1\":{\"298\":1}}],[\"一样长\",{\"1\":{\"272\":1}}],[\"一样\",{\"1\":{\"60\":1,\"211\":1}}],[\"一定要注意在使用\",{\"1\":{\"38\":1}}],[\"一个传入参数\",{\"1\":{\"287\":1}}],[\"一个枚举类型\",{\"1\":{\"277\":1}}],[\"一个较长的生命周期可以强制转成一个较短的生命周期\",{\"1\":{\"272\":1}}],[\"一个泛型函数\",{\"1\":{\"270\":1}}],[\"一个拥有生命周期\",{\"1\":{\"268\":1}}],[\"一个缓冲区\",{\"1\":{\"251\":1}}],[\"一个方法是把它们装箱\",{\"1\":{\"207\":1}}],[\"一个长度为\",{\"1\":{\"205\":1}}],[\"一个类型可以实现许多不同的\",{\"1\":{\"181\":1}}],[\"一个包含资源的结构体\",{\"1\":{\"178\":1}}],[\"一个程序就手动导入一番\",{\"1\":{\"164\":1}}],[\"一个指向数据的指针\",{\"1\":{\"154\":1}}],[\"一个对只读内存中分配的字符串的引用\",{\"1\":{\"152\":1}}],[\"一个变量的生命周期在它创建的时候开始\",{\"1\":{\"139\":1}}],[\"一个名为\",{\"1\":{\"133\":1}}],[\"一个公有的构造器方法\",{\"1\":{\"129\":1}}],[\"一个公有的结构体\",{\"1\":{\"129\":2}}],[\"一个人必须有名字\",{\"1\":{\"118\":1}}],[\"一个这样的项就叫做一个关联类型\",{\"1\":{\"87\":1}}],[\"一个可以捕获\",{\"1\":{\"83\":1}}],[\"一个实现\",{\"1\":{\"50\":1}}],[\"一个命令行参数的解析器\",{\"1\":{\"44\":1}}],[\"一个例子就是\",{\"1\":{\"34\":1}}],[\"一个具体类型\",{\"1\":{\"11\":1}}],[\"一个\",{\"1\":{\"10\":1,\"57\":1,\"154\":1,\"209\":1,\"277\":1}}],[\"一个返回布尔值的函数\",{\"1\":{\"10\":1}}],[\"让我们试着做一个非常简易的用户登录系统\",{\"1\":{\"284\":1}}],[\"让我们从这个作用域中访问所有名为\",{\"1\":{\"131\":1}}],[\"让我们将\",{\"1\":{\"128\":1}}],[\"让我们用\",{\"1\":{\"80\":1}}],[\"让我们使用关联类型来重写上一小节的例子\",{\"1\":{\"246\":1}}],[\"让我们使用\",{\"1\":{\"72\":1}}],[\"让我们使用函数来重写\",{\"1\":{\"10\":1}}],[\"让我们创建一个库\",{\"1\":{\"53\":1}}],[\"让我们谈谈\",{\"1\":{\"9\":1}}],[\"之类的组合算子\",{\"1\":{\"225\":1}}],[\"之外\",{\"1\":{\"211\":1}}],[\"之前使用\",{\"1\":{\"235\":1}}],[\"之前被解释为要么\",{\"1\":{\"211\":1}}],[\"之前有\",{\"1\":{\"91\":1}}],[\"之前没有写\",{\"1\":{\"11\":1}}],[\"之后我们再把每个线程提供的结果再加起来\",{\"1\":{\"293\":1}}],[\"之后继续使用它\",{\"1\":{\"235\":1}}],[\"之后\",{\"1\":{\"227\":1,\"235\":1}}],[\"之后就无法再使用了\",{\"1\":{\"73\":1}}],[\"之后指定\",{\"1\":{\"10\":1}}],[\"之意\",{\"1\":{\"5\":1}}],[\">`\",{\"1\":{\"161\":5,\"194\":1,\"288\":1}}],[\">>\",{\"1\":{\"135\":2}}],[\">width$\",{\"1\":{\"107\":1}}],[\">5\",{\"1\":{\"107\":1}}],[\">=\",{\"1\":{\"85\":1,\"99\":1,\"251\":2}}],[\">\",{\"1\":{\"10\":3,\"11\":1,\"13\":2,\"30\":7,\"40\":1,\"47\":1,\"48\":1,\"50\":2,\"52\":3,\"54\":1,\"55\":2,\"58\":1,\"63\":1,\"64\":1,\"65\":2,\"66\":6,\"67\":1,\"70\":1,\"75\":3,\"79\":1,\"81\":2,\"83\":2,\"84\":2,\"85\":1,\"86\":4,\"89\":3,\"91\":1,\"95\":2,\"99\":3,\"111\":3,\"118\":1,\"128\":1,\"129\":1,\"133\":2,\"136\":1,\"145\":2,\"146\":1,\"147\":1,\"148\":1,\"151\":4,\"152\":1,\"153\":1,\"154\":1,\"159\":4,\"161\":15,\"168\":1,\"170\":2,\"171\":3,\"173\":1,\"174\":2,\"175\":1,\"177\":1,\"179\":1,\"181\":4,\"183\":1,\"184\":4,\"185\":7,\"186\":10,\"187\":4,\"189\":5,\"193\":3,\"205\":4,\"207\":4,\"209\":4,\"210\":2,\"211\":2,\"213\":5,\"215\":4,\"217\":6,\"219\":2,\"220\":1,\"221\":1,\"222\":1,\"223\":1,\"225\":2,\"228\":2,\"238\":1,\"240\":2,\"242\":3,\"244\":7,\"246\":10,\"247\":2,\"249\":2,\"251\":4,\"256\":3,\"264\":2,\"268\":2,\"272\":2,\"275\":1,\"279\":1,\"285\":1,\"286\":4,\"289\":1,\"290\":2,\"293\":4,\"306\":2,\"308\":2,\"310\":1}}],[\"24\",{\"1\":{\"193\":1}}],[\"254\",{\"1\":{\"251\":1,\"252\":1}}],[\"25\",{\"1\":{\"251\":1}}],[\"259722\",{\"1\":{\"251\":1}}],[\"255\",{\"1\":{\"193\":1,\"251\":1,\"252\":1}}],[\"256\",{\"1\":{\"193\":6}}],[\"232\",{\"1\":{\"193\":5}}],[\"234\",{\"1\":{\"184\":1}}],[\"28\",{\"1\":{\"181\":2}}],[\"2f64\",{\"1\":{\"136\":1}}],[\"2i\",{\"1\":{\"257\":1}}],[\"2i16\",{\"1\":{\"136\":2}}],[\"2i32\",{\"1\":{\"113\":2,\"285\":1}}],[\"2u16\",{\"1\":{\"136\":2}}],[\"2u32\",{\"1\":{\"35\":1,\"111\":3,\"114\":2,\"136\":1,\"195\":1,\"263\":1}}],[\"27\",{\"1\":{\"44\":3,\"60\":1,\"254\":1}}],[\"2000\",{\"1\":{\"294\":1}}],[\"2002\",{\"1\":{\"141\":1,\"148\":1}}],[\"207454\",{\"1\":{\"107\":1}}],[\"20\",{\"1\":{\"57\":1,\"153\":1,\"227\":1,\"282\":1}}],[\"2014\",{\"1\":{\"261\":2}}],[\"2013\",{\"1\":{\"141\":1,\"148\":1}}],[\"2018\",{\"1\":{\"40\":1}}],[\"2015\",{\"1\":{\"40\":1,\"54\":1}}],[\"2022\",{\"1\":{\"15\":1}}],[\"211d\",{\"1\":{\"153\":4}}],[\"21\",{\"1\":{\"21\":1,\"170\":1,\"174\":1}}],[\"26\",{\"1\":{\"15\":1}}],[\"2\",{\"1\":{\"8\":1,\"21\":1,\"24\":1,\"34\":1,\"44\":3,\"45\":3,\"52\":1,\"60\":1,\"67\":2,\"70\":2,\"72\":2,\"75\":1,\"76\":1,\"79\":1,\"84\":1,\"85\":2,\"86\":2,\"97\":2,\"103\":1,\"107\":1,\"110\":1,\"112\":4,\"113\":1,\"114\":1,\"116\":4,\"134\":1,\"135\":7,\"136\":5,\"137\":12,\"141\":2,\"147\":1,\"154\":1,\"156\":2,\"161\":1,\"168\":1,\"170\":2,\"171\":1,\"173\":2,\"174\":3,\"175\":1,\"176\":3,\"177\":4,\"178\":1,\"179\":1,\"185\":4,\"186\":1,\"191\":1,\"196\":1,\"199\":1,\"200\":1,\"205\":1,\"207\":1,\"209\":1,\"210\":3,\"211\":1,\"213\":1,\"220\":2,\"221\":2,\"222\":2,\"223\":2,\"225\":4,\"227\":1,\"231\":3,\"235\":1,\"240\":2,\"244\":7,\"246\":7,\"252\":1,\"256\":2,\"257\":1,\"259\":1,\"272\":1,\"285\":3,\"287\":2,\"300\":4,\"302\":1,\"304\":1,\"306\":10,\"308\":10,\"310\":1,\"311\":2}}],[\"`v`\",{\"1\":{\"310\":1}}],[\"`val`\",{\"1\":{\"298\":2}}],[\"`vec<u8>`\",{\"1\":{\"194\":1}}],[\"`vec<\",{\"1\":{\"194\":1}}],[\"`vec<t>`\",{\"1\":{\"89\":1}}],[\"`vec`\",{\"1\":{\"194\":2,\"235\":1,\"310\":3}}],[\"`vector`\",{\"1\":{\"154\":3}}],[\"`vec\",{\"1\":{\"154\":1,\"185\":1,\"194\":1,\"306\":1}}],[\"`hosts`\",{\"1\":{\"290\":1}}],[\"`hello\",{\"1\":{\"289\":1}}],[\"`haystack`\",{\"1\":{\"235\":2}}],[\"`hashset\",{\"1\":{\"285\":1}}],[\"`hashmap\",{\"1\":{\"146\":2}}],[\"`hasarea`\",{\"1\":{\"89\":3}}],[\"`year`\",{\"1\":{\"261\":1}}],[\"`y`\",{\"1\":{\"8\":1,\"57\":1,\"140\":1,\"185\":1,\"195\":1,\"256\":1,\"263\":1,\"266\":1,\"304\":1}}],[\"`7`\",{\"1\":{\"254\":1}}],[\"`greeting`\",{\"1\":{\"240\":2}}],[\"`get`\",{\"1\":{\"181\":2}}],[\"`genericval`\",{\"1\":{\"95\":1}}],[\"`generic\",{\"1\":{\"91\":2}}],[\"`generic`\",{\"1\":{\"91\":1}}],[\"`gen\",{\"1\":{\"91\":3}}],[\"`运算符的话\",{\"1\":{\"219\":1}}],[\"`+`\",{\"1\":{\"187\":1,\"249\":3}}],[\"`0`\",{\"1\":{\"304\":1}}],[\"`0\",{\"1\":{\"186\":1}}],[\"`3`\",{\"1\":{\"174\":1}}],[\"`join`\",{\"1\":{\"164\":1}}],[\"`lorem\",{\"1\":{\"288\":1}}],[\"`lifetime\",{\"1\":{\"275\":1}}],[\"`list\",{\"1\":{\"205\":1}}],[\"`list`\",{\"1\":{\"205\":2,\"310\":1}}],[\"`last`\",{\"1\":{\"263\":1}}],[\"`large\",{\"1\":{\"260\":1}}],[\"`ls\",{\"1\":{\"161\":2}}],[\"`ln`\",{\"1\":{\"286\":1}}],[\"`ln\",{\"1\":{\"161\":2}}],[\"`length<unit>`\",{\"1\":{\"249\":1}}],[\"`length`\",{\"1\":{\"249\":4}}],[\"`len`\",{\"1\":{\"134\":1,\"154\":1}}],[\"`let`\",{\"1\":{\"60\":1,\"75\":1,\"76\":1,\"81\":1,\"136\":1}}],[\"`1`\",{\"1\":{\"304\":1}}],[\"`1u32`\",{\"1\":{\"135\":1}}],[\"`1i32`\",{\"1\":{\"135\":1}}],[\"`one\",{\"1\":{\"249\":4}}],[\"`output`\",{\"1\":{\"246\":1,\"249\":1}}],[\"`op\",{\"1\":{\"151\":1}}],[\"`option`\",{\"1\":{\"147\":1,\"211\":1,\"225\":1}}],[\"`option<childstdout>`\",{\"1\":{\"291\":1}}],[\"`option<childstdin>`\",{\"1\":{\"291\":1}}],[\"`option<t>`\",{\"1\":{\"186\":1}}],[\"`option<t>\",{\"1\":{\"103\":1}}],[\"`option<i32>`\",{\"1\":{\"76\":2,\"81\":2}}],[\"`optional`\",{\"1\":{\"76\":1,\"81\":4}}],[\"`ok`\",{\"1\":{\"151\":1}}],[\"`other\",{\"1\":{\"132\":1}}],[\"`r`\",{\"1\":{\"298\":1}}],[\"`rhs`\",{\"1\":{\"249\":1}}],[\"`rust\",{\"1\":{\"174\":1}}],[\"`rustdoc`\",{\"1\":{\"118\":1}}],[\"`rmdir\",{\"1\":{\"161\":2}}],[\"`rm\",{\"1\":{\"161\":2}}],[\"`rc\",{\"1\":{\"149\":4}}],[\"`rc`\",{\"1\":{\"149\":1}}],[\"`reference`\",{\"1\":{\"298\":4}}],[\"`ref\",{\"1\":{\"263\":1,\"298\":2}}],[\"`ref`\",{\"1\":{\"263\":3,\"270\":2,\"298\":3}}],[\"`red\",{\"1\":{\"247\":1}}],[\"`result<i32\",{\"1\":{\"223\":1}}],[\"`result`\",{\"1\":{\"211\":1,\"223\":1}}],[\"`recv`\",{\"1\":{\"158\":2}}],[\"`receiver<t>`\",{\"1\":{\"158\":1}}],[\"`rectangle\",{\"1\":{\"86\":2}}],[\"`rectangle`\",{\"1\":{\"86\":2}}],[\"`reg\",{\"1\":{\"91\":1}}],[\"`return`\",{\"1\":{\"10\":1}}],[\"```rust\",{\"1\":{\"125\":2,\"170\":1}}],[\"```\",{\"1\":{\"118\":2,\"125\":2,\"170\":5,\"171\":2}}],[\"`mm`\",{\"1\":{\"249\":1}}],[\"`mem\",{\"1\":{\"235\":1}}],[\"`mut\",{\"1\":{\"298\":2}}],[\"`mutable\",{\"1\":{\"263\":2}}],[\"`mutabook`\",{\"1\":{\"261\":1}}],[\"`mut`\",{\"1\":{\"235\":1,\"263\":1}}],[\"`mul\",{\"1\":{\"111\":2}}],[\"`move`\",{\"1\":{\"235\":1}}],[\"`moved\",{\"1\":{\"178\":3}}],[\"`movable`\",{\"1\":{\"235\":2}}],[\"`mod\",{\"1\":{\"128\":2}}],[\"`mkdir\",{\"1\":{\"161\":4}}],[\"`map\",{\"1\":{\"217\":2,\"225\":1}}],[\"`main`\",{\"1\":{\"148\":1,\"167\":1,\"293\":1}}],[\"`match`\",{\"1\":{\"68\":1,\"76\":1,\"215\":1,\"217\":1,\"219\":1,\"228\":1,\"296\":1}}],[\"`my`\",{\"1\":{\"128\":1,\"131\":3}}],[\"`my\",{\"1\":{\"128\":12,\"131\":3,\"133\":11}}],[\"`minmax`\",{\"1\":{\"256\":1}}],[\"`min\",{\"1\":{\"114\":1}}],[\"`$y`\",{\"1\":{\"114\":1}}],[\"`$y\",{\"1\":{\"114\":1}}],[\"`$x`\",{\"1\":{\"114\":2}}],[\"`$right`\",{\"1\":{\"113\":1}}],[\"`$left`\",{\"1\":{\"113\":1}}],[\"`$func\",{\"1\":{\"110\":1}}],[\"`$`\",{\"1\":{\"107\":1}}],[\"`u32`\",{\"1\":{\"228\":1,\"296\":1}}],[\"`u8`\",{\"1\":{\"219\":1}}],[\"`u64\",{\"1\":{\"191\":1}}],[\"`u64`\",{\"1\":{\"191\":2}}],[\"`use`\",{\"1\":{\"132\":1,\"203\":3,\"256\":1}}],[\"`use\",{\"1\":{\"132\":1}}],[\"`u`\",{\"1\":{\"93\":1}}],[\"`unboxed\",{\"1\":{\"145\":1}}],[\"`unwrap\",{\"1\":{\"70\":1,\"161\":1,\"225\":1,\"291\":1}}],[\"`unwrap`\",{\"1\":{\"68\":2}}],[\"`unit`\",{\"1\":{\"57\":1,\"249\":1}}],[\"`unit\",{\"1\":{\"57\":1}}],[\"`data\",{\"1\":{\"293\":1}}],[\"`divisionbyzero`\",{\"1\":{\"286\":1}}],[\"`div`\",{\"1\":{\"286\":1}}],[\"`display`\",{\"1\":{\"89\":2,\"164\":1,\"256\":4}}],[\"`drop`\",{\"1\":{\"183\":2,\"291\":1}}],[\"`double`\",{\"1\":{\"240\":1}}],[\"`doubleerror`\",{\"1\":{\"209\":1,\"213\":2}}],[\"`doubledrop<t>`\",{\"1\":{\"93\":1}}],[\"`doccomments`\",{\"1\":{\"170\":1}}],[\"`description`\",{\"1\":{\"289\":1}}],[\"`destroy`\",{\"1\":{\"86\":1}}],[\"`deep`\",{\"1\":{\"254\":2}}],[\"`deeply\",{\"1\":{\"132\":3}}],[\"`derive`\",{\"1\":{\"254\":2}}],[\"`debug`\",{\"1\":{\"89\":2,\"179\":1,\"256\":2,\"270\":2,\"285\":2}}],[\"`dead\",{\"1\":{\"39\":1}}],[\"`wait`\",{\"1\":{\"292\":2}}],[\"`wc`\",{\"1\":{\"291\":3}}],[\"`write\",{\"1\":{\"251\":1,\"256\":1,\"310\":1}}],[\"`work\",{\"1\":{\"203\":1}}],[\"`work`\",{\"1\":{\"203\":1}}],[\"`where`\",{\"1\":{\"103\":2}}],[\"`while\",{\"1\":{\"81\":1}}],[\"`webevent`\",{\"1\":{\"57\":1}}],[\"`bar\",{\"1\":{\"187\":1}}],[\"`bar`\",{\"1\":{\"110\":1,\"187\":1}}],[\"`box<error\",{\"1\":{\"207\":1,\"211\":1}}],[\"`boxed\",{\"1\":{\"138\":4,\"145\":1}}],[\"`borrowed`\",{\"1\":{\"277\":2}}],[\"`borrow1\",{\"1\":{\"139\":1}}],[\"`borrow1`\",{\"1\":{\"139\":3}}],[\"`borrow2`\",{\"1\":{\"139\":4}}],[\"`bottom\",{\"1\":{\"60\":1}}],[\"`b`\",{\"1\":{\"101\":4,\"140\":4,\"244\":5,\"246\":2}}],[\"`break`\",{\"1\":{\"81\":1}}],[\"`failed\",{\"1\":{\"266\":1}}],[\"`farewell`\",{\"1\":{\"240\":3}}],[\"`fmt\",{\"1\":{\"254\":4,\"256\":5}}],[\"`fmt`\",{\"1\":{\"213\":1,\"256\":3,\"310\":1}}],[\"`f`\",{\"1\":{\"195\":1,\"233\":2,\"238\":1,\"251\":1,\"256\":1}}],[\"`four`\",{\"1\":{\"266\":1}}],[\"`format\",{\"1\":{\"205\":1,\"251\":1}}],[\"`for`\",{\"1\":{\"186\":2}}],[\"`foo`\",{\"1\":{\"110\":1,\"187\":1,\"266\":2}}],[\"`foo\",{\"1\":{\"76\":1,\"187\":1}}],[\"`fnmut`\",{\"1\":{\"240\":2,\"306\":1,\"308\":1}}],[\"`fnonce`\",{\"1\":{\"240\":2}}],[\"`fn`\",{\"1\":{\"233\":2,\"238\":3,\"240\":2}}],[\"`fn\",{\"1\":{\"170\":1}}],[\"`function`\",{\"1\":{\"131\":1}}],[\"`function\",{\"1\":{\"128\":2,\"131\":2,\"132\":3,\"133\":1}}],[\"`file`\",{\"1\":{\"288\":1,\"289\":1}}],[\"`fibonacci`\",{\"1\":{\"186\":1}}],[\"`find`\",{\"1\":{\"308\":2}}],[\"`find\",{\"1\":{\"114\":1}}],[\"`first`\",{\"1\":{\"86\":1}}],[\"`f32`\",{\"1\":{\"95\":1,\"101\":1}}],[\"`f64`\",{\"1\":{\"21\":1,\"86\":1,\"101\":1,\"249\":3}}],[\"`error`\",{\"1\":{\"209\":1,\"213\":1}}],[\"`err`\",{\"1\":{\"151\":1,\"213\":1}}],[\"`elided\",{\"1\":{\"264\":6}}],[\"`elem`\",{\"1\":{\"194\":2}}],[\"`else`\",{\"1\":{\"81\":1}}],[\"`else\",{\"1\":{\"76\":1,\"81\":1}}],[\"`extern\",{\"1\":{\"170\":1}}],[\"`expr`\",{\"1\":{\"110\":2}}],[\"`echo\",{\"1\":{\"161\":2}}],[\"`eat\",{\"1\":{\"138\":1}}],[\"`eval`\",{\"1\":{\"112\":1,\"116\":2}}],[\"`empty`\",{\"1\":{\"93\":1}}],[\"`enum`\",{\"1\":{\"57\":4,\"201\":1,\"296\":1}}],[\"`nine`\",{\"1\":{\"266\":1}}],[\"`nil`\",{\"1\":{\"178\":3,\"205\":2}}],[\"`nanosecond`\",{\"1\":{\"191\":2}}],[\"`name`\",{\"1\":{\"118\":1,\"282\":1}}],[\"`negativelogarithm`\",{\"1\":{\"286\":1}}],[\"`next\",{\"1\":{\"219\":1}}],[\"`next`\",{\"1\":{\"186\":2}}],[\"`nested\",{\"1\":{\"128\":1}}],[\"`num`\",{\"1\":{\"275\":3}}],[\"`number`\",{\"1\":{\"76\":1,\"79\":1}}],[\"`null`\",{\"1\":{\"93\":1}}],[\"`n`\",{\"1\":{\"72\":2,\"80\":1,\"186\":2,\"228\":2}}],[\"`none`\",{\"1\":{\"68\":1,\"146\":1,\"147\":3,\"186\":3,\"217\":2,\"219\":2,\"228\":1}}],[\"`x`\",{\"1\":{\"57\":1,\"105\":1,\"140\":1,\"195\":1,\"233\":1,\"256\":1,\"263\":2,\"302\":1}}],[\"`keypress\",{\"1\":{\"57\":1}}],[\"`t<u>\",{\"1\":{\"249\":1}}],[\"`t<u>`\",{\"1\":{\"249\":1}}],[\"`type`\",{\"1\":{\"246\":3}}],[\"`triple`\",{\"1\":{\"304\":1}}],[\"`trait`\",{\"1\":{\"187\":1,\"249\":1}}],[\"`try\",{\"1\":{\"171\":2,\"310\":1}}],[\"`try`\",{\"1\":{\"40\":1}}],[\"`take\",{\"1\":{\"186\":1}}],[\"`thread\",{\"1\":{\"158\":1}}],[\"`test\",{\"1\":{\"113\":1}}],[\"`tt`\",{\"1\":{\"111\":1}}],[\"`t\",{\"1\":{\"103\":1}}],[\"`touch\",{\"1\":{\"161\":2}}],[\"`to\",{\"1\":{\"57\":1,\"240\":1}}],[\"`t`\",{\"1\":{\"11\":2,\"89\":4,\"91\":1,\"93\":3,\"95\":2,\"129\":2,\"158\":1,\"205\":1,\"235\":1,\"270\":7}}],[\"`immutabook`\",{\"1\":{\"261\":2}}],[\"`impl\",{\"1\":{\"185\":1}}],[\"`impl`\",{\"1\":{\"95\":3}}],[\"`io\",{\"1\":{\"161\":6,\"288\":2,\"289\":3}}],[\"`iter`\",{\"1\":{\"186\":1}}],[\"`iterator`\",{\"1\":{\"186\":9}}],[\"`iter\",{\"1\":{\"154\":1,\"306\":2,\"308\":2}}],[\"`into\",{\"1\":{\"306\":2,\"308\":2}}],[\"`input`\",{\"1\":{\"246\":1}}],[\"`inc`\",{\"1\":{\"235\":1}}],[\"`inch`\",{\"1\":{\"191\":1,\"249\":1}}],[\"`inches`\",{\"1\":{\"179\":1}}],[\"`inaccessible\",{\"1\":{\"128\":1}}],[\"`indirect\",{\"1\":{\"38\":1,\"53\":1,\"54\":1}}],[\"`ident`\",{\"1\":{\"110\":3}}],[\"`if`\",{\"1\":{\"231\":1}}],[\"`if\",{\"1\":{\"76\":2,\"81\":1}}],[\"`i`\",{\"1\":{\"76\":1,\"81\":2,\"139\":2,\"154\":1,\"186\":1,\"195\":1,\"293\":1}}],[\"`i32`\",{\"1\":{\"11\":1,\"21\":2,\"75\":2,\"83\":1,\"91\":4,\"240\":3,\"246\":2,\"254\":1,\"256\":1,\"266\":1,\"277\":3,\"298\":3,\"306\":3,\"308\":4}}],[\"`person\",{\"1\":{\"282\":1}}],[\"`person`\",{\"1\":{\"118\":1,\"282\":2}}],[\"`process\",{\"1\":{\"217\":1}}],[\"`print`\",{\"1\":{\"233\":2,\"235\":3,\"270\":1,\"273\":1}}],[\"`print\",{\"1\":{\"205\":1,\"266\":3,\"268\":2,\"270\":1}}],[\"`printer`\",{\"1\":{\"89\":1}}],[\"`println\",{\"1\":{\"16\":1,\"235\":2,\"256\":1,\"259\":2,\"298\":2}}],[\"`private\",{\"1\":{\"38\":1,\"53\":1,\"54\":2,\"133\":3}}],[\"`poor`\",{\"1\":{\"203\":1}}],[\"`pop`\",{\"1\":{\"154\":1}}],[\"`point2d`\",{\"1\":{\"256\":1}}],[\"`point\",{\"1\":{\"60\":1}}],[\"`point`\",{\"1\":{\"60\":2,\"86\":1,\"259\":2,\"263\":3}}],[\"`pub\",{\"1\":{\"133\":4}}],[\"`pub`\",{\"1\":{\"133\":1}}],[\"`public\",{\"1\":{\"38\":1,\"53\":1,\"54\":1,\"133\":1}}],[\"`phantomtuple`\",{\"1\":{\"101\":2}}],[\"`parseinterror`\",{\"1\":{\"213\":2,\"223\":1}}],[\"`parse`\",{\"1\":{\"213\":1}}],[\"`partialeq`\",{\"1\":{\"76\":1,\"179\":1}}],[\"`panic\",{\"1\":{\"147\":2}}],[\"`panic`\",{\"1\":{\"68\":2}}],[\"`path`\",{\"1\":{\"133\":1,\"164\":1}}],[\"`pair`\",{\"1\":{\"86\":2,\"178\":3,\"231\":1}}],[\"`paste\",{\"1\":{\"57\":1}}],[\"`pageunload`\",{\"1\":{\"57\":1}}],[\"`pageload`\",{\"1\":{\"57\":1}}],[\"`current\",{\"1\":{\"219\":2}}],[\"`civilian`\",{\"1\":{\"203\":1}}],[\"`centimeters`\",{\"1\":{\"179\":1}}],[\"`cat\",{\"1\":{\"161\":2}}],[\"`calculate\",{\"1\":{\"116\":1}}],[\"`cloned\",{\"1\":{\"178\":1}}],[\"`clone`\",{\"1\":{\"178\":1,\"249\":1}}],[\"`closedbox`\",{\"1\":{\"129\":1}}],[\"`closure\",{\"1\":{\"83\":1}}],[\"`click`\",{\"1\":{\"57\":1}}],[\"`c`\",{\"1\":{\"57\":1,\"140\":1,\"244\":1}}],[\"`coerce\",{\"1\":{\"275\":1}}],[\"`copy`\",{\"1\":{\"249\":2}}],[\"`copied\",{\"1\":{\"35\":1}}],[\"`count`\",{\"1\":{\"235\":5,\"310\":1}}],[\"`color`\",{\"1\":{\"235\":7,\"296\":1}}],[\"`cow`\",{\"1\":{\"184\":1}}],[\"`cool\",{\"1\":{\"131\":2}}],[\"`container\",{\"1\":{\"246\":1}}],[\"`content`\",{\"1\":{\"129\":1}}],[\"`consume`\",{\"1\":{\"235\":1}}],[\"`cons`\",{\"1\":{\"205\":1}}],[\"`const`\",{\"1\":{\"55\":1}}],[\"`char`\",{\"1\":{\"11\":1,\"91\":2}}],[\"`allow`\",{\"1\":{\"296\":1}}],[\"`apply\",{\"1\":{\"240\":1}}],[\"`apply`\",{\"1\":{\"240\":1}}],[\"`age`\",{\"1\":{\"228\":1,\"282\":1}}],[\"`arc`\",{\"1\":{\"144\":1}}],[\"`area`\",{\"1\":{\"89\":1}}],[\"`add`\",{\"1\":{\"249\":2}}],[\"`add<foo>`\",{\"1\":{\"187\":1}}],[\"`add<bar>`\",{\"1\":{\"187\":1}}],[\"`add\",{\"1\":{\"111\":2,\"249\":2}}],[\"`abs`\",{\"1\":{\"86\":1}}],[\"`any`\",{\"1\":{\"306\":2}}],[\"`annotated\",{\"1\":{\"264\":4}}],[\"`and\",{\"1\":{\"215\":1}}],[\"`an\",{\"1\":{\"35\":1}}],[\"`animal`\",{\"1\":{\"30\":1,\"184\":2}}],[\"`a`\",{\"1\":{\"11\":7,\"91\":4,\"101\":3,\"140\":4,\"244\":5,\"246\":2}}],[\"`sleep\",{\"1\":{\"292\":1}}],[\"`short\",{\"1\":{\"199\":1}}],[\"`sheep`\",{\"1\":{\"30\":2,\"184\":1}}],[\"`size\",{\"1\":{\"195\":1}}],[\"`singlegen\",{\"1\":{\"11\":1}}],[\"`singlegen<char>`\",{\"1\":{\"11\":1}}],[\"`singlegen`\",{\"1\":{\"11\":3}}],[\"`single`\",{\"1\":{\"11\":4}}],[\"`static\",{\"1\":{\"275\":1}}],[\"`status\",{\"1\":{\"203\":1}}],[\"`status`\",{\"1\":{\"203\":1}}],[\"`stdout`\",{\"1\":{\"291\":1}}],[\"`stdin`\",{\"1\":{\"291\":3}}],[\"`std\",{\"1\":{\"187\":1,\"225\":1}}],[\"`struct`\",{\"1\":{\"254\":1}}],[\"`structure`\",{\"1\":{\"107\":1,\"254\":4,\"256\":1}}],[\"`stringify\",{\"1\":{\"110\":2}}],[\"`string`\",{\"1\":{\"57\":1,\"152\":1,\"268\":1,\"275\":1}}],[\"`skip\",{\"1\":{\"186\":1}}],[\"`sqrt\",{\"1\":{\"151\":1}}],[\"`super`\",{\"1\":{\"131\":1}}],[\"`sub\",{\"1\":{\"111\":2}}],[\"`sgen<t>`\",{\"1\":{\"91\":2}}],[\"`sgen<i32>`\",{\"1\":{\"91\":1}}],[\"`sgen<>`\",{\"1\":{\"91\":2}}],[\"`sgen<a>`\",{\"1\":{\"91\":1}}],[\"`sgen`\",{\"1\":{\"91\":1}}],[\"`s`\",{\"1\":{\"91\":2,\"95\":2}}],[\"`seconds`不能比较\",{\"1\":{\"179\":1}}],[\"`seconds`\",{\"1\":{\"179\":2}}],[\"`second`\",{\"1\":{\"86\":1}}],[\"`sender<t>`\",{\"1\":{\"158\":1}}],[\"`self\",{\"1\":{\"86\":3,\"131\":1,\"249\":1,\"256\":1,\"306\":2}}],[\"`self`\",{\"1\":{\"30\":2,\"86\":5,\"131\":2,\"205\":4,\"249\":1}}],[\"`some`\",{\"1\":{\"147\":2,\"186\":3,\"219\":1,\"228\":1}}],[\"`some\",{\"1\":{\"76\":1,\"81\":1,\"146\":1}}],[\"`say\",{\"1\":{\"16\":1}}],[\"`<\",{\"1\":{\"272\":1}}],[\"`<rhs\",{\"1\":{\"249\":1}}],[\"`<char\",{\"1\":{\"101\":4}}],[\"`<t>`\",{\"1\":{\"11\":1,\"91\":2,\"95\":1}}],[\"`<a>`\",{\"1\":{\"11\":1}}],[\"`z`\",{\"1\":{\"8\":1,\"195\":1,\"304\":1}}],[\"`\",{\"1\":{\"8\":2,\"10\":4,\"11\":2,\"16\":3,\"38\":3,\"39\":2,\"53\":3,\"54\":3,\"57\":3,\"70\":1,\"76\":7,\"81\":7,\"83\":2,\"86\":5,\"89\":2,\"91\":6,\"97\":8,\"105\":2,\"107\":8,\"110\":2,\"113\":1,\"114\":3,\"116\":1,\"128\":14,\"131\":7,\"132\":4,\"133\":13,\"138\":3,\"141\":3,\"146\":3,\"147\":2,\"148\":1,\"151\":2,\"154\":1,\"161\":5,\"164\":1,\"170\":1,\"171\":2,\"174\":3,\"183\":1,\"186\":4,\"194\":1,\"197\":4,\"205\":5,\"211\":2,\"213\":3,\"215\":1,\"217\":3,\"225\":4,\"235\":8,\"246\":3,\"247\":1,\"249\":2,\"251\":2,\"254\":4,\"256\":6,\"259\":2,\"260\":3,\"261\":2,\"263\":2,\"266\":14,\"268\":6,\"270\":6,\"272\":4,\"275\":2,\"285\":2,\"298\":16,\"300\":2,\"304\":4,\"306\":10,\"308\":12,\"310\":4}}],[\"zzzzz\",{\"1\":{\"240\":1}}],[\"zip\",{\"1\":{\"111\":1}}],[\"zero\",{\"1\":{\"75\":1,\"148\":2,\"170\":2,\"171\":1,\"175\":7,\"201\":3,\"286\":1}}],[\"z\",{\"1\":{\"8\":3,\"111\":2,\"159\":12,\"195\":2,\"259\":9,\"268\":2,\"304\":2}}],[\"将用\",{\"1\":{\"308\":1}}],[\"将第二个和第三个元素绑定到各自的变量\",{\"1\":{\"300\":1}}],[\"将该元组解构成两个变量\",{\"1\":{\"293\":1}}],[\"将该值放在\",{\"1\":{\"227\":1}}],[\"将字符串写入\",{\"1\":{\"291\":1}}],[\"将迭代器返回给文件行的读取器\",{\"1\":{\"290\":1}}],[\"将创建一个新文件\",{\"1\":{\"288\":1}}],[\"将对\",{\"1\":{\"275\":1}}],[\"将闭包存储到\",{\"1\":{\"233\":1}}],[\"将闭包绑定到引用的说法可能不准\",{\"1\":{\"83\":1}}],[\"将赋值给\",{\"1\":{\"219\":1}}],[\"将不可能\",{\"1\":{\"186\":1}}],[\"将不同的值赋给\",{\"1\":{\"79\":1,\"231\":1,\"296\":1,\"304\":1}}],[\"将路径转换成一个字符串切片\",{\"1\":{\"164\":1}}],[\"将阻止当前线程\",{\"1\":{\"158\":1}}],[\"将会创建一个\",{\"1\":{\"268\":1}}],[\"将会得到\",{\"1\":{\"215\":1}}],[\"将会引发程序报告\",{\"1\":{\"148\":1}}],[\"将会引发\",{\"1\":{\"147\":1}}],[\"将会被编译器忽略掉\",{\"1\":{\"13\":1}}],[\"将取出被包装的值\",{\"1\":{\"147\":1}}],[\"将包含在\",{\"1\":{\"145\":1}}],[\"将遮蔽外部的同名函数\",{\"1\":{\"132\":1}}],[\"将找到\",{\"1\":{\"128\":1}}],[\"将你的代码写在这里\",{\"1\":{\"125\":2}}],[\"将求出任意数量的参数的最小值\",{\"1\":{\"114\":1}}],[\"将以不同的方式来比较\",{\"1\":{\"113\":1}}],[\"将格式化文本写到字符串\",{\"1\":{\"107\":1}}],[\"将变量释放\",{\"1\":{\"91\":1}}],[\"将此行注释掉\",{\"1\":{\"154\":1,\"178\":1,\"183\":1,\"198\":1,\"285\":1}}],[\"将此行注释去掉\",{\"1\":{\"86\":1,\"97\":1,\"235\":2}}],[\"将此表达式赋给\",{\"1\":{\"8\":1}}],[\"将输入参数括起来\",{\"1\":{\"83\":1}}],[\"将其中一条分支注释掉\",{\"1\":{\"79\":1}}],[\"将在每次迭代中分别取\",{\"1\":{\"72\":2}}],[\"将在项目目录中优先查找\",{\"1\":{\"41\":1}}],[\"将使用此字段标明的名称\",{\"1\":{\"44\":1}}],[\"将看到类似以下的的内容\",{\"1\":{\"44\":1}}],[\"将看到如下内容\",{\"1\":{\"44\":1}}],[\"将得到如下错误\",{\"1\":{\"40\":1}}],[\"将\",{\"1\":{\"35\":1,\"76\":2,\"79\":1,\"81\":3,\"132\":1,\"140\":1,\"164\":1,\"178\":2,\"240\":1,\"244\":1,\"254\":1,\"284\":1,\"288\":1}}],[\"将文本打印到控制台\",{\"1\":{\"13\":1}}],[\"将从\",{\"1\":{\"5\":1}}],[\"yay\",{\"1\":{\"215\":1}}],[\"ys\",{\"1\":{\"111\":3,\"134\":2}}],[\"yields\",{\"1\":{\"101\":2}}],[\"yellow\",{\"1\":{\"296\":2}}],[\"yet\",{\"1\":{\"228\":1}}],[\"year\",{\"1\":{\"219\":1,\"254\":1,\"261\":5}}],[\"years\",{\"1\":{\"99\":10}}],[\"yes\",{\"1\":{\"36\":2}}],[\"y2\",{\"1\":{\"86\":4}}],[\"y1\",{\"1\":{\"86\":4}}],[\"yuck\",{\"1\":{\"68\":1}}],[\"y`\",{\"1\":{\"60\":2}}],[\"y=\",{\"1\":{\"57\":1}}],[\"yourtype\",{\"1\":{\"103\":2}}],[\"yourself\",{\"1\":{\"16\":1,\"111\":1}}],[\"you\",{\"1\":{\"36\":6,\"84\":2,\"110\":1,\"146\":1,\"153\":2,\"184\":1,\"228\":1}}],[\"y\",{\"1\":{\"8\":3,\"57\":4,\"58\":3,\"60\":6,\"86\":14,\"95\":2,\"111\":5,\"140\":4,\"145\":4,\"151\":7,\"185\":2,\"195\":2,\"231\":4,\"250\":2,\"256\":4,\"259\":9,\"263\":8,\"266\":4,\"268\":6,\"277\":7,\"286\":7,\"296\":4,\"302\":10,\"304\":2}}],[\"而其他部分将保留\",{\"1\":{\"282\":1}}],[\"而言\",{\"1\":{\"249\":1}}],[\"而总是返回\",{\"1\":{\"186\":1}}],[\"而非类型\",{\"1\":{\"296\":1}}],[\"而非传值\",{\"1\":{\"195\":1}}],[\"而非\",{\"1\":{\"179\":1}}],[\"而非数据\",{\"1\":{\"140\":1}}],[\"而process\",{\"1\":{\"166\":1}}],[\"而且对于表示长度的类型\",{\"1\":{\"249\":1}}],[\"而且也不是所有的应用都需要这样做\",{\"1\":{\"213\":1}}],[\"而且当\",{\"1\":{\"149\":1}}],[\"而且确实无法对上面两个\",{\"1\":{\"83\":1}}],[\"而每当克隆得到的\",{\"1\":{\"149\":1}}],[\"而每个元组自身又是一个类型标记为\",{\"1\":{\"136\":1}}],[\"而这个闭包捕获的也是变量的引用\",{\"1\":{\"235\":1}}],[\"而这个函数仅当目标系统\",{\"1\":{\"36\":1}}],[\"而这是编译器禁止的\",{\"1\":{\"140\":1}}],[\"而在\",{\"1\":{\"101\":1}}],[\"而输入变量名必须指明\",{\"1\":{\"83\":1}}],[\"而意外结果是\",{\"1\":{\"70\":1}}],[\"而\",{\"1\":{\"67\":1,\"81\":1,\"91\":1,\"146\":1,\"195\":1,\"256\":1,\"286\":1}}],[\"而是显式地指定\",{\"1\":{\"293\":1}}],[\"而是被强制转换成和输入参数的一样\",{\"1\":{\"275\":1}}],[\"而是复制它们作为\",{\"1\":{\"249\":1}}],[\"而是使用\",{\"1\":{\"211\":1}}],[\"而是存储为若干字节\",{\"1\":{\"164\":1}}],[\"而是程序员的\",{\"1\":{\"34\":1}}],[\"而是展开成源码\",{\"1\":{\"16\":1}}],[\"而不能被消耗\",{\"1\":{\"306\":1,\"308\":1}}],[\"而不能被静态地判别\",{\"1\":{\"207\":1}}],[\"而不同时属于\",{\"1\":{\"285\":1}}],[\"而不移动\",{\"1\":{\"282\":1}}],[\"而不需要指定它们来自\",{\"1\":{\"203\":1}}],[\"而不需写在类型第一次出现之前\",{\"1\":{\"103\":1}}],[\"而不是\",{\"1\":{\"215\":1,\"221\":1}}],[\"而不是打印结果到控制台上\",{\"1\":{\"205\":1}}],[\"而不是调用\",{\"1\":{\"147\":1}}],[\"而不是链接到单独的页面\",{\"1\":{\"120\":1}}],[\"而不是像字符串预处理那样直接替换成代码\",{\"1\":{\"16\":1}}],[\"而不局限于类型参数本身\",{\"1\":{\"103\":1}}],[\"而不一定是代码块中最后一行的语句\",{\"1\":{\"8\":1}}],[\"而常量\",{\"1\":{\"6\":1}}],[\"所有其他情况\",{\"1\":{\"287\":1}}],[\"所有其他类型都必须手动实现\",{\"1\":{\"254\":1}}],[\"所有\",{\"1\":{\"254\":1,\"270\":1}}],[\"所有类型都能派生\",{\"1\":{\"254\":1}}],[\"所有消息都在此处被收集\",{\"1\":{\"158\":1}}],[\"所有值默认都是栈分配的\",{\"1\":{\"145\":1}}],[\"所有元素可以初始化成相同的值\",{\"1\":{\"134\":1}}],[\"所有自然数取平方\",{\"1\":{\"85\":1}}],[\"所有的类型\",{\"1\":{\"254\":1}}],[\"所有的类型标注都不是必需的\",{\"1\":{\"145\":1,\"152\":1}}],[\"所有的\",{\"1\":{\"75\":1}}],[\"所有礼物都显式地使用\",{\"1\":{\"68\":1}}],[\"所有权和移动\",{\"0\":{\"140\":1},\"1\":{\"0\":1}}],[\"所以传给闭包的是\",{\"1\":{\"308\":1}}],[\"所以必需解包\",{\"1\":{\"291\":1}}],[\"所以情况不同\",{\"1\":{\"266\":1}}],[\"所以默认为\",{\"1\":{\"266\":1}}],[\"所以借用检查器将会隐式地添加它们以减少程序输入量和增强可读性\",{\"1\":{\"264\":1}}],[\"所以是\",{\"1\":{\"249\":1}}],[\"所以只有使用impl\",{\"1\":{\"242\":1}}],[\"所以只需很少按键就可注释掉这些\",{\"1\":{\"105\":1}}],[\"所以返回闭包作为输出参数\",{\"1\":{\"242\":1}}],[\"所以该闭包只能调用一次\",{\"1\":{\"235\":1}}],[\"所以闭包将会捕获变量的值\",{\"1\":{\"235\":1}}],[\"所以仍然可变借用\",{\"1\":{\"235\":1}}],[\"所以单个别名就能简便地定义所有相关的\",{\"1\":{\"223\":1}}],[\"所以有必要引入\",{\"1\":{\"215\":1}}],[\"所以实现不了这样的写法\",{\"1\":{\"211\":1}}],[\"所以如果函数返回带闭包的迭代器\",{\"1\":{\"185\":1}}],[\"所以如果公主表示厌恶的话我们要停止\",{\"1\":{\"69\":1}}],[\"所以我们可以不写它\",{\"1\":{\"293\":1}}],[\"所以我们可以从函数中返回\",{\"1\":{\"184\":1}}],[\"所以我们采取这种方式\",{\"1\":{\"235\":1}}],[\"所以我们要想办法来解决这个问题\",{\"1\":{\"68\":1}}],[\"所以完全可以把公共模块写在\",{\"1\":{\"173\":1}}],[\"所以例子要写得完善\",{\"1\":{\"171\":1}}],[\"所以最好选择最方便的写法\",{\"1\":{\"153\":1}}],[\"所以没有执行新的分配操作\",{\"1\":{\"152\":1}}],[\"所以你再也不用手动释放内存或者担心内存泄漏\",{\"1\":{\"141\":1}}],[\"所以任何对象在离开作用域时\",{\"1\":{\"141\":1}}],[\"所以资源只能拥有一个所有者\",{\"1\":{\"140\":1}}],[\"所以函数不是泛型的\",{\"1\":{\"91\":1}}],[\"所以这些值不能够比较\",{\"1\":{\"101\":2}}],[\"所以这个函数是关于\",{\"1\":{\"91\":1}}],[\"所以这个函数也不是泛型的\",{\"1\":{\"91\":1}}],[\"所以这不是泛型函数\",{\"1\":{\"91\":1}}],[\"所以这里的\",{\"1\":{\"11\":1}}],[\"所以不能在变量名\",{\"1\":{\"40\":1}}],[\"所以它被\",{\"1\":{\"291\":1}}],[\"所以它们的打印功能有些受限\",{\"1\":{\"153\":1}}],[\"所以它们可以用作赋值中的值\",{\"1\":{\"8\":1}}],[\"所以它用display\",{\"1\":{\"89\":1}}],[\"所以它可以是任何类型\",{\"1\":{\"11\":1}}],[\"所以\",{\"1\":{\"11\":1,\"70\":1,\"138\":1,\"254\":1}}],[\"17\",{\"1\":{\"296\":1}}],[\"1745\",{\"1\":{\"146\":1}}],[\"192\",{\"1\":{\"290\":1}}],[\"1979\",{\"1\":{\"261\":1}}],[\"19\",{\"1\":{\"228\":1}}],[\"1`\",{\"1\":{\"174\":1}}],[\"1f32\",{\"1\":{\"136\":1}}],[\"1i8\",{\"1\":{\"136\":2,\"193\":1}}],[\"1i32\",{\"1\":{\"113\":1,\"135\":1,\"154\":1,\"285\":1}}],[\"1u8\",{\"1\":{\"136\":2,\"195\":1}}],[\"1u32\",{\"1\":{\"35\":1,\"110\":2,\"111\":2,\"114\":2,\"135\":2,\"186\":1}}],[\"14\",{\"1\":{\"256\":1}}],[\"141592\",{\"1\":{\"108\":1}}],[\"142\",{\"1\":{\"108\":2}}],[\"11861322575564723963297542624962850\",{\"1\":{\"293\":1}}],[\"11\",{\"1\":{\"79\":1,\"136\":1}}],[\"1364\",{\"1\":{\"146\":2}}],[\"13\",{\"1\":{\"79\":3,\"136\":1,\"228\":1}}],[\"18\",{\"1\":{\"63\":1,\"64\":1,\"65\":1,\"66\":2,\"67\":2,\"99\":1,\"148\":2,\"207\":2,\"209\":2,\"210\":4,\"211\":2,\"213\":2,\"273\":1,\"275\":1,\"277\":1}}],[\"16278424637452589860345374828574668\",{\"1\":{\"293\":1}}],[\"168\",{\"1\":{\"290\":2}}],[\"164\",{\"1\":{\"146\":1}}],[\"16\",{\"1\":{\"55\":1,\"107\":1}}],[\"102\",{\"1\":{\"177\":2}}],[\"10f2c\",{\"1\":{\"107\":1}}],[\"101\",{\"1\":{\"72\":1,\"80\":2}}],[\"10\",{\"1\":{\"33\":2,\"51\":1,\"55\":1,\"60\":1,\"70\":1,\"75\":3,\"105\":1,\"107\":1,\"111\":1,\"136\":1,\"144\":1,\"148\":1,\"151\":1,\"154\":2,\"167\":1,\"170\":2,\"171\":1,\"175\":2,\"220\":1,\"221\":1,\"222\":1,\"223\":1,\"225\":2,\"227\":1,\"244\":1,\"246\":1,\"251\":1,\"279\":1,\"286\":1,\"293\":1,\"298\":2}}],[\"10000\",{\"1\":{\"107\":1}}],[\"10000111100101100\",{\"1\":{\"107\":1}}],[\"1000\",{\"1\":{\"85\":2,\"135\":1,\"193\":11,\"249\":1}}],[\"100\",{\"1\":{\"10\":1,\"72\":2,\"76\":1,\"105\":1,\"177\":2,\"179\":1}}],[\"122\",{\"1\":{\"296\":1}}],[\"127\",{\"1\":{\"290\":2}}],[\"123\",{\"1\":{\"251\":1}}],[\"128\",{\"1\":{\"193\":7,\"251\":1,\"252\":1}}],[\"12\",{\"1\":{\"21\":2,\"136\":1,\"179\":1,\"228\":3,\"249\":1,\"254\":1,\"266\":1}}],[\"15\",{\"1\":{\"8\":1,\"10\":1,\"72\":2,\"80\":1,\"228\":1,\"277\":1}}],[\"1\",{\"1\":{\"8\":1,\"10\":1,\"15\":1,\"21\":3,\"24\":1,\"34\":1,\"44\":5,\"45\":2,\"60\":3,\"67\":1,\"72\":5,\"78\":1,\"79\":2,\"80\":3,\"81\":2,\"83\":5,\"84\":1,\"85\":2,\"86\":6,\"89\":1,\"97\":2,\"103\":1,\"107\":10,\"110\":2,\"112\":4,\"113\":1,\"116\":4,\"134\":3,\"135\":7,\"136\":8,\"137\":12,\"141\":3,\"147\":1,\"148\":1,\"149\":2,\"151\":1,\"154\":1,\"156\":4,\"159\":2,\"161\":1,\"168\":1,\"173\":2,\"174\":4,\"175\":2,\"176\":3,\"177\":4,\"178\":1,\"179\":1,\"185\":3,\"186\":3,\"193\":4,\"195\":2,\"196\":1,\"198\":4,\"199\":1,\"205\":2,\"210\":1,\"227\":1,\"228\":3,\"231\":1,\"235\":3,\"244\":8,\"246\":8,\"251\":1,\"254\":1,\"256\":2,\"259\":1,\"263\":1,\"268\":1,\"273\":1,\"285\":3,\"286\":1,\"287\":5,\"290\":4,\"300\":10,\"302\":1,\"304\":1,\"306\":2,\"308\":2,\"310\":1,\"311\":2}}],[\"+=\",{\"1\":{\"78\":1,\"80\":1,\"84\":1,\"85\":1,\"86\":4,\"111\":2,\"198\":2,\"227\":1,\"235\":1,\"268\":1,\"273\":1,\"298\":1}}],[\"+\",{\"1\":{\"8\":3,\"13\":1,\"45\":2,\"51\":1,\"58\":1,\"81\":2,\"83\":4,\"85\":1,\"86\":1,\"97\":2,\"103\":4,\"105\":2,\"110\":2,\"111\":1,\"112\":4,\"113\":1,\"114\":5,\"116\":8,\"135\":2,\"159\":2,\"168\":1,\"170\":1,\"173\":1,\"174\":1,\"177\":1,\"185\":2,\"186\":1,\"187\":9,\"189\":1,\"191\":2,\"193\":2,\"205\":1,\"209\":2,\"213\":1,\"231\":1,\"249\":8,\"257\":1,\"270\":3,\"287\":1,\"288\":1}}],[\"52380795257888236525459303330302837\",{\"1\":{\"293\":1}}],[\"5`\",{\"1\":{\"292\":1}}],[\"59\",{\"1\":{\"251\":1}}],[\"53\",{\"1\":{\"251\":1}}],[\"50\",{\"1\":{\"197\":1,\"260\":1}}],[\"500\",{\"1\":{\"134\":2}}],[\"5u8\",{\"1\":{\"194\":1}}],[\"5u32\",{\"1\":{\"8\":1,\"114\":1,\"136\":2,\"140\":1,\"263\":1,\"281\":1}}],[\"54\",{\"1\":{\"179\":1}}],[\"58495327135744041048897885734297812\",{\"1\":{\"293\":1}}],[\"58\",{\"1\":{\"107\":1}}],[\"5i32\",{\"1\":{\"21\":1,\"52\":1,\"140\":1,\"141\":1}}],[\"5\",{\"1\":{\"8\":1,\"10\":1,\"48\":1,\"51\":1,\"52\":1,\"55\":1,\"60\":1,\"72\":2,\"75\":1,\"78\":1,\"79\":1,\"80\":1,\"99\":1,\"105\":2,\"107\":1,\"134\":3,\"135\":2,\"136\":2,\"138\":1,\"148\":1,\"168\":1,\"170\":2,\"173\":2,\"175\":1,\"184\":1,\"185\":2,\"191\":1,\"199\":1,\"259\":1,\"285\":3,\"292\":2,\"298\":1,\"306\":2,\"308\":2}}],[\"x|\",{\"1\":{\"306\":3,\"308\":4}}],[\"x<\",{\"1\":{\"268\":1}}],[\"xb1\",{\"1\":{\"153\":1}}],[\"xa8\",{\"1\":{\"153\":1}}],[\"xe6\",{\"1\":{\"153\":1}}],[\"x82\",{\"1\":{\"153\":4}}],[\"x86\",{\"1\":{\"134\":1}}],[\"x3f\",{\"1\":{\"153\":3}}],[\"x74\",{\"1\":{\"153\":2}}],[\"x73\",{\"1\":{\"153\":2}}],[\"x75\",{\"1\":{\"153\":2}}],[\"x52\",{\"1\":{\"153\":2}}],[\"x`\",{\"1\":{\"148\":1,\"263\":1,\"266\":2,\"306\":1}}],[\"xor\",{\"1\":{\"135\":1,\"293\":2}}],[\"xs\",{\"1\":{\"111\":3,\"134\":7,\"154\":13}}],[\"x2\",{\"1\":{\"86\":4}}],[\"x1\",{\"1\":{\"86\":4}}],[\"xxx`\",{\"1\":{\"83\":1}}],[\"x=\",{\"1\":{\"57\":1}}],[\"x\",{\"1\":{\"8\":16,\"57\":5,\"58\":4,\"60\":7,\"83\":2,\"84\":1,\"86\":14,\"95\":2,\"105\":3,\"107\":1,\"110\":4,\"111\":8,\"135\":1,\"140\":6,\"142\":1,\"145\":4,\"148\":1,\"151\":12,\"154\":6,\"185\":3,\"195\":2,\"196\":3,\"219\":2,\"231\":6,\"233\":2,\"240\":1,\"250\":2,\"251\":2,\"256\":4,\"259\":7,\"263\":9,\"264\":13,\"266\":5,\"268\":15,\"270\":5,\"277\":9,\"279\":2,\"286\":12,\"302\":4,\"306\":4,\"308\":4}}],[\"另一个线程\",{\"1\":{\"167\":1}}],[\"另一个好处是\",{\"1\":{\"76\":1}}],[\"另一种处理错误的方式是使用match\",{\"1\":{\"220\":1}}],[\"另一种定义\",{\"1\":{\"161\":1}}],[\"另一种是表达式带上英文分号\",{\"1\":{\"8\":1}}],[\"另一方面\",{\"1\":{\"84\":1}}],[\"另外要注意\",{\"1\":{\"268\":1}}],[\"另外这个生命周期的语法也表明了\",{\"1\":{\"266\":1}}],[\"另外也允许变量遮蔽\",{\"1\":{\"199\":1}}],[\"另外注意到\",{\"1\":{\"114\":1}}],[\"另外一个静态方法\",{\"1\":{\"86\":1}}],[\"另外\",{\"1\":{\"42\":1,\"70\":1,\"103\":1,\"135\":1,\"157\":1,\"270\":2,\"293\":1,\"310\":1}}],[\"另外为了满足您的好奇心\",{\"1\":{\"15\":1}}],[\"另外在\",{\"1\":{\"7\":1}}],[\"最后求值的表达式就是代码块的值\",{\"1\":{\"293\":1}}],[\"最后加起来\",{\"1\":{\"85\":1}}],[\"最常见的格式化\",{\"1\":{\"251\":1}}],[\"最常见的情况就是在\",{\"1\":{\"58\":1}}],[\"最左边一位和最右边一位\",{\"1\":{\"193\":1}}],[\"最新发布的版本为\",{\"1\":{\"44\":1}}],[\"最普遍的语句类型有两种\",{\"1\":{\"8\":1}}],[\"最一般的转换会用到\",{\"1\":{\"4\":1}}],[\"程序员可以看到所有的失败路径\",{\"1\":{\"160\":1,\"163\":1}}],[\"程序开始学习\",{\"1\":{\"15\":1}}],[\"程序设计语言\",{\"1\":{\"15\":1,\"45\":1,\"182\":1,\"190\":1}}],[\"程序的源码\",{\"1\":{\"13\":1}}],[\"程序吧\",{\"1\":{\"10\":1}}],[\"程序\",{\"1\":{\"8\":1,\"72\":1,\"80\":1}}],[\"程序参数\",{\"0\":{\"155\":1},\"1\":{\"0\":1}}],[\"有了\",{\"1\":{\"310\":1}}],[\"有些生命周期的模式太常用了\",{\"1\":{\"264\":1}}],[\"有些主题和写程序并没有直接的关联\",{\"1\":{\"17\":1}}],[\"有可能被重用\",{\"1\":{\"223\":1}}],[\"有可选的\",{\"1\":{\"81\":1}}],[\"有其他的原材料\",{\"1\":{\"215\":1}}],[\"有部分条件如\",{\"1\":{\"200\":1}}],[\"有一个内置方法\",{\"1\":{\"217\":1}}],[\"有一个简单的解决方法\",{\"1\":{\"184\":1}}],[\"有一些这方面的辅助宏\",{\"1\":{\"174\":1}}],[\"有两种方式使变量拥有\",{\"1\":{\"275\":1}}],[\"有两种常量\",{\"1\":{\"55\":1}}],[\"有两个变量\",{\"1\":{\"147\":1}}],[\"有个用途是尝试一个操作直到成功为止\",{\"1\":{\"227\":1}}],[\"有个好消息\",{\"1\":{\"181\":1}}],[\"有个额外优点是格式化的正确性会在编译时检查\",{\"1\":{\"107\":1}}],[\"有个特例就是\",{\"1\":{\"55\":1}}],[\"有能力捕获外部环境的变量\",{\"1\":{\"83\":1}}],[\"有很多这样的\",{\"1\":{\"256\":1}}],[\"有很多相同的组合算子\",{\"1\":{\"70\":1}}],[\"有很多类似\",{\"1\":{\"70\":1}}],[\"有\",{\"1\":{\"60\":1}}],[\"有关\",{\"1\":{\"44\":1}}],[\"有关进一步的说明和示例\",{\"1\":{\"42\":1}}],[\"有关错误处理的更多内容\",{\"1\":{\"7\":1}}],[\"有时会导致返回的引用指向无效数据\",{\"1\":{\"268\":1}}],[\"有时会有太多需要转义的字符\",{\"1\":{\"153\":1}}],[\"有时我们只是想\",{\"1\":{\"221\":1}}],[\"有时候我们不想再处理错误\",{\"1\":{\"210\":1}}],[\"有时候把所有不同的错误都视为一种错误类型会简化代码\",{\"1\":{\"209\":1}}],[\"有时候想要捕捉到程序某部分的失败信息\",{\"1\":{\"147\":1}}],[\"有时仅在测试中才需要一些依赖\",{\"1\":{\"168\":1}}],[\"有时也称作\",{\"1\":{\"146\":1}}],[\"有时\",{\"1\":{\"67\":1}}],[\"有时使用\",{\"1\":{\"41\":1}}],[\"有时你需要能够接受不定数目参数的接口\",{\"1\":{\"16\":1}}],[\"有类似的功能\",{\"1\":{\"33\":1}}],[\"有符号整数\",{\"1\":{\"20\":1}}],[\"有多种语句\",{\"1\":{\"8\":1}}],[\"有不同的语法形式\",{\"1\":{\"1\":1}}],[\"但在老一些的\",{\"1\":{\"310\":1}}],[\"但在编写函数时\",{\"1\":{\"240\":1}}],[\"但读者可以把\",{\"1\":{\"298\":1}}],[\"但下面这个不是引用\",{\"1\":{\"298\":1}}],[\"但必须返回正确的生命周期\",{\"1\":{\"268\":1}}],[\"但对一些更复杂的情形\",{\"1\":{\"268\":1}}],[\"但对于\",{\"1\":{\"256\":1}}],[\"但实际上\",{\"1\":{\"244\":1}}],[\"但实际上这非常有用且方便\",{\"1\":{\"84\":1}}],[\"但编译器最终是根据所捕获变量在闭包里的使用情况决定捕获方式\",{\"1\":{\"240\":1}}],[\"但那样的话孩子会是几岁\",{\"1\":{\"228\":1}}],[\"但显式地处理所有错误确实显得过于繁琐\",{\"1\":{\"220\":1}}],[\"但你会发现大量使用它会很繁琐\",{\"1\":{\"217\":1}}],[\"但如果option\",{\"1\":{\"210\":1}}],[\"但返回的是一个堆分配的字符串\",{\"1\":{\"205\":1}}],[\"但加上\",{\"1\":{\"198\":1}}],[\"但转到\",{\"1\":{\"193\":1}}],[\"但其返回类型使用\",{\"1\":{\"185\":1}}],[\"但其大小在编译时是不确定的\",{\"1\":{\"134\":1}}],[\"但使用\",{\"1\":{\"171\":1,\"219\":1}}],[\"但保证了它一定是一个有效的\",{\"1\":{\"152\":1}}],[\"但愿\",{\"1\":{\"151\":1}}],[\"但没有取得所有权\",{\"1\":{\"138\":1}}],[\"但很长的元组无法打印\",{\"1\":{\"136\":1}}],[\"但将文本输出到标准错误\",{\"1\":{\"107\":1}}],[\"但将文本输出到控制台\",{\"1\":{\"107\":1}}],[\"但输出结果追加一个换行符\",{\"1\":{\"107\":2}}],[\"但\",{\"1\":{\"101\":1,\"146\":1,\"235\":1,\"256\":1,\"266\":1,\"282\":2,\"293\":1}}],[\"但不会被消耗\",{\"1\":{\"306\":1,\"308\":1}}],[\"但不能使用\",{\"1\":{\"153\":1}}],[\"但不对它做任何事\",{\"1\":{\"93\":1}}],[\"但不使用垃圾回收机制\",{\"1\":{\"15\":1}}],[\"但这没有关系\",{\"1\":{\"247\":1}}],[\"但这样的话它们就无法转换成\",{\"1\":{\"153\":1}}],[\"但这方法需要一个可变对象\",{\"1\":{\"86\":1}}],[\"但这个默认名称可以使用\",{\"1\":{\"53\":1}}],[\"但此函数会照常返回\",{\"1\":{\"84\":1}}],[\"但并不是\",{\"1\":{\"76\":1}}],[\"但相比显式处理\",{\"1\":{\"68\":1}}],[\"但既然我们在用\",{\"1\":{\"68\":1}}],[\"但所有的概念都是相同的\",{\"1\":{\"44\":1}}],[\"但可以使用\",{\"1\":{\"193\":1}}],[\"但可以通过将文件放在\",{\"1\":{\"43\":1}}],[\"但可以用遮蔽\",{\"1\":{\"21\":1}}],[\"但引用总是安全的\",{\"1\":{\"33\":1}}],[\"但它会将格式化后的字符串写入\",{\"1\":{\"251\":1}}],[\"但它们仍然会被编译\",{\"1\":{\"171\":1}}],[\"但它们可以随时扩大或缩小\",{\"1\":{\"154\":1}}],[\"但它们并不相同\",{\"1\":{\"139\":1}}],[\"但它们为你提供了工具和基础设施支持\",{\"1\":{\"17\":1}}],[\"但它仍然没有问题\",{\"1\":{\"84\":1}}],[\"但它自身的语法很要求细心\",{\"1\":{\"11\":1}}],[\"但是仍然可以使用只引用\",{\"1\":{\"282\":1}}],[\"但是牺牲了一些美感\",{\"1\":{\"254\":1}}],[\"但是在不可变借用的同时\",{\"1\":{\"259\":1}}],[\"但是在老代码中仍然会看到\",{\"1\":{\"222\":1}}],[\"但是在编译时我们不知道哪个结构体\",{\"1\":{\"184\":1}}],[\"但是这次没有把所有的\",{\"1\":{\"211\":1}}],[\"但是这种做法很少用\",{\"1\":{\"196\":1}}],[\"但是自定义条件必须使用\",{\"1\":{\"200\":1}}],[\"但是您可以将一个\",{\"1\":{\"189\":1}}],[\"但是有了\",{\"1\":{\"185\":1}}],[\"但是有时要强调为什么一个操作会失败\",{\"1\":{\"151\":1}}],[\"但是现在你可以像下面这样静态地完成所有操作\",{\"1\":{\"185\":1}}],[\"但是现在是\",{\"1\":{\"140\":1}}],[\"但是我们有时候也需要把资源复制一份\",{\"1\":{\"178\":1}}],[\"但是已经有很多利用宏开发的复杂接口了\",{\"1\":{\"112\":1}}],[\"但是\",{\"1\":{\"8\":1,\"68\":1,\"76\":1,\"184\":1,\"254\":1}}],[\"但是除了在测试或者原型开发中\",{\"1\":{\"7\":1}}],[\"但仍可能出现某些兼容性问题\",{\"1\":{\"3\":1}}],[\"然后这两个引用都被强制转成这个生命周期\",{\"1\":{\"272\":1}}],[\"然后对它取引用\",{\"1\":{\"268\":1}}],[\"然后使\",{\"1\":{\"254\":1}}],[\"然后我们为container\",{\"1\":{\"244\":1}}],[\"然后剩余位置\",{\"1\":{\"193\":1}}],[\"然后绑定给一个变量\",{\"1\":{\"186\":1}}],[\"然后断言\",{\"1\":{\"174\":1}}],[\"然后在示例程序中\",{\"1\":{\"257\":1}}],[\"然后在测试中导入并使用它\",{\"1\":{\"173\":1}}],[\"然后在隐藏的\",{\"1\":{\"171\":1}}],[\"然后它占有的资源就被释放\",{\"1\":{\"141\":1}}],[\"然后告诉\",{\"1\":{\"118\":1}}],[\"然后将所有的物件导入到与库名相同的模块下\",{\"1\":{\"54\":1}}],[\"然后看看如何把它链接到另一个\",{\"1\":{\"53\":1}}],[\"然后针对\",{\"1\":{\"30\":1}}],[\"然后增加一行代码\",{\"1\":{\"14\":1}}],[\"然后\",{\"1\":{\"7\":1}}],[\"然而返回闭包类型会有问题\",{\"1\":{\"242\":1}}],[\"然而我们只是想把里面的变量拿出来\",{\"1\":{\"221\":1}}],[\"然而不要直接这么做\",{\"1\":{\"50\":1}}],[\"然而\",{\"1\":{\"7\":1,\"139\":1,\"215\":1,\"233\":1}}],[\"以色彩模型命名\",{\"1\":{\"296\":1}}],[\"以只读方式打开路径\",{\"1\":{\"289\":1}}],[\"以只写模式打开文件\",{\"1\":{\"288\":1}}],[\"以获取值\",{\"1\":{\"284\":1}}],[\"以便与\",{\"1\":{\"256\":1}}],[\"以下是个简单的元组结构体\",{\"1\":{\"256\":1}}],[\"以闭包作为参数\",{\"1\":{\"240\":1}}],[\"以至于标准库也提供了一个别名\",{\"1\":{\"223\":1}}],[\"以使代码更具可读性\",{\"1\":{\"219\":1}}],[\"以使类型\",{\"1\":{\"95\":1}}],[\"以简化代码\",{\"1\":{\"217\":1}}],[\"以处理各种情况\",{\"1\":{\"217\":1}}],[\"以模块化的风格来管理控制流\",{\"1\":{\"217\":1}}],[\"以链式调用的方式来简化\",{\"1\":{\"215\":1}}],[\"以指定\",{\"1\":{\"175\":1}}],[\"以更优雅和友好的风格来格式化文本\",{\"1\":{\"107\":1}}],[\"以这个\",{\"1\":{\"76\":1}}],[\"以\",{\"1\":{\"42\":1,\"60\":1,\"137\":1}}],[\"以扩大其适用范围的话题\",{\"1\":{\"11\":1}}],[\"以免万一还是出现\",{\"1\":{\"7\":1}}],[\"以及很多其他组合算子也为\",{\"1\":{\"225\":1}}],[\"以及一个存在栈中的\",{\"1\":{\"138\":1}}],[\"以及防止不必要的路径硬编码\",{\"1\":{\"131\":1}}],[\"以及\",{\"1\":{\"117\":1,\"164\":1,\"183\":1,\"271\":1}}],[\"以及变量何时被创建或销毁\",{\"1\":{\"23\":1}}],[\"以及其他整数类型\",{\"1\":{\"284\":1}}],[\"以及其他语言都不同\",{\"1\":{\"16\":1}}],[\"以及其他流程控制有关内容\",{\"1\":{\"15\":1}}],[\"以及处理不可恢复的错误\",{\"1\":{\"7\":1}}],[\"以及把别的类型转换到\",{\"1\":{\"4\":1}}],[\"因\",{\"1\":{\"205\":1}}],[\"因而可以直接\",{\"1\":{\"291\":1}}],[\"因而要求闭包通过可变引用来捕获它\",{\"1\":{\"240\":1}}],[\"因而其中需要允许一些死代码的出现\",{\"1\":{\"39\":1}}],[\"因而\",{\"1\":{\"30\":1,\"235\":1}}],[\"因此闭包接收到的参数是\",{\"1\":{\"306\":1}}],[\"因此闭包需要是可变的\",{\"1\":{\"235\":1}}],[\"因此用法上\",{\"1\":{\"298\":1}}],[\"因此不会产生悬挂指针\",{\"1\":{\"293\":1}}],[\"因此不会发生数据竞争等不安全的事情\",{\"1\":{\"293\":1}}],[\"因此不会违反匹配表达式的类型要求\",{\"1\":{\"84\":1}}],[\"因此不要求\",{\"1\":{\"266\":1}}],[\"因此在这些泛型的情况下要用\",{\"1\":{\"256\":1}}],[\"因此自定义输出的外观经常是更可取的\",{\"1\":{\"256\":1}}],[\"因此之后\",{\"1\":{\"235\":1}}],[\"因此可用\",{\"1\":{\"298\":1}}],[\"因此可用于定义包编译的参数\",{\"1\":{\"42\":1}}],[\"因此可以重新借用\",{\"1\":{\"259\":1}}],[\"因此可以使用可变的引用重新借用\",{\"1\":{\"259\":1}}],[\"因此可以正确地重新借用\",{\"1\":{\"235\":1}}],[\"因此无需\",{\"1\":{\"235\":1}}],[\"因此必须在顶层解构它们\",{\"1\":{\"211\":1}}],[\"因此使用一个对\",{\"1\":{\"205\":1}}],[\"因此很清楚您要实现哪个\",{\"1\":{\"181\":1}}],[\"因此它返回一个\",{\"1\":{\"164\":1}}],[\"因此它提供了一种类型转换的简单机制\",{\"1\":{\"47\":1}}],[\"因此所有的\",{\"1\":{\"163\":1}}],[\"因此当指向某个值的最后一个引用指针退出作用域时\",{\"1\":{\"144\":1}}],[\"因此下面两个函数运行完成以后\",{\"1\":{\"138\":1}}],[\"因此什么也不会打印\",{\"1\":{\"76\":1}}],[\"因此结果的向量\",{\"1\":{\"65\":1}}],[\"因此请确保它们不会相互竞争\",{\"1\":{\"45\":1}}],[\"因此如果没有原始标识符\",{\"1\":{\"40\":1}}],[\"因此\",{\"1\":{\"11\":1,\"42\":1,\"101\":1,\"160\":1,\"164\":1,\"184\":1,\"187\":1,\"256\":1}}],[\"因此尽管努力确保尽可能向前兼容\",{\"1\":{\"3\":1}}],[\"因为不能对整数解\",{\"1\":{\"298\":1}}],[\"因为右边不是\",{\"1\":{\"298\":1}}],[\"因为赋值语句\",{\"1\":{\"298\":1}}],[\"因为所有的情形都已覆盖\",{\"1\":{\"296\":1}}],[\"因为只使用了枚举类型的一种取值\",{\"1\":{\"296\":1}}],[\"因为只有两个可能的键\",{\"1\":{\"284\":1}}],[\"因为否则\",{\"1\":{\"291\":1}}],[\"因为该生命周期从未被约束\",{\"1\":{\"266\":1}}],[\"因为当前还有不可变借用\",{\"1\":{\"259\":1}}],[\"因为对于任何非泛型的容器类型\",{\"1\":{\"256\":1}}],[\"因为在函数退出时\",{\"1\":{\"242\":1}}],[\"因为目前\",{\"1\":{\"242\":1}}],[\"因为借用检查不允许在变量被移动走\",{\"1\":{\"235\":1}}],[\"因为借用检查器保证了它指向一个有效的数据\",{\"1\":{\"33\":1}}],[\"因为之后调用闭包\",{\"1\":{\"235\":1}}],[\"因为闭包里存储着一个\",{\"1\":{\"235\":1}}],[\"因为闭包只持有一个指向\",{\"1\":{\"235\":1}}],[\"因为闭包类型没有名称\",{\"1\":{\"185\":1}}],[\"因为内部的类型已经实现了\",{\"1\":{\"213\":1}}],[\"因为上面显式地使用了\",{\"1\":{\"203\":1}}],[\"因为这两者的概念是不同的\",{\"1\":{\"298\":1}}],[\"因为这个操作很简单常见\",{\"1\":{\"211\":1}}],[\"因为这个方法的行为取决于\",{\"1\":{\"205\":1}}],[\"因为这个字段就是从\",{\"1\":{\"60\":1}}],[\"因为这会产生未定义行为\",{\"1\":{\"196\":1}}],[\"因为这样可能导致使用未初始化的变量\",{\"1\":{\"196\":1}}],[\"因为有类型说明\",{\"1\":{\"194\":1}}],[\"因为别名\",{\"1\":{\"191\":1}}],[\"因为引用的大小是静态已知的\",{\"1\":{\"184\":1}}],[\"因为其不同的实现将需要不同的内存量\",{\"1\":{\"184\":1}}],[\"因为毕竟有多个名为\",{\"1\":{\"181\":1}}],[\"因为我们把数据块\",{\"1\":{\"293\":1}}],[\"因为我们正在处理的程序只有一个线程\",{\"1\":{\"148\":1}}],[\"因为我们使用了泛型类型参数\",{\"1\":{\"11\":1}}],[\"因为变量要负责释放它们拥有的资源\",{\"1\":{\"140\":1}}],[\"因为元组可以拥有任意多个值\",{\"1\":{\"136\":1}}],[\"因为他们表示相同的函数\",{\"1\":{\"131\":1}}],[\"因为宏系统会把它转换成普通的\",{\"1\":{\"112\":1}}],[\"因为标准库提供了那些类型的实现\",{\"1\":{\"107\":1}}],[\"因为那是要打印的内容\",{\"1\":{\"103\":1}}],[\"因为没有被移动而可以继续使用\",{\"1\":{\"282\":1}}],[\"因为没有一种合适的样式适用于所有类型\",{\"1\":{\"256\":1}}],[\"因为没有\",{\"1\":{\"91\":1}}],[\"因为此类型可能具有的所有可能值的集合为空\",{\"1\":{\"84\":1}}],[\"因为此类枚举的实例不具有可比性\",{\"1\":{\"76\":1}}],[\"因为类型不同\",{\"1\":{\"73\":1}}],[\"因为无论如何\",{\"1\":{\"55\":1}}],[\"因为它当前已经被可变借用\",{\"1\":{\"259\":1}}],[\"因为它已经被\",{\"1\":{\"183\":1}}],[\"因为它已经在循环中被\",{\"1\":{\"73\":1}}],[\"因为它是一个指向内存堆中引用的指针\",{\"1\":{\"144\":1}}],[\"因为它不再拥有那部分堆上的内存\",{\"1\":{\"140\":1}}],[\"因为它们各不相交\",{\"1\":{\"139\":1}}],[\"因为它的作用域完全覆盖了\",{\"1\":{\"139\":1}}],[\"因为它的类型标记\",{\"1\":{\"55\":1}}],[\"因为它永远不会返回\",{\"1\":{\"84\":1}}],[\"因为它允许你指定一条错误信息\",{\"1\":{\"7\":1}}],[\"因为编译器大多数时候不能推断它\",{\"1\":{\"48\":1}}],[\"因为并不包含多个值\",{\"1\":{\"20\":1}}],[\"因为\",{\"1\":{\"11\":1,\"76\":1,\"84\":1,\"91\":1,\"107\":1,\"171\":1,\"205\":1,\"221\":1,\"244\":1,\"259\":1,\"266\":1,\"273\":1,\"291\":1,\"293\":1}}],[\"更改程序使\",{\"1\":{\"311\":1}}],[\"更改或自定义关键字类型\",{\"0\":{\"284\":1},\"1\":{\"0\":1}}],[\"更有效\",{\"1\":{\"290\":1}}],[\"更有用\",{\"1\":{\"7\":1}}],[\"更易读\",{\"1\":{\"220\":1}}],[\"更容易\",{\"1\":{\"185\":1}}],[\"更容易访问\",{\"1\":{\"132\":1}}],[\"更重要的是\",{\"1\":{\"185\":1}}],[\"更多细节请看\",{\"1\":{\"222\":1}}],[\"更多细节请看模块和crate\",{\"1\":{\"195\":1}}],[\"更多细节请看借用\",{\"1\":{\"195\":1}}],[\"更多可用的方法可以看这里\",{\"1\":{\"186\":1}}],[\"更多\",{\"1\":{\"152\":1,\"154\":1}}],[\"更多关于文件处理\",{\"1\":{\"15\":1}}],[\"更能表达意图\",{\"1\":{\"7\":1}}],[\"用单独的线程处理每一段数据\",{\"1\":{\"293\":1}}],[\"用到了一个不可变引用\",{\"1\":{\"259\":1}}],[\"用以储存闭包捕获的变量\",{\"1\":{\"233\":1}}],[\"用同一个类型代表了多种错误\",{\"1\":{\"209\":1}}],[\"用传引用\",{\"1\":{\"195\":1}}],[\"用它来匹配所有要运行的测试\",{\"1\":{\"176\":1}}],[\"用它来保证所有的借用都是有效的\",{\"1\":{\"139\":1}}],[\"用等宽字体查看\",{\"1\":{\"139\":1}}],[\"用户定义的类型不实现fmt\",{\"1\":{\"107\":1}}],[\"用来指明\",{\"1\":{\"187\":1}}],[\"用来对集合\",{\"1\":{\"186\":1}}],[\"用来从\",{\"1\":{\"179\":1}}],[\"用来实现打印标记\",{\"1\":{\"89\":1}}],[\"用来测试还没有实现的函数\",{\"1\":{\"7\":1}}],[\"用\",{\"1\":{\"76\":1,\"117\":3,\"286\":1}}],[\"用于储存将要创建的子线程\",{\"1\":{\"293\":1}}],[\"用于约束的\",{\"1\":{\"270\":1}}],[\"用于宣布它在什么时候被调用\",{\"1\":{\"183\":1}}],[\"用于获取路径指向的文件\",{\"1\":{\"164\":1}}],[\"用于防止链接到单独的页面或其他位置\",{\"1\":{\"121\":1}}],[\"用于内联文档\",{\"1\":{\"120\":1}}],[\"用于字面常量\",{\"1\":{\"110\":1}}],[\"用于变量名或函数名\",{\"1\":{\"110\":1}}],[\"用于表达式\",{\"1\":{\"110\":1}}],[\"用于有\",{\"1\":{\"68\":1}}],[\"用于易出错的转换\",{\"1\":{\"52\":1}}],[\"用于改变或定义原生类型和用户定义类型\",{\"1\":{\"31\":1}}],[\"用法类似\",{\"1\":{\"79\":1}}],[\"用法\",{\"1\":{\"0\":1}}],[\"在传给它一个迭代器时\",{\"1\":{\"308\":1}}],[\"在生成输出之前\",{\"1\":{\"290\":1}}],[\"在生命周期没有省略\",{\"1\":{\"266\":1}}],[\"在文件的行上返回一个迭代器\",{\"1\":{\"290\":1}}],[\"在文档测试中使用隐藏的\",{\"1\":{\"171\":1}}],[\"在文档中使用\",{\"0\":{\"126\":1}}],[\"在文档注释中\",{\"1\":{\"118\":1}}],[\"在单个变量的解构内\",{\"1\":{\"282\":1}}],[\"在结构体中标注生命周期也和函数的类似\",{\"1\":{\"277\":1}}],[\"在函数内部使用生命周期\",{\"1\":{\"266\":1}}],[\"在函数中临时创建的引用也就不复存在了\",{\"1\":{\"138\":1}}],[\"在解构一个结构体时\",{\"1\":{\"263\":1}}],[\"在通过\",{\"1\":{\"263\":1}}],[\"在添加了针对\",{\"1\":{\"251\":1}}],[\"在闭包中留下无效的引用\",{\"1\":{\"242\":1}}],[\"在闭包的签名中删除\",{\"1\":{\"235\":1}}],[\"在语义上是不可复制的\",{\"1\":{\"235\":1}}],[\"在竖线\",{\"1\":{\"235\":1}}],[\"在最后使用\",{\"1\":{\"235\":1}}],[\"在处理嵌套循环的时候可以\",{\"1\":{\"226\":1}}],[\"在模块的层面上创建别名特别有帮助\",{\"1\":{\"223\":1}}],[\"在尝试吃食物之前确认食物是否存在是非常重要的\",{\"1\":{\"217\":1}}],[\"在某些语言中它叫做\",{\"1\":{\"215\":1}}],[\"在其头部插入新元素\",{\"1\":{\"205\":1}}],[\"在此作用域上不存在\",{\"1\":{\"199\":1}}],[\"在不可变绑定超出作用域之前\",{\"1\":{\"197\":1}}],[\"在不同类型之间进行转换\",{\"1\":{\"15\":1}}],[\"在本作用域被冻结\",{\"1\":{\"197\":1,\"260\":1}}],[\"在本例中\",{\"1\":{\"195\":1,\"293\":1}}],[\"在本章一开始\",{\"1\":{\"32\":1}}],[\"在向量中插入\",{\"1\":{\"194\":1}}],[\"在集成测试中要想共享代码\",{\"1\":{\"173\":1}}],[\"在与\",{\"1\":{\"173\":1}}],[\"在内部并不是用\",{\"1\":{\"164\":1}}],[\"在内存中是连续存储的\",{\"1\":{\"134\":1}}],[\"在迭代的同时\",{\"1\":{\"154\":1}}],[\"在字符串尾部插入一个字符串\",{\"1\":{\"152\":1}}],[\"在字符串的尾部插入一个字符\",{\"1\":{\"152\":1}}],[\"在回退栈的同时\",{\"1\":{\"148\":1}}],[\"在占据了多余空间时还可以缩小自己\",{\"1\":{\"146\":1}}],[\"在堆上分配这个点\",{\"1\":{\"145\":1}}],[\"在堆上分配一个整型数据\",{\"1\":{\"141\":3}}],[\"在移动资源之后\",{\"1\":{\"140\":1}}],[\"在进行赋值\",{\"1\":{\"140\":1}}],[\"在后面我们将会看到生命周期更强大的功能\",{\"1\":{\"139\":1}}],[\"在它销毁的时候结束\",{\"1\":{\"139\":1}}],[\"在同一模块中\",{\"1\":{\"133\":1}}],[\"在构建和测试时跳过该代码\",{\"1\":{\"125\":1}}],[\"在哪里找到库\",{\"1\":{\"118\":1}}],[\"在第\",{\"1\":{\"107\":1}}],[\"在第一次使用\",{\"1\":{\"11\":1}}],[\"在格式说明符中使用命名参数\",{\"1\":{\"107\":1}}],[\"在数字右边补零\",{\"1\":{\"107\":1}}],[\"在这作用域没有冻结\",{\"1\":{\"260\":1}}],[\"在这类情形中\",{\"1\":{\"226\":1}}],[\"在这类情况下\",{\"1\":{\"67\":1}}],[\"在这个错误类型中\",{\"1\":{\"213\":1}}],[\"在这个作用域没有冻结\",{\"1\":{\"197\":1}}],[\"在这个例子是\",{\"1\":{\"131\":1}}],[\"在这个例子中\",{\"1\":{\"86\":1,\"131\":1,\"132\":1}}],[\"在这里我们我们接受了一个\",{\"1\":{\"272\":1}}],[\"在这里\",{\"1\":{\"272\":1}}],[\"在这里也是合法的类型\",{\"1\":{\"246\":1}}],[\"在这里定义可以被方法使用的泛型类型\",{\"1\":{\"246\":1}}],[\"在这里使用别名又让我们节省了一些代码量\",{\"1\":{\"223\":1}}],[\"在这里再次销毁\",{\"1\":{\"183\":1}}],[\"在这里被销毁\",{\"1\":{\"141\":3}}],[\"在这里面的所有内容都不会被编译器读取\",{\"1\":{\"105\":1}}],[\"在这方面\",{\"1\":{\"113\":1}}],[\"在这种情况下\",{\"1\":{\"76\":1,\"282\":1}}],[\"在这样的场合要简洁得多\",{\"1\":{\"76\":1}}],[\"在一个叫做\",{\"1\":{\"173\":1}}],[\"在一些场合下\",{\"1\":{\"76\":1}}],[\"在一般函数中访问常量\",{\"1\":{\"55\":1}}],[\"在上一个例子中\",{\"1\":{\"220\":1}}],[\"在上一小节中\",{\"1\":{\"43\":1}}],[\"在上面调用后就不再存活\",{\"1\":{\"291\":1}}],[\"在上面这种情形中\",{\"1\":{\"266\":1}}],[\"在上面这些代码中\",{\"1\":{\"73\":1}}],[\"在上面的例子中给\",{\"1\":{\"137\":1}}],[\"在每次迭代中\",{\"1\":{\"73\":1}}],[\"在每次迭代中借用集合中的一个元素\",{\"1\":{\"73\":1}}],[\"在失败的情况下\",{\"1\":{\"70\":1}}],[\"在使用类型\",{\"1\":{\"91\":1}}],[\"在使用泛型时\",{\"1\":{\"89\":1}}],[\"在使用\",{\"1\":{\"70\":1,\"185\":1,\"213\":1}}],[\"在使用时\",{\"1\":{\"11\":1}}],[\"在接收到\",{\"1\":{\"68\":1}}],[\"在接下来的小节中会一一介绍\",{\"1\":{\"7\":1}}],[\"在标准库\",{\"1\":{\"68\":1}}],[\"在标准库中有无数\",{\"1\":{\"47\":1}}],[\"在泛型中很有用\",{\"1\":{\"60\":1}}],[\"在代码目录组织上\",{\"1\":{\"45\":1}}],[\"在需要时下载\",{\"1\":{\"44\":1}}],[\"在撰写本文时\",{\"1\":{\"44\":1}}],[\"在下一部分\",{\"1\":{\"220\":1}}],[\"在下一节会看到\",{\"1\":{\"244\":1}}],[\"在下一节将进一步介绍\",{\"1\":{\"146\":1}}],[\"在下一节中\",{\"1\":{\"43\":1}}],[\"在下面的例子中尝试使用这些操作\",{\"1\":{\"285\":1}}],[\"在下面的例子中\",{\"1\":{\"225\":1,\"240\":1}}],[\"在下面的例子和本章节剩下的内容里\",{\"1\":{\"139\":1}}],[\"在下面的小节中\",{\"1\":{\"115\":1}}],[\"在下面一些情况下很有用\",{\"1\":{\"103\":1}}],[\"在下面几节中\",{\"1\":{\"67\":1}}],[\"在下面代码中\",{\"1\":{\"67\":1}}],[\"在下面例子中\",{\"1\":{\"30\":1,\"68\":1,\"101\":1,\"114\":1,\"215\":1,\"217\":1,\"244\":1}}],[\"在布尔表达式中使用\",{\"1\":{\"36\":1}}],[\"在属性位置中使用\",{\"1\":{\"36\":1}}],[\"在变量名前加上下划线以消除警告\",{\"1\":{\"35\":1}}],[\"在整个代码库\",{\"1\":{\"32\":1}}],[\"在原生类型基础上进行了大量扩充\",{\"1\":{\"24\":1}}],[\"在原型开发中这很有用\",{\"1\":{\"7\":1}}],[\"在软件工程中\",{\"1\":{\"17\":1}}],[\"在定义类型\",{\"1\":{\"11\":1}}],[\"在之前被定义为\",{\"1\":{\"11\":1}}],[\"在\",{\"0\":{\"125\":1},\"1\":{\"7\":1,\"11\":1,\"32\":1,\"40\":1,\"41\":1,\"44\":1,\"54\":1,\"55\":1,\"73\":1,\"107\":1,\"125\":1,\"131\":1,\"136\":1,\"138\":1,\"145\":1,\"154\":1,\"174\":1,\"187\":1,\"193\":1,\"222\":1,\"228\":2,\"246\":1,\"251\":1,\"264\":1,\"270\":1,\"293\":1,\"310\":1}}],[\"那样的语言用法不一样\",{\"1\":{\"298\":1}}],[\"那样的的\",{\"1\":{\"184\":1}}],[\"那样\",{\"1\":{\"225\":1}}],[\"那就在定界符中使用更多的\",{\"1\":{\"153\":1}}],[\"那就是\",{\"1\":{\"16\":1}}],[\"那么返回\",{\"1\":{\"286\":2}}],[\"那么该集合也就实现了\",{\"1\":{\"285\":1}}],[\"那么新值将会替换旧的值\",{\"1\":{\"285\":1}}],[\"那么这些集合类也就实现了\",{\"1\":{\"284\":1}}],[\"那么这对你会有所帮助\",{\"1\":{\"58\":1}}],[\"那么它应该是哪种样式\",{\"1\":{\"256\":1}}],[\"那么它返回\",{\"1\":{\"215\":1}}],[\"那么不允许该闭包通过\",{\"1\":{\"240\":1}}],[\"那么任何满足该闭包的\",{\"1\":{\"238\":1}}],[\"那么若\",{\"1\":{\"219\":1}}],[\"那么同时你也就免费获得了\",{\"1\":{\"48\":1}}],[\"那么很容易相信我们也能够把类型\",{\"1\":{\"46\":1}}],[\"那么\",{\"1\":{\"44\":1,\"91\":1,\"146\":1,\"151\":1,\"186\":1,\"246\":1,\"285\":1}}],[\"那么你就知道这会带来的极大的痛苦\",{\"1\":{\"44\":1}}],[\"那么模块文件的内容将在编译之前被插入\",{\"1\":{\"5\":1}}],[\"那要怎样做呢\",{\"1\":{\"43\":1}}],[\"那显然是有问题的\",{\"1\":{\"7\":1}}],[\"关于文档风格的\",{\"1\":{\"172\":1}}],[\"关键字等价于右边的\",{\"1\":{\"263\":1}}],[\"关键字可用来创建结构体\",{\"1\":{\"263\":1}}],[\"关键字可以用作当型循环\",{\"1\":{\"80\":1}}],[\"关键字进行显式类型转换\",{\"1\":{\"193\":1}}],[\"关键字编写返回类型\",{\"1\":{\"184\":1}}],[\"关键字表示父作用域\",{\"1\":{\"131\":1}}],[\"关键字表示当前的模块作用域\",{\"1\":{\"131\":1}}],[\"关键字允许创建一个从数个不同取值中选其一的枚举类型\",{\"1\":{\"57\":1}}],[\"关键字\",{\"1\":{\"10\":1,\"40\":1,\"55\":1,\"131\":1,\"242\":1}}],[\"关键字来定义\",{\"1\":{\"246\":1}}],[\"关键字来提供模式匹配\",{\"1\":{\"79\":1}}],[\"关键字来表示一个无限循环\",{\"1\":{\"78\":1}}],[\"关键字来声明\",{\"1\":{\"10\":1}}],[\"关键字来创建引用\",{\"1\":{\"298\":1}}],[\"关键字来创建\",{\"1\":{\"6\":1,\"60\":1}}],[\"关联函数签名\",{\"1\":{\"30\":1}}],[\"关联类型恰好提供了这样的功能\",{\"1\":{\"244\":1}}],[\"关联类型\",{\"0\":{\"246\":1},\"1\":{\"0\":1,\"87\":1,\"246\":1}}],[\"关联项就提供了简单的使用方法\",{\"1\":{\"87\":1}}],[\"关联项\",{\"0\":{\"87\":1},\"1\":{\"0\":1,\"87\":2}}],[\"eu\",{\"1\":{\"288\":2}}],[\"est\",{\"1\":{\"288\":2}}],[\"esse\",{\"1\":{\"288\":2}}],[\"escher\",{\"1\":{\"261\":1}}],[\"escapes\",{\"1\":{\"153\":1}}],[\"escaped\",{\"1\":{\"153\":6}}],[\"escape\",{\"1\":{\"153\":3}}],[\"eiusmod\",{\"1\":{\"288\":2}}],[\"either\",{\"1\":{\"277\":2}}],[\"either<\",{\"1\":{\"277\":1}}],[\"ea\",{\"1\":{\"288\":2}}],[\"early\",{\"1\":{\"220\":1}}],[\"eat\",{\"1\":{\"138\":4,\"215\":7,\"217\":4}}],[\"echo\",{\"1\":{\"161\":3,\"289\":1,\"290\":1}}],[\"etc\",{\"1\":{\"256\":1}}],[\"et\",{\"1\":{\"141\":1,\"148\":1,\"288\":2}}],[\"elit\",{\"1\":{\"288\":2}}],[\"elided\",{\"1\":{\"264\":4}}],[\"elision\",{\"1\":{\"264\":1,\"268\":1}}],[\"elem2\",{\"1\":{\"285\":1}}],[\"elem1\",{\"1\":{\"285\":1}}],[\"elem\",{\"1\":{\"194\":3,\"205\":2}}],[\"elements\",{\"1\":{\"134\":1,\"235\":1,\"300\":1}}],[\"element\",{\"1\":{\"134\":3,\"136\":1,\"154\":3,\"209\":1,\"210\":1,\"213\":1,\"293\":1}}],[\"else`\",{\"1\":{\"161\":1}}],[\"else\",{\"0\":{\"75\":1},\"1\":{\"0\":1,\"9\":1,\"10\":3,\"15\":1,\"30\":2,\"36\":1,\"52\":1,\"55\":1,\"72\":6,\"75\":5,\"76\":4,\"80\":3,\"81\":2,\"85\":1,\"147\":1,\"148\":1,\"151\":3,\"159\":1,\"161\":6,\"166\":2,\"171\":1,\"175\":1,\"179\":1,\"184\":1,\"207\":1,\"251\":2,\"286\":3}}],[\"everyman\",{\"1\":{\"284\":5}}],[\"even\",{\"1\":{\"153\":1}}],[\"event\",{\"1\":{\"57\":2}}],[\"evennumber\",{\"1\":{\"52\":7}}],[\"eval\",{\"1\":{\"112\":3,\"116\":8}}],[\"eprintln\",{\"1\":{\"107\":1}}],[\"eprint\",{\"1\":{\"107\":2}}],[\"email\",{\"1\":{\"284\":5}}],[\"emoticon\",{\"1\":{\"76\":3}}],[\"emptyvec\",{\"1\":{\"207\":4,\"209\":1,\"211\":4,\"213\":4}}],[\"empty\",{\"1\":{\"67\":2,\"93\":5,\"207\":2,\"209\":2,\"210\":5,\"211\":2,\"213\":2}}],[\"e\",{\"1\":{\"70\":2,\"151\":1,\"153\":2,\"161\":10,\"166\":1,\"207\":3,\"209\":2,\"211\":3,\"213\":6,\"220\":6,\"221\":2,\"222\":2,\"223\":2,\"225\":8,\"251\":1,\"290\":1}}],[\"e>\",{\"1\":{\"65\":1,\"70\":1,\"151\":1}}],[\"e>>\",{\"1\":{\"65\":1}}],[\"edible\",{\"1\":{\"217\":1}}],[\"edition\",{\"1\":{\"261\":5}}],[\"edition=2018\",{\"1\":{\"54\":1}}],[\"editable\",{\"1\":{\"125\":3}}],[\"edge\",{\"1\":{\"60\":4}}],[\"err<e>\",{\"1\":{\"70\":1}}],[\"err\",{\"1\":{\"52\":3,\"65\":1,\"66\":1,\"70\":1,\"151\":7,\"153\":1,\"161\":7,\"171\":1,\"207\":2,\"209\":6,\"211\":7,\"213\":3,\"220\":5,\"221\":4,\"222\":1,\"223\":2,\"225\":9,\"286\":8,\"287\":1,\"288\":2,\"289\":2,\"291\":3}}],[\"error`\",{\"1\":{\"213\":1,\"289\":1}}],[\"errortype>\",{\"1\":{\"171\":1}}],[\"error2>\",{\"1\":{\"67\":1}}],[\"error1>\",{\"1\":{\"67\":1}}],[\"errors\",{\"1\":{\"66\":8,\"141\":2,\"148\":2}}],[\"error>>\",{\"1\":{\"207\":1,\"211\":1}}],[\"error>`\",{\"1\":{\"207\":1,\"211\":1}}],[\"error>\",{\"1\":{\"52\":1,\"160\":1,\"163\":1,\"207\":1}}],[\"error\",{\"0\":{\"320\":1,\"338\":1},\"1\":{\"7\":1,\"24\":1,\"40\":1,\"52\":1,\"141\":2,\"148\":2,\"170\":1,\"175\":1,\"200\":1,\"207\":7,\"208\":1,\"209\":6,\"210\":2,\"211\":5,\"213\":7,\"220\":1,\"221\":1,\"222\":1,\"223\":1,\"225\":2,\"287\":4}}],[\"equivalent\",{\"1\":{\"147\":1}}],[\"equals\",{\"1\":{\"179\":1,\"263\":1}}],[\"equal\",{\"1\":{\"111\":2,\"149\":1}}],[\"equality\",{\"1\":{\"101\":1}}],[\"eq\",{\"1\":{\"34\":1,\"52\":4,\"111\":1,\"146\":1,\"149\":1,\"168\":2,\"170\":2,\"173\":2,\"174\":3,\"175\":1,\"177\":4,\"179\":1,\"181\":2,\"185\":6,\"219\":1,\"227\":1,\"247\":1,\"248\":1,\"284\":8}}],[\"excepteur\",{\"1\":{\"288\":2}}],[\"excluding\",{\"1\":{\"84\":1}}],[\"ex\",{\"1\":{\"288\":2}}],[\"exercitation\",{\"1\":{\"288\":2}}],[\"execute\",{\"1\":{\"166\":1}}],[\"executable\",{\"1\":{\"54\":2}}],[\"explicit\",{\"1\":{\"185\":1,\"201\":1}}],[\"expression\",{\"1\":{\"174\":1}}],[\"expr\",{\"1\":{\"110\":2,\"111\":3,\"112\":1,\"113\":4,\"114\":3,\"116\":3}}],[\"expected\",{\"1\":{\"40\":2,\"175\":2,\"225\":1}}],[\"expect\",{\"1\":{\"7\":2,\"68\":1,\"293\":1}}],[\"exitstatus\",{\"1\":{\"292\":1}}],[\"exited\",{\"1\":{\"183\":2,\"226\":1}}],[\"exiting\",{\"1\":{\"183\":2}}],[\"exit\",{\"1\":{\"84\":1,\"141\":1,\"148\":1}}],[\"extern\",{\"1\":{\"40\":2,\"44\":1,\"54\":3,\"118\":1,\"159\":3}}],[\"examples`\",{\"1\":{\"149\":2}}],[\"examples\",{\"0\":{\"358\":1},\"1\":{\"149\":5,\"170\":2}}],[\"example\",{\"1\":{\"15\":4}}],[\"enim\",{\"1\":{\"288\":2}}],[\"end\",{\"1\":{\"183\":1,\"292\":2}}],[\"ends\",{\"1\":{\"139\":3,\"292\":1}}],[\"env\",{\"1\":{\"156\":3,\"287\":2}}],[\"environment\",{\"1\":{\"42\":1}}],[\"encoding\",{\"1\":{\"153\":1}}],[\"encapsulation\",{\"1\":{\"129\":1}}],[\"enough\",{\"1\":{\"78\":1,\"99\":8}}],[\"entered\",{\"1\":{\"226\":2}}],[\"entering\",{\"1\":{\"132\":1}}],[\"enter\",{\"1\":{\"13\":1}}],[\"enumerate\",{\"1\":{\"154\":1,\"293\":2,\"295\":1,\"310\":1}}],[\"enumeration\",{\"1\":{\"6\":1,\"57\":1}}],[\"enum\",{\"0\":{\"337\":1},\"1\":{\"6\":1,\"15\":1,\"57\":4,\"58\":2,\"76\":3,\"151\":1,\"201\":5,\"203\":2,\"205\":3,\"213\":1,\"215\":2,\"217\":1,\"228\":1,\"249\":2,\"250\":1,\"277\":1,\"286\":1,\"296\":2,\"297\":1}}],[\"或其他任意泛型容器\",{\"1\":{\"256\":1}}],[\"或写能力\",{\"1\":{\"163\":1}}],[\"或任意实现了\",{\"1\":{\"146\":1}}],[\"或通过值来传递函数参数\",{\"1\":{\"140\":1}}],[\"或祖先模块\",{\"1\":{\"133\":1}}],[\"或终止进程的函数\",{\"1\":{\"84\":1}}],[\"或使用\",{\"1\":{\"68\":1}}],[\"或是\",{\"1\":{\"67\":1}}],[\"或默认方式来声明类型\",{\"1\":{\"21\":1}}],[\"或\",{\"1\":{\"20\":1,\"57\":1,\"89\":1,\"128\":1,\"164\":1,\"185\":1,\"211\":1,\"226\":1,\"233\":2,\"240\":3,\"244\":2,\"246\":1,\"254\":1,\"284\":1,\"289\":1,\"293\":1,\"310\":1}}],[\"或私有\",{\"1\":{\"18\":1}}],[\"或者将它们存储在另一个数组\",{\"1\":{\"300\":1}}],[\"或者将其做成切片\",{\"1\":{\"300\":1}}],[\"或者你要判断一样东西是不是已经存在\",{\"1\":{\"285\":1}}],[\"或者说\",{\"1\":{\"259\":1}}],[\"或者自动定义\",{\"1\":{\"186\":1}}],[\"或者使用\",{\"1\":{\"177\":1}}],[\"或者需要一个字节数组\",{\"1\":{\"153\":1}}],[\"或者是直接原样写出会更便利\",{\"1\":{\"153\":1}}],[\"或者改用另一种间接的方法\",{\"1\":{\"103\":1}}],[\"或者编译器没有足够的信息来推断类型参数\",{\"1\":{\"91\":1}}],[\"或者产生一个更有用的函数的函数\",{\"1\":{\"85\":1}}],[\"或者一个\",{\"1\":{\"213\":1}}],[\"或者一个普通的结构体\",{\"1\":{\"57\":1}}],[\"或者一个元组结构体\",{\"1\":{\"57\":1}}],[\"或者用\",{\"1\":{\"51\":1}}],[\"或者库\",{\"1\":{\"44\":1}}],[\"或者\",{\"1\":{\"11\":1,\"72\":1,\"235\":1}}],[\"或者缺少值并不是错误的情况准备的\",{\"1\":{\"7\":1}}],[\"或库文件\",{\"1\":{\"5\":1}}],[\"或项的元数据\",{\"1\":{\"1\":1,\"15\":1}}],[\"是对迭代器元素的引用类型\",{\"1\":{\"308\":1}}],[\"是对未知类型\",{\"1\":{\"15\":1,\"30\":1}}],[\"是迭代器对应的元素的类型\",{\"1\":{\"306\":1}}],[\"是闭包作用在元素上的返回值\",{\"1\":{\"306\":1}}],[\"是异或的意思\",{\"1\":{\"293\":1}}],[\"是相同的\",{\"1\":{\"270\":1}}],[\"是什么类型\",{\"1\":{\"246\":1}}],[\"是因为\",{\"1\":{\"240\":1}}],[\"是因为运算符就是方法调用的语法糖\",{\"1\":{\"187\":1}}],[\"是处理\",{\"1\":{\"217\":1}}],[\"是处理可能发生的失败情况的过程\",{\"1\":{\"7\":1}}],[\"是不同类型之间的转换工具\",{\"1\":{\"211\":1}}],[\"是不可变的\",{\"1\":{\"86\":1}}],[\"是借用的\",{\"1\":{\"205\":1}}],[\"是由\",{\"1\":{\"200\":1}}],[\"是这样一种\",{\"1\":{\"174\":1}}],[\"是这样一种概念\",{\"1\":{\"139\":1}}],[\"是要发送\",{\"1\":{\"158\":1}}],[\"是大小可变的数组\",{\"1\":{\"154\":1}}],[\"是堆分配的\",{\"1\":{\"152\":1}}],[\"是怎样工作的\",{\"1\":{\"142\":1}}],[\"是每个元素的类型\",{\"1\":{\"136\":1}}],[\"是隐藏参数\",{\"1\":{\"101\":1}}],[\"是隐式传递的\",{\"1\":{\"86\":1}}],[\"是泛型类型\",{\"1\":{\"95\":1}}],[\"是泛型的\",{\"1\":{\"11\":1,\"101\":2,\"244\":1}}],[\"是方法调用者的\",{\"1\":{\"86\":1}}],[\"是依附于对象的函数\",{\"1\":{\"86\":1}}],[\"是可行的\",{\"1\":{\"76\":1}}],[\"是已编译好的库的路径\",{\"1\":{\"54\":1}}],[\"是私有的\",{\"1\":{\"54\":1,\"133\":4}}],[\"是类型转换的通用\",{\"1\":{\"52\":1}}],[\"是内部相关联的\",{\"1\":{\"46\":1}}],[\"是本项目\",{\"1\":{\"44\":1}}],[\"是新项目的入口源文件\",{\"1\":{\"44\":1}}],[\"是我们想要使用的二进制可执行文件的名称\",{\"1\":{\"43\":1}}],[\"是实现者类型\",{\"1\":{\"30\":1}}],[\"是具体类型\",{\"1\":{\"11\":1}}],[\"是一种\",{\"1\":{\"293\":1}}],[\"是一种显式地失败\",{\"1\":{\"7\":1}}],[\"是一样的\",{\"1\":{\"193\":1,\"310\":1}}],[\"是一些实现了\",{\"1\":{\"183\":1}}],[\"是一组拥有相同类型\",{\"1\":{\"134\":1}}],[\"是一类能够捕获周围作用域中变量的函数\",{\"1\":{\"83\":1}}],[\"是一门非常重视正确性的语言\",{\"1\":{\"28\":1}}],[\"是一门注重安全\",{\"1\":{\"15\":1}}],[\"是一个指向\",{\"1\":{\"263\":1}}],[\"是一个指向堆分配的整数的指针\",{\"1\":{\"140\":1}}],[\"是一个对分配在只读内存区的字符串的引用\",{\"1\":{\"261\":1}}],[\"是一个包含单个\",{\"1\":{\"254\":1}}],[\"是一个缓冲区\",{\"1\":{\"251\":1}}],[\"是一个带有虚类型参数\",{\"1\":{\"249\":1}}],[\"是一个函数\",{\"1\":{\"195\":1,\"306\":1,\"308\":1}}],[\"是一个总是指向有效\",{\"1\":{\"152\":1}}],[\"是一个智能指针\",{\"1\":{\"145\":1}}],[\"是一个在线运行\",{\"1\":{\"124\":1}}],[\"是一个具体类型\",{\"1\":{\"91\":1}}],[\"是一个\",{\"1\":{\"86\":1,\"107\":1,\"186\":1,\"298\":1}}],[\"是一个库文件\",{\"1\":{\"38\":1}}],[\"是一个二进制的可执行文件还是一个库\",{\"1\":{\"38\":1}}],[\"是一个宏\",{\"1\":{\"13\":1}}],[\"是一个泛型类型\",{\"1\":{\"11\":1}}],[\"是个具体类型\",{\"1\":{\"11\":1}}],[\"是关于泛化类型和函数功能\",{\"1\":{\"11\":1}}],[\"是\",{\"1\":{\"5\":1,\"15\":1,\"70\":1,\"73\":1,\"86\":1,\"111\":1,\"112\":1,\"152\":1,\"164\":1,\"189\":2,\"191\":2,\"193\":1,\"194\":1,\"210\":1,\"215\":1,\"219\":4,\"298\":1,\"308\":1}}],[\"是官方的\",{\"1\":{\"2\":1}}],[\"尤其是从\",{\"1\":{\"4\":1}}],[\"方式打印结构体\",{\"1\":{\"60\":1}}],[\"方便的基准测试\",{\"1\":{\"2\":1}}],[\"方便的单元测试\",{\"1\":{\"2\":1}}],[\"方法会把迭代器元素的引用传给闭包\",{\"1\":{\"308\":1}}],[\"方法会自动地把\",{\"1\":{\"306\":1}}],[\"方法返回一个描述错误的字符串\",{\"1\":{\"289\":1}}],[\"方法返回一个可显示\",{\"1\":{\"164\":1}}],[\"方法的参数\",{\"1\":{\"284\":1}}],[\"方法的标注和函数类似\",{\"1\":{\"273\":1}}],[\"方法中生命期的标注基本上与函数类似\",{\"1\":{\"279\":1}}],[\"方法一般是不需要标明生命周期的\",{\"1\":{\"273\":1}}],[\"方法是\",{\"1\":{\"187\":1}}],[\"方法对数组\",{\"1\":{\"186\":1}}],[\"方法移除前\",{\"1\":{\"186\":1}}],[\"方法提取\",{\"1\":{\"186\":1}}],[\"方法将一些集合类型转换为迭代器\",{\"1\":{\"186\":1}}],[\"方法都返回\",{\"1\":{\"163\":1}}],[\"方法简化\",{\"1\":{\"161\":1}}],[\"方法从通道中拿到一个消息\",{\"1\":{\"158\":1}}],[\"方法获得一个\",{\"1\":{\"154\":1}}],[\"方法可以在\",{\"1\":{\"152\":1,\"154\":1}}],[\"方法可以重载\",{\"1\":{\"30\":1}}],[\"方法在\",{\"1\":{\"86\":1}}],[\"方法自定义\",{\"1\":{\"68\":1}}],[\"方法签名\",{\"1\":{\"30\":1}}],[\"方法\",{\"0\":{\"86\":1,\"273\":1},\"1\":{\"0\":2,\"30\":1,\"70\":1,\"86\":1,\"130\":1,\"164\":1,\"178\":1,\"181\":1,\"187\":1,\"206\":1,\"249\":1,\"274\":1,\"288\":1,\"290\":1}}],[\"官方文档的\",{\"1\":{\"225\":1}}],[\"官方文档\",{\"1\":{\"127\":1}}],[\"官方文档中注意到了一个名为\",{\"1\":{\"126\":1}}],[\"官方文档中英文双语教程\",{\"1\":{\"15\":1}}],[\"官方的\",{\"1\":{\"44\":1,\"87\":1}}],[\"官方手册中找到详细内容\",{\"1\":{\"2\":1}}],[\"官方\",{\"1\":{\"2\":1}}],[\"这三个取值仅由它们的名字\",{\"1\":{\"296\":1}}],[\"这三个函数会以不同的方式返回集合中的数据\",{\"1\":{\"73\":1}}],[\"这点非常重要\",{\"1\":{\"291\":1}}],[\"这点代价不值一提\",{\"1\":{\"48\":1}}],[\"这正是\",{\"1\":{\"290\":1}}],[\"这能够以其他方式来来打开文件\",{\"1\":{\"288\":1}}],[\"这通常将元素打印成这样的格式\",{\"1\":{\"285\":1}}],[\"这有什么意义呢\",{\"1\":{\"285\":1}}],[\"这很大程度上是由于若使用浮点数作为散列表的键\",{\"1\":{\"284\":1}}],[\"这包括\",{\"1\":{\"284\":1}}],[\"这两个生命周期都必须至少要和\",{\"1\":{\"266\":1}}],[\"这两种引用类型的差异似乎也无关紧要\",{\"1\":{\"55\":1}}],[\"这两种类型时都没有作用\",{\"1\":{\"38\":1}}],[\"这两种把\",{\"1\":{\"11\":1}}],[\"这叫做可变引用\",{\"1\":{\"261\":1}}],[\"这语句不能运行\",{\"1\":{\"256\":1}}],[\"这并不是一个问题\",{\"1\":{\"256\":1}}],[\"这并不是把集合变成迭代器的唯一方法\",{\"1\":{\"73\":1}}],[\"这需要通过手动实现\",{\"1\":{\"256\":1}}],[\"这说明闭包可能采取\",{\"1\":{\"240\":1}}],[\"这句可能说得不对\",{\"1\":{\"240\":1}}],[\"这要求闭包是泛型的\",{\"1\":{\"233\":1}}],[\"这太有用了\",{\"1\":{\"223\":1}}],[\"这次我们使用提前返回改写之前的例子\",{\"1\":{\"220\":1}}],[\"这对\",{\"1\":{\"215\":1}}],[\"这段代码已经相当清晰了\",{\"1\":{\"211\":1}}],[\"这段代码支持编辑\",{\"1\":{\"13\":1}}],[\"这只是中断内部的循环\",{\"1\":{\"226\":1}}],[\"这只是在大多数情况下是正确的\",{\"1\":{\"211\":1}}],[\"这只是一种风格\",{\"1\":{\"105\":1}}],[\"这一行\",{\"1\":{\"194\":1}}],[\"这一点就特别有用\",{\"1\":{\"40\":1}}],[\"这之所以可行\",{\"1\":{\"187\":1}}],[\"这使得捕获\",{\"1\":{\"235\":1}}],[\"这使得使用\",{\"1\":{\"185\":1}}],[\"这使得所有\",{\"1\":{\"160\":1,\"163\":1}}],[\"这使读者既可以运行你的代码示例\",{\"1\":{\"125\":1}}],[\"这时\",{\"1\":{\"217\":1}}],[\"这时可以使用原始字符串\",{\"1\":{\"153\":1}}],[\"这时常常可以使用宏来避免重复代码\",{\"1\":{\"16\":1}}],[\"这相当于包裹在\",{\"1\":{\"149\":1}}],[\"这被称为资源的移动\",{\"1\":{\"140\":1}}],[\"这也就是说\",{\"1\":{\"220\":1}}],[\"这也防止了资源的重复释放\",{\"1\":{\"140\":1}}],[\"这也是永远循环\",{\"1\":{\"84\":1}}],[\"这也是编译时输出的二进制可执行文件的名称\",{\"1\":{\"44\":1}}],[\"这限制了生命周期的用法\",{\"1\":{\"139\":1}}],[\"这就有一个问题\",{\"1\":{\"256\":1}}],[\"这就和取模一样\",{\"1\":{\"193\":1}}],[\"这就允许你为一些特定功能创造一套简洁直观的语法\",{\"1\":{\"112\":1}}],[\"这就是编译时发现的错误\",{\"1\":{\"76\":1}}],[\"这就是为什么下面比较\",{\"1\":{\"76\":1}}],[\"这将得到一个错误\",{\"1\":{\"302\":1}}],[\"这将会打印出\",{\"1\":{\"285\":1}}],[\"这将需要更多代码\",{\"1\":{\"219\":1}}],[\"这将需要很多的嵌套的\",{\"1\":{\"219\":1}}],[\"这将返回\",{\"1\":{\"219\":1}}],[\"这将返回一个迭代器\",{\"1\":{\"156\":1}}],[\"这将在\",{\"1\":{\"131\":1}}],[\"这将不会编译\",{\"1\":{\"107\":1}}],[\"这将输出\",{\"1\":{\"107\":2}}],[\"这可能会很麻烦\",{\"1\":{\"310\":1}}],[\"这可能是因为调用了返回类型是泛型的函数\",{\"1\":{\"91\":1}}],[\"这可手动在\",{\"1\":{\"186\":1}}],[\"这可以工作\",{\"1\":{\"213\":1}}],[\"这可以大大简化你的类型签名\",{\"1\":{\"185\":1}}],[\"这可以通过使用类型推断\",{\"1\":{\"51\":1}}],[\"这可使用\",{\"1\":{\"147\":1}}],[\"这可避免悬挂指针\",{\"1\":{\"140\":1}}],[\"这拥有更好的表现力\",{\"1\":{\"89\":1}}],[\"这类方法一般用作构造器\",{\"1\":{\"86\":1}}],[\"这类标记\",{\"1\":{\"11\":1}}],[\"这毫无问题\",{\"1\":{\"84\":1}}],[\"这允许我们编写如下代码\",{\"1\":{\"84\":1}}],[\"这读作\",{\"1\":{\"81\":1}}],[\"这会返回一个\",{\"1\":{\"292\":1}}],[\"这会中断外层循环\",{\"1\":{\"226\":1}}],[\"这会失败吗\",{\"1\":{\"151\":1}}],[\"这会移除掉一层装箱\",{\"1\":{\"145\":1}}],[\"这会生成从\",{\"1\":{\"72\":1}}],[\"这会对未使用的函数产生警告\",{\"1\":{\"39\":1}}],[\"这同样是一件糟糕的事情\",{\"1\":{\"68\":1}}],[\"这和对\",{\"1\":{\"233\":1}}],[\"这和\",{\"1\":{\"44\":1,\"132\":1}}],[\"这部分可以让你为项目添加依赖\",{\"1\":{\"44\":1}}],[\"这意味着变量的某些部分将被移动\",{\"1\":{\"282\":1}}],[\"这意味着所有函数都必须返回一个具体类型\",{\"1\":{\"184\":1}}],[\"这意味着已经没有所有者\",{\"1\":{\"149\":1}}],[\"这意味着\",{\"1\":{\"38\":1}}],[\"这意味着在使用它时保证正确性不再是编译器的责任\",{\"1\":{\"34\":1}}],[\"这已经在之前的章节介绍过了\",{\"1\":{\"32\":1}}],[\"这种写法比较罗嗦\",{\"1\":{\"310\":1}}],[\"这种做法就很有用了\",{\"1\":{\"285\":1}}],[\"这种做法会在错误处理中增加一些模板化的代码\",{\"1\":{\"213\":1}}],[\"这种隐式添加生命周期的过程称为省略\",{\"1\":{\"264\":1}}],[\"这种语法能够泛型地表示这些新类型\",{\"1\":{\"246\":1}}],[\"这种语言是完全合法的\",{\"1\":{\"112\":1}}],[\"这种模糊写法是不允许的\",{\"1\":{\"240\":1}}],[\"这种情况下禁止它返回这样的引用\",{\"1\":{\"268\":1}}],[\"这种情况下\",{\"1\":{\"235\":1}}],[\"这种情况下仍然会给出正确的答案\",{\"1\":{\"225\":1}}],[\"这种情况下就会提供一条更有用的错误信息\",{\"1\":{\"225\":2}}],[\"这种情况需要类型标注\",{\"1\":{\"30\":1}}],[\"这种情形下仍然会给出正确的答案\",{\"1\":{\"225\":1}}],[\"这种类型可以根据错误处理的实际情况定制\",{\"1\":{\"209\":1}}],[\"这种类型的主要优点是它可以被转换为任何其他类型\",{\"1\":{\"84\":1}}],[\"这种\",{\"1\":{\"187\":1,\"249\":1}}],[\"这种测试是小规模的\",{\"1\":{\"173\":1}}],[\"这种依赖要写在\",{\"1\":{\"168\":1}}],[\"这种行为避免了资源泄漏\",{\"1\":{\"141\":1}}],[\"这种行为可以通过\",{\"1\":{\"5\":1}}],[\"这门语言本身就提供了对编写软件测试的支持\",{\"1\":{\"28\":1}}],[\"这个模式去匹配\",{\"1\":{\"298\":1}}],[\"这个数目是由程序开头的静态常量决定的\",{\"1\":{\"294\":1}}],[\"这个过程比在内存中创建\",{\"1\":{\"290\":1}}],[\"这个结构体不能使用\",{\"1\":{\"254\":1}}],[\"这个结构通过\",{\"1\":{\"144\":1}}],[\"这个格式化的功能是通过\",{\"1\":{\"251\":1}}],[\"这个闭包使\",{\"1\":{\"235\":1}}],[\"这个闭包打印\",{\"1\":{\"235\":1}}],[\"这个组合算子可用于\",{\"1\":{\"217\":1}}],[\"这个简单的\",{\"1\":{\"183\":1}}],[\"这个属性就保证了你在测试的确实是所指定的\",{\"1\":{\"175\":1}}],[\"这个属性接受可选参数\",{\"1\":{\"175\":1}}],[\"这个断言会导致测试失败\",{\"1\":{\"174\":1}}],[\"这个加法函数写得很差\",{\"1\":{\"174\":1}}],[\"这个用来计算单精度复数的复变余弦\",{\"1\":{\"159\":1}}],[\"这个外部函数用于计算单精度复数的平方根\",{\"1\":{\"159\":1}}],[\"这个缩短的字符串是原字符串的一个切片\",{\"1\":{\"152\":1}}],[\"这个变量声明用来指定其值的地方\",{\"1\":{\"144\":1}}],[\"这个操作会导致解引用已释放的内存\",{\"1\":{\"140\":1}}],[\"这个可见性才会起作用\",{\"1\":{\"129\":1}}],[\"这个例子非常简单\",{\"1\":{\"112\":1}}],[\"这个虚类型结构体对\",{\"1\":{\"101\":1}}],[\"这个虚元组结构体对\",{\"1\":{\"101\":1}}],[\"这个说法实际上只在\",{\"1\":{\"87\":1}}],[\"这个方法会\",{\"1\":{\"86\":1}}],[\"这个方法要求调用者是可变的\",{\"1\":{\"86\":1}}],[\"这个函数与上面那个完全一致\",{\"1\":{\"225\":1}}],[\"这个函数会完成削皮切块烹饪一条龙\",{\"1\":{\"217\":1}}],[\"这个函数永远不会将控制内容返回给调用者\",{\"1\":{\"84\":1}}],[\"这个函数仅当目标系统是\",{\"1\":{\"36\":1}}],[\"这个类型无法实例化\",{\"1\":{\"84\":1}}],[\"这个意思\",{\"1\":{\"76\":1}}],[\"这个表达式也必须返回一个\",{\"1\":{\"75\":1}}],[\"这个表达式返回一个\",{\"1\":{\"75\":1}}],[\"这个\",{\"1\":{\"38\":1,\"89\":1,\"134\":1,\"159\":1,\"186\":1,\"187\":1,\"244\":1,\"246\":1,\"249\":1,\"254\":1,\"256\":1}}],[\"这个空元组\",{\"1\":{\"20\":1}}],[\"这个调用将会展开成\",{\"1\":{\"16\":1}}],[\"这些则把\",{\"1\":{\"296\":1}}],[\"这些内容将在后面的\",{\"1\":{\"256\":1}}],[\"这些内容在原生类型之外进行了有效扩充\",{\"1\":{\"26\":1}}],[\"这些函数只对实现了相应的\",{\"1\":{\"247\":1}}],[\"这些运算符可以根据它们的输入参数来完成不同的任务\",{\"1\":{\"187\":1}}],[\"这些\",{\"1\":{\"179\":1,\"238\":1}}],[\"这些测试仍然可以通过\",{\"1\":{\"170\":1}}],[\"这些部分\",{\"1\":{\"170\":1}}],[\"这些注释中的代码块也会被编译并且用作测试\",{\"1\":{\"170\":1}}],[\"这些依赖不会传播给其他依赖于这个包的包\",{\"1\":{\"168\":1}}],[\"这些线程由操作系统调度\",{\"1\":{\"167\":1}}],[\"这些命令会恰当地按需调用\",{\"1\":{\"117\":1}}],[\"这些命令将处理所有依赖\",{\"1\":{\"44\":1}}],[\"这些宏都以相同的做法解析文本\",{\"1\":{\"107\":1}}],[\"这些额外的参数没有存储值\",{\"1\":{\"101\":1}}],[\"这些方法通过关键字\",{\"1\":{\"86\":1}}],[\"这些方法将返回一个字符串\",{\"1\":{\"30\":1}}],[\"这些匿名函数\",{\"1\":{\"83\":1}}],[\"这些选项可以通过\",{\"1\":{\"68\":1}}],[\"这些标识符对语言有特定意义\",{\"1\":{\"40\":1}}],[\"这些主题包括\",{\"1\":{\"17\":1}}],[\"这些功能包括\",{\"1\":{\"2\":1}}],[\"这称为元编程\",{\"1\":{\"15\":1}}],[\"这是我们要处理的数据\",{\"1\":{\"293\":1}}],[\"这是任何\",{\"1\":{\"285\":1}}],[\"这是必须的\",{\"1\":{\"242\":1}}],[\"这是因为如果能以移动的方式捕获变量\",{\"1\":{\"240\":1}}],[\"这是完全相同的函数\",{\"1\":{\"185\":1}}],[\"这是最重要的指导原则之一\",{\"1\":{\"171\":1}}],[\"这是扩展了标准的\",{\"1\":{\"168\":1}}],[\"这是主\",{\"1\":{\"167\":1}}],[\"这是主函数\",{\"1\":{\"13\":1}}],[\"这是\",{\"1\":{\"163\":1,\"272\":1,\"293\":1,\"306\":1}}],[\"这是通过调用线程中所有对象的析构函数完成的\",{\"1\":{\"148\":1}}],[\"这是推荐方式\",{\"1\":{\"146\":1}}],[\"这是为了和被括号包含的字面量作区分\",{\"1\":{\"136\":1}}],[\"这是另外一种注释\",{\"1\":{\"105\":1}}],[\"这是行注释的例子\",{\"1\":{\"105\":1}}],[\"这是不同迭代方式的关键区别\",{\"1\":{\"73\":1}}],[\"这是部分自定义类型\",{\"1\":{\"24\":1}}],[\"这是一个封装\",{\"1\":{\"213\":1}}],[\"这是一个代码块\",{\"1\":{\"199\":1}}],[\"这是一个类型推导的进阶例子\",{\"1\":{\"194\":1}}],[\"这是一个三层的\",{\"1\":{\"151\":1}}],[\"这是一个实例方法\",{\"1\":{\"86\":1}}],[\"这是一个静态方法\",{\"1\":{\"86\":1}}],[\"这是一个空类型\",{\"1\":{\"84\":1}}],[\"这是一个简单的宏\",{\"1\":{\"16\":1}}],[\"这是一个表达式\",{\"1\":{\"10\":1}}],[\"这是注释内容\",{\"1\":{\"13\":1}}],[\"这是传统的\",{\"1\":{\"13\":1}}],[\"这里接受一个指向\",{\"1\":{\"270\":1}}],[\"这里也换成新类型\",{\"1\":{\"209\":1}}],[\"这里使用其完整路径\",{\"1\":{\"195\":1}}],[\"这里省略了标准的\",{\"1\":{\"168\":1}}],[\"这里并没有分配新的字符串\",{\"1\":{\"152\":1}}],[\"这里没有数值说明\",{\"1\":{\"144\":1}}],[\"这里没什么新东西\",{\"1\":{\"44\":1}}],[\"这里给出一个\",{\"1\":{\"118\":1}}],[\"这里给出一个例子\",{\"1\":{\"111\":1}}],[\"这里列出全部指示符\",{\"1\":{\"110\":1}}],[\"这里需要一个\",{\"1\":{\"103\":1}}],[\"这里我们实现\",{\"1\":{\"187\":2}}],[\"这里我们将它们绑定到引用\",{\"1\":{\"83\":1}}],[\"这里我们显式地在错误条件下调用\",{\"1\":{\"69\":1}}],[\"这里从\",{\"1\":{\"76\":1}}],[\"这里所有的礼物都使用\",{\"1\":{\"68\":1}}],[\"这里假设它在同一目录下\",{\"1\":{\"54\":1}}],[\"这里\",{\"1\":{\"41\":1,\"217\":1}}],[\"这里是\",{\"1\":{\"11\":1,\"186\":1}}],[\"这里的两个引用都必须比这个结构体长寿\",{\"1\":{\"277\":1}}],[\"这里的结构和之前一样\",{\"1\":{\"211\":1}}],[\"这里的所有都和\",{\"1\":{\"44\":1}}],[\"这里的语句将被运行\",{\"1\":{\"13\":1}}],[\"这里的\",{\"1\":{\"11\":2,\"101\":1,\"225\":1,\"268\":1}}],[\"这样各线程打印的内容不会交错在一起\",{\"1\":{\"293\":1}}],[\"这样做将导致变量的部分移动\",{\"1\":{\"282\":1}}],[\"这样做的坏处就是\",{\"1\":{\"207\":1}}],[\"这样会有某些后果吗\",{\"1\":{\"233\":1}}],[\"这样就可以对它们使用\",{\"1\":{\"244\":1}}],[\"这样就知道了\",{\"1\":{\"225\":1}}],[\"这样就不会产生无法预料的优先权错误\",{\"1\":{\"16\":1}}],[\"这样它可以决定回应错误的正确方式\",{\"1\":{\"225\":1}}],[\"这样它就可以使每个文档中的程序链接到库\",{\"1\":{\"118\":1}}],[\"这样更加灵活\",{\"1\":{\"217\":1}}],[\"这样多层串联调用就会变得混乱\",{\"1\":{\"215\":1}}],[\"这样其他错误可以包裹这个错误类型\",{\"1\":{\"209\":1}}],[\"这样出错时测试会\",{\"1\":{\"171\":1}}],[\"这样我们就不必每写\",{\"1\":{\"164\":1}}],[\"这样你就可以在字符串中写入各种各样的字符\",{\"1\":{\"153\":1}}],[\"这样当你从\",{\"1\":{\"137\":1}}],[\"这样意思就变了\",{\"1\":{\"103\":1}}],[\"这样的同步类型\",{\"1\":{\"293\":1}}],[\"这样的\",{\"1\":{\"246\":1}}],[\"这样的代码更好写\",{\"1\":{\"220\":1}}],[\"这样的简单映射\",{\"1\":{\"217\":1}}],[\"这样的运算\",{\"1\":{\"187\":2}}],[\"这样的函数\",{\"1\":{\"171\":1}}],[\"这样的泛型类型参数\",{\"1\":{\"91\":1}}],[\"这样的目录就没有父目录\",{\"1\":{\"7\":1}}],[\"这样集合本身不会被改变\",{\"1\":{\"73\":1}}],[\"这样可以用到之前的\",{\"1\":{\"60\":1}}],[\"这样\",{\"1\":{\"11\":1,\"87\":1,\"191\":1,\"266\":1}}],[\"这应当并不是一个错误\",{\"1\":{\"7\":1}}],[\"这元数据可以用来\",{\"1\":{\"1\":1}}],[\"它和\",{\"1\":{\"310\":1}}],[\"它像\",{\"1\":{\"298\":1}}],[\"它更改了赋值行为\",{\"1\":{\"298\":1}}],[\"它暴露了\",{\"1\":{\"291\":1}}],[\"它等同于这样一个匹配表达式\",{\"1\":{\"286\":1}}],[\"它保证了不会出现重复的元素\",{\"1\":{\"285\":1}}],[\"它保证其他部分的代码按照所希望的行为正常运行\",{\"1\":{\"174\":1}}],[\"它使借用者可以读\",{\"1\":{\"261\":1}}],[\"它表明所有的捕获都是通过值进行的\",{\"1\":{\"242\":1}}],[\"它表现为以下两个\",{\"1\":{\"68\":1}}],[\"它需要得到\",{\"1\":{\"235\":1}}],[\"它需要接受任意多的参数\",{\"1\":{\"16\":1}}],[\"它就会被\",{\"1\":{\"227\":1}}],[\"它就像是把所有的\",{\"1\":{\"211\":1}}],[\"它隐式地转换成了\",{\"1\":{\"213\":1}}],[\"它采用内部各类型对\",{\"1\":{\"213\":1}}],[\"它将自动转换成返回类型\",{\"1\":{\"211\":1}}],[\"它被限定只在一个代码块\",{\"1\":{\"199\":1}}],[\"它还会冻结\",{\"1\":{\"197\":1,\"260\":1}}],[\"它还会考察变量之后会怎样使用\",{\"1\":{\"194\":1}}],[\"它还会帮你测试注释文档中的代码\",{\"1\":{\"118\":1}}],[\"它不只是在初始化时看看右值\",{\"1\":{\"194\":1}}],[\"它没有实现\",{\"1\":{\"179\":2}}],[\"它实现了\",{\"1\":{\"178\":1}}],[\"它装包了一个文件描述符\",{\"1\":{\"163\":1}}],[\"它包裹了一个文件描述符\",{\"1\":{\"160\":1}}],[\"它\",{\"1\":{\"151\":1,\"291\":1}}],[\"它的签名如下\",{\"1\":{\"306\":1,\"308\":1}}],[\"它的作用是\",{\"1\":{\"225\":1}}],[\"它的栈\",{\"1\":{\"148\":1}}],[\"它的析构函数会被调用\",{\"1\":{\"145\":1}}],[\"它的析构函数\",{\"1\":{\"141\":1}}],[\"它只不过看起来像是另一种语言而已\",{\"1\":{\"112\":1}}],[\"它只重新构建尚未构建的内容\",{\"1\":{\"44\":1}}],[\"它允许我们将类型\",{\"1\":{\"107\":1}}],[\"它放在\",{\"1\":{\"103\":1}}],[\"它要求输入必须是\",{\"1\":{\"99\":1}}],[\"它要么举出元素t\",{\"1\":{\"70\":1}}],[\"它把年份\",{\"1\":{\"261\":1}}],[\"它把\",{\"1\":{\"93\":1}}],[\"它是通过使用以下\",{\"1\":{\"240\":1}}],[\"它是用于把对象和\",{\"1\":{\"187\":1}}],[\"它是用于\",{\"1\":{\"187\":1}}],[\"它是\",{\"1\":{\"87\":1,\"160\":1}}],[\"它与\",{\"1\":{\"84\":1}}],[\"它带有一个值\",{\"1\":{\"76\":1}}],[\"它并不是总能把字符串解析成指定的类型\",{\"1\":{\"70\":1}}],[\"它可以处理参数类型为未指定的情况\",{\"1\":{\"251\":1}}],[\"它可以接受一个\",{\"1\":{\"137\":1}}],[\"它可以不经改动就被赋给一个\",{\"1\":{\"55\":1}}],[\"它可接受类型为\",{\"1\":{\"11\":1}}],[\"它会在自身被\",{\"1\":{\"289\":1}}],[\"它会在整个程序运行的时期中存在\",{\"1\":{\"275\":1}}],[\"它会立即借用\",{\"1\":{\"235\":1}}],[\"它会被自动调用\",{\"1\":{\"213\":1}}],[\"它会把结果打印到控制台上\",{\"1\":{\"112\":1}}],[\"它会咬我们一口吗\",{\"1\":{\"70\":1}}],[\"它会打印一个错误消息\",{\"1\":{\"69\":1}}],[\"它会自动提供\",{\"1\":{\"50\":1}}],[\"它会创建一个切片\",{\"1\":{\"34\":1}}],[\"它导出一个名为\",{\"1\":{\"40\":1}}],[\"它却并不被认为是复合类型\",{\"1\":{\"20\":1}}],[\"它有很多非常有用的功能来提高代码质量和开发人员的开发效率\",{\"1\":{\"2\":1}}],[\"它们本身就是泛型\",{\"1\":{\"270\":1}}],[\"它们有不同的生命周期\",{\"1\":{\"266\":1}}],[\"它们都把数据保存在可执行文件的只读内存区\",{\"1\":{\"275\":1}}],[\"它们都要求有各自的实现\",{\"1\":{\"256\":1}}],[\"它们都会产生\",{\"1\":{\"153\":1}}],[\"它们都会产生类似的\",{\"1\":{\"153\":1}}],[\"它们都需要显式的类型声明\",{\"1\":{\"55\":1}}],[\"它们也占有资源\",{\"1\":{\"141\":1}}],[\"它们的大小在编译时是未知的\",{\"1\":{\"154\":1}}],[\"它们的优先级和类\",{\"1\":{\"135\":1}}],[\"它们的语法和能力使它们在临时\",{\"1\":{\"83\":1}}],[\"它们的语法为\",{\"1\":{\"1\":1}}],[\"它们使用\",{\"1\":{\"84\":1,\"118\":1}}],[\"它们多少有些区别\",{\"1\":{\"7\":1}}],[\"它们可以分开到多行中\",{\"1\":{\"1\":1}}],[\"包围的语句集合\",{\"1\":{\"199\":1}}],[\"包围起来\",{\"1\":{\"114\":1}}],[\"包裹的值来调用其输入函数并返回结果\",{\"1\":{\"215\":1}}],[\"包裹\",{\"1\":{\"186\":1}}],[\"包裹错误\",{\"0\":{\"213\":1},\"1\":{\"0\":1}}],[\"包含一个指向泛型类型\",{\"1\":{\"270\":1}}],[\"包含一个指针的可变元组\",{\"1\":{\"263\":1}}],[\"包含一个\",{\"1\":{\"256\":1}}],[\"包含链表的一个元素和一个指向下一节点的指针\",{\"1\":{\"205\":1}}],[\"包含测试的文件\",{\"1\":{\"173\":2}}],[\"包含各种不同类型的元组\",{\"1\":{\"136\":1}}],[\"包含多种\",{\"1\":{\"107\":1}}],[\"包含此值\",{\"1\":{\"72\":1}}],[\"包括其资源\",{\"1\":{\"178\":1}}],[\"包括嵌套模块内的\",{\"1\":{\"133\":1}}],[\"包括文档测试\",{\"1\":{\"117\":1}}],[\"包括全局作用域\",{\"1\":{\"55\":1}}],[\"包括子目录\",{\"1\":{\"44\":1}}],[\"包括\",{\"1\":{\"19\":1,\"44\":1,\"107\":1}}],[\"包括双语版\",{\"1\":{\"15\":1}}],[\"包括在上面定义的具体类型\",{\"1\":{\"11\":1}}],[\"包装箱\",{\"1\":{\"5\":1}}],[\"包\",{\"1\":{\"5\":1,\"44\":1}}],[\"包注册服务\",{\"1\":{\"2\":1,\"44\":1}}],[\"包管理工具的一些基本功能\",{\"1\":{\"15\":1}}],[\"包管理工具\",{\"1\":{\"2\":1}}],[\"voluptate\",{\"1\":{\"288\":2}}],[\"void\",{\"1\":{\"68\":2}}],[\"v3\",{\"1\":{\"185\":6}}],[\"v2\",{\"1\":{\"185\":2,\"215\":3}}],[\"v1\",{\"1\":{\"185\":2,\"215\":1}}],[\"v>\",{\"1\":{\"146\":1}}],[\"v\",{\"1\":{\"141\":1,\"148\":1,\"185\":4,\"296\":2,\"310\":4}}],[\"violets\",{\"1\":{\"201\":1}}],[\"visibility\",{\"1\":{\"133\":1}}],[\"vis\",{\"1\":{\"110\":1}}],[\"via\",{\"1\":{\"42\":1,\"298\":2}}],[\"v0\",{\"1\":{\"45\":2}}],[\"velit\",{\"1\":{\"288\":2}}],[\"veniam\",{\"1\":{\"288\":2}}],[\"ve\",{\"1\":{\"184\":1}}],[\"verb=\",{\"1\":{\"107\":1}}],[\"verb\",{\"1\":{\"107\":1}}],[\"veryverboseenumofthingstodowithnumbers\",{\"1\":{\"58\":4}}],[\"versioning\",{\"1\":{\"44\":1}}],[\"version\",{\"1\":{\"44\":3,\"166\":1}}],[\"vec2\",{\"1\":{\"306\":3,\"308\":4}}],[\"vec1\",{\"1\":{\"306\":3,\"308\":4}}],[\"vecs\",{\"1\":{\"185\":3}}],[\"vec<number>\",{\"1\":{\"256\":1}}],[\"vec<path>\",{\"1\":{\"256\":1}}],[\"vec<string>\",{\"1\":{\"156\":1,\"287\":1}}],[\"vec<i32>\",{\"1\":{\"154\":1,\"185\":5,\"310\":1}}],[\"vec<char>\",{\"1\":{\"152\":1}}],[\"vec<u8>\",{\"1\":{\"152\":1,\"164\":1}}],[\"vec<t>\",{\"1\":{\"111\":3,\"152\":1,\"256\":2,\"284\":1}}],[\"vec<result<t\",{\"1\":{\"65\":1}}],[\"vec<\",{\"1\":{\"63\":1,\"64\":1,\"66\":6,\"67\":1,\"111\":3,\"207\":1,\"209\":1,\"210\":2,\"211\":1,\"213\":1}}],[\"vec\",{\"1\":{\"34\":1,\"63\":1,\"64\":1,\"65\":1,\"66\":2,\"67\":6,\"73\":3,\"89\":1,\"97\":3,\"103\":3,\"154\":3,\"158\":1,\"167\":1,\"183\":1,\"185\":3,\"194\":4,\"207\":5,\"209\":5,\"210\":10,\"211\":5,\"213\":5,\"235\":2,\"285\":3,\"293\":2,\"306\":4,\"308\":2,\"310\":4,\"312\":1}}],[\"vectors\",{\"1\":{\"295\":1}}],[\"vector\",{\"0\":{\"154\":1},\"1\":{\"0\":1,\"24\":1,\"34\":4,\"67\":1,\"146\":2,\"152\":2,\"154\":17,\"164\":1,\"167\":1,\"194\":1,\"209\":1,\"210\":1,\"213\":1,\"311\":1}}],[\"vancouver\",{\"1\":{\"251\":1}}],[\"val`\",{\"1\":{\"195\":1,\"298\":3}}],[\"valid\",{\"1\":{\"164\":1}}],[\"valgrind\",{\"1\":{\"141\":3,\"148\":2}}],[\"val\",{\"1\":{\"83\":1,\"95\":10,\"112\":2,\"116\":2,\"134\":1,\"145\":6,\"195\":7,\"298\":4}}],[\"value`\",{\"1\":{\"298\":2}}],[\"value5\",{\"1\":{\"1\":1}}],[\"value4\",{\"1\":{\"1\":1}}],[\"value3\",{\"1\":{\"1\":1}}],[\"value2\",{\"1\":{\"1\":2}}],[\"value\",{\"1\":{\"1\":5,\"35\":1,\"47\":2,\"48\":2,\"52\":3,\"76\":2,\"95\":4,\"136\":2,\"146\":2,\"147\":2,\"149\":2,\"151\":3,\"154\":1,\"194\":1,\"195\":1,\"285\":1,\"286\":2,\"296\":1,\"298\":7,\"310\":2}}],[\"variables\",{\"1\":{\"42\":1}}],[\"variable\",{\"0\":{\"335\":1},\"1\":{\"35\":2,\"199\":1}}],[\"variadic\",{\"1\":{\"16\":1}}],[\"=19\",{\"1\":{\"79\":1}}],[\"=100\",{\"1\":{\"72\":1}}],[\"=b表示两端都包含在内的范围\",{\"1\":{\"72\":1}}],[\"=>\",{\"1\":{\"16\":1,\"57\":5,\"58\":2,\"68\":3,\"73\":6,\"76\":2,\"79\":6,\"81\":2,\"84\":2,\"110\":2,\"111\":3,\"112\":1,\"113\":2,\"114\":2,\"116\":2,\"146\":7,\"147\":2,\"151\":6,\"153\":2,\"161\":10,\"164\":2,\"203\":4,\"205\":4,\"207\":2,\"209\":2,\"211\":2,\"213\":6,\"215\":10,\"217\":6,\"220\":6,\"221\":2,\"222\":2,\"223\":2,\"225\":8,\"228\":7,\"231\":4,\"284\":2,\"286\":5,\"287\":11,\"288\":4,\"289\":4,\"291\":6,\"296\":8,\"298\":4,\"300\":6,\"304\":3}}],[\"=n\",{\"1\":{\"10\":1}}],[\"==4401==\",{\"1\":{\"148\":14}}],[\"==26873==\",{\"1\":{\"141\":14}}],[\"===\",{\"1\":{\"86\":1,\"151\":1}}],[\"==\",{\"1\":{\"10\":2,\"33\":1,\"52\":1,\"68\":1,\"69\":1,\"72\":6,\"76\":1,\"78\":2,\"80\":3,\"84\":1,\"85\":1,\"101\":4,\"111\":1,\"113\":2,\"147\":1,\"148\":1,\"151\":1,\"170\":1,\"171\":1,\"174\":1,\"175\":1,\"179\":1,\"227\":1,\"231\":3,\"244\":2,\"246\":2,\"263\":1,\"286\":1,\"306\":4,\"308\":4}}],[\"=\",{\"1\":{\"1\":2,\"8\":6,\"11\":5,\"21\":11,\"30\":2,\"33\":1,\"34\":4,\"35\":6,\"36\":3,\"38\":2,\"41\":1,\"44\":12,\"47\":3,\"48\":2,\"50\":2,\"51\":3,\"52\":3,\"55\":4,\"57\":5,\"58\":2,\"60\":10,\"63\":2,\"64\":2,\"65\":2,\"66\":6,\"67\":4,\"68\":6,\"70\":4,\"73\":4,\"75\":2,\"76\":15,\"78\":1,\"79\":3,\"80\":1,\"81\":7,\"83\":4,\"84\":4,\"85\":4,\"86\":9,\"89\":3,\"93\":2,\"95\":2,\"97\":3,\"99\":2,\"101\":4,\"103\":1,\"105\":2,\"107\":2,\"108\":1,\"110\":2,\"111\":9,\"112\":4,\"116\":5,\"118\":3,\"129\":3,\"134\":2,\"135\":2,\"136\":8,\"138\":3,\"139\":3,\"140\":5,\"141\":3,\"142\":1,\"144\":2,\"145\":6,\"146\":1,\"147\":4,\"148\":1,\"149\":3,\"151\":1,\"152\":7,\"153\":14,\"154\":3,\"156\":1,\"158\":4,\"159\":5,\"161\":6,\"164\":3,\"166\":3,\"167\":3,\"168\":1,\"170\":2,\"171\":1,\"175\":2,\"178\":5,\"179\":6,\"181\":3,\"183\":4,\"184\":2,\"185\":6,\"186\":6,\"187\":6,\"191\":9,\"193\":6,\"194\":2,\"195\":5,\"196\":3,\"197\":4,\"198\":2,\"199\":4,\"201\":3,\"203\":2,\"205\":4,\"207\":4,\"209\":4,\"210\":7,\"211\":6,\"213\":6,\"215\":1,\"217\":6,\"219\":2,\"220\":2,\"221\":2,\"222\":2,\"223\":1,\"225\":5,\"227\":2,\"228\":4,\"231\":1,\"233\":2,\"235\":12,\"238\":1,\"240\":4,\"242\":6,\"244\":3,\"246\":5,\"247\":3,\"249\":13,\"251\":2,\"254\":3,\"256\":6,\"259\":10,\"260\":4,\"261\":3,\"263\":12,\"264\":1,\"266\":3,\"268\":4,\"270\":2,\"272\":2,\"273\":1,\"275\":4,\"277\":6,\"279\":1,\"281\":4,\"282\":2,\"284\":5,\"285\":2,\"286\":3,\"287\":4,\"288\":4,\"289\":4,\"290\":3,\"291\":3,\"292\":2,\"293\":7,\"296\":1,\"298\":5,\"300\":13,\"302\":11,\"304\":1,\"306\":4,\"308\":6,\"310\":3}}],[\"注意下面的说明\",{\"1\":{\"270\":1}}],[\"注意使用了\",{\"1\":{\"246\":1}}],[\"注意反过来就不再成立\",{\"1\":{\"240\":1}}],[\"注意在上一个例子中\",{\"1\":{\"211\":1}}],[\"注意在实际程序中\",{\"1\":{\"39\":1}}],[\"注意我们没有储存关于错误的任何额外信息\",{\"1\":{\"209\":1}}],[\"注意类型别名\",{\"1\":{\"191\":1}}],[\"注意私有的函数也可以被测试\",{\"1\":{\"174\":1}}],[\"注意这里没有用完整路径\",{\"1\":{\"203\":1}}],[\"注意这并不是一个\",{\"1\":{\"153\":1}}],[\"注意这个惯用法\",{\"1\":{\"174\":1}}],[\"注意这个\",{\"1\":{\"84\":1}}],[\"注意并非所有变量都拥有资源\",{\"1\":{\"140\":1}}],[\"注意到\",{\"1\":{\"284\":1,\"293\":1}}],[\"注意到这里没有用到名称或类型来标注生命周期\",{\"1\":{\"139\":1}}],[\"注意到并且显式地处理这种错误可以避免程序的其他部分产生潜在的问题\",{\"1\":{\"7\":1}}],[\"注意有两个斜线在本行的开头\",{\"1\":{\"105\":1}}],[\"注意第一个参数\",{\"1\":{\"86\":1}}],[\"注意变量名和类型共同指定了\",{\"1\":{\"57\":1}}],[\"注意\",{\"1\":{\"21\":1,\"73\":1,\"84\":1,\"101\":1,\"105\":1,\"164\":1,\"246\":1,\"256\":1,\"279\":1,\"306\":1,\"308\":1}}],[\"注意少了感叹号\",{\"1\":{\"1\":1}}],[\"注释内容一直到结束分隔符\",{\"1\":{\"105\":1}}],[\"注释内容直到行尾\",{\"1\":{\"105\":1}}],[\"注释对任何程序都不可缺少\",{\"1\":{\"105\":1}}],[\"注释掉上面这行\",{\"1\":{\"197\":1}}],[\"注释掉\",{\"1\":{\"194\":1}}],[\"注释掉这行\",{\"1\":{\"199\":1}}],[\"注释掉这一行\",{\"1\":{\"193\":1}}],[\"注释掉这个总括性的分支\",{\"1\":{\"79\":1}}],[\"注释掉此行代码\",{\"1\":{\"149\":1}}],[\"注释掉此行\",{\"1\":{\"55\":1,\"107\":1,\"138\":1,\"154\":1,\"196\":1,\"260\":1,\"261\":1}}],[\"注释\",{\"0\":{\"105\":1},\"1\":{\"0\":1}}],[\"当其中任一元素满足谓词\",{\"1\":{\"306\":1}}],[\"当某状态对某线程是可见的\",{\"1\":{\"293\":1}}],[\"当成这样一个\",{\"1\":{\"285\":1}}],[\"当所有权转移时\",{\"1\":{\"281\":1}}],[\"当数据被不可变地借用时\",{\"1\":{\"260\":1}}],[\"当数据被相同的名称不变地绑定时\",{\"1\":{\"197\":1}}],[\"当以闭包作为输入参数时\",{\"1\":{\"240\":1}}],[\"当闭包被定义\",{\"1\":{\"233\":1}}],[\"当我们要重用某个\",{\"1\":{\"223\":1}}],[\"当找到一个\",{\"1\":{\"221\":1}}],[\"当只是需要\",{\"1\":{\"220\":1}}],[\"当转换到有符号类型时\",{\"1\":{\"193\":1}}],[\"当把任何类型转换为无符号类型\",{\"1\":{\"193\":1}}],[\"当对象离开作用域时会自动调用该方法\",{\"1\":{\"183\":1}}],[\"当处理资源时\",{\"1\":{\"178\":1}}],[\"当处理option\",{\"1\":{\"7\":1}}],[\"当测试函数中有什么东西\",{\"1\":{\"174\":1}}],[\"当需要同步处理时\",{\"1\":{\"293\":1}}],[\"当需要超过这个阈值时\",{\"1\":{\"154\":1}}],[\"当需要多个所有权时\",{\"1\":{\"149\":1}}],[\"当箱子离开作用域时\",{\"1\":{\"145\":1}}],[\"当线程之间所有权需要共享时\",{\"1\":{\"144\":1}}],[\"当资源离开作用域\",{\"1\":{\"142\":1}}],[\"当存在引用指向一个对象时\",{\"1\":{\"138\":1}}],[\"当运行\",{\"1\":{\"118\":1}}],[\"当使用\",{\"1\":{\"103\":1}}],[\"当分别指定泛型的类型和约束会更清晰时\",{\"1\":{\"103\":1}}],[\"当解构失败时退出循环\",{\"1\":{\"81\":1}}],[\"当条件满足时循环\",{\"1\":{\"80\":1}}],[\"当公主收到蛇这件不合适的礼物时\",{\"1\":{\"68\":1}}],[\"当你看着这些结果时\",{\"1\":{\"66\":1}}],[\"当枚举的名称太长或者太一般化\",{\"1\":{\"58\":1}}],[\"当然这个用处不大\",{\"1\":{\"284\":1}}],[\"当然如果数值已经在目标类型的范围内\",{\"1\":{\"193\":1}}],[\"当然我们可以使用\",{\"1\":{\"141\":1}}],[\"当然是有限制的\",{\"1\":{\"112\":1}}],[\"当然\",{\"1\":{\"44\":1,\"93\":1}}],[\"当\",{\"1\":{\"40\":1,\"80\":1,\"81\":1,\"87\":1,\"138\":1,\"142\":1,\"149\":1,\"186\":1,\"275\":1}}],[\"当用到\",{\"1\":{\"38\":1}}],[\"当作参数的用法就是类型参数\",{\"1\":{\"11\":1}}],[\"当函数返回\",{\"1\":{\"10\":1}}],[\"当错误有可能发生\",{\"1\":{\"7\":1}}],[\"当调用\",{\"1\":{\"5\":1}}],[\"当它们用于模块或项时\",{\"1\":{\"1\":1}}],[\"当属性作用于整个\",{\"1\":{\"1\":1}}],[\"时它将返回\",{\"1\":{\"306\":1}}],[\"时关闭文件\",{\"1\":{\"289\":1}}],[\"时的消息\",{\"1\":{\"175\":1}}],[\"时的作者列表\",{\"1\":{\"44\":1}}],[\"时最常使用的\",{\"1\":{\"119\":1}}],[\"时循环\",{\"1\":{\"80\":1}}],[\"时将返回\",{\"1\":{\"68\":1}}],[\"时才会编译\",{\"1\":{\"36\":1}}],[\"时\",{\"1\":{\"1\":1,\"4\":1,\"5\":1,\"7\":1,\"10\":1,\"11\":1,\"38\":1,\"70\":1,\"81\":1,\"137\":1,\"149\":2,\"193\":1,\"213\":2,\"220\":1,\"221\":1}}],[\"标注生命周期\",{\"1\":{\"273\":1,\"279\":1}}],[\"标签\",{\"1\":{\"226\":1}}],[\"标准错误\",{\"1\":{\"291\":1}}],[\"标准输入\",{\"1\":{\"291\":1}}],[\"标准输出\",{\"1\":{\"42\":1,\"291\":1}}],[\"标准库也并不擅自规定一种样式\",{\"1\":{\"256\":1}}],[\"标准库也提供了很多其他类型来支持某些功能\",{\"1\":{\"26\":1}}],[\"标准库的\",{\"1\":{\"207\":1}}],[\"标准库文档也是用它生成的\",{\"1\":{\"122\":1}}],[\"标准库中的\",{\"1\":{\"247\":1}}],[\"标准库中已经给无数种类型实现了\",{\"1\":{\"51\":1}}],[\"标准库中文版\",{\"1\":{\"15\":1}}],[\"标准库\",{\"0\":{\"156\":1},\"1\":{\"25\":1}}],[\"标准库提供了开箱即用的线程类型\",{\"1\":{\"293\":1}}],[\"标准库提供了很多自定义类型\",{\"1\":{\"24\":1}}],[\"标准库提供的一些自定义类型\",{\"1\":{\"15\":1}}],[\"标准库更多介绍\",{\"0\":{\"26\":1},\"1\":{\"0\":1,\"15\":1}}],[\"标准库类型\",{\"0\":{\"24\":1},\"1\":{\"0\":1,\"15\":1,\"27\":1}}],[\"标记会发生什么\",{\"1\":{\"200\":1}}],[\"标记来传给\",{\"1\":{\"200\":1}}],[\"标记树\",{\"1\":{\"111\":1}}],[\"标记树token\",{\"1\":{\"110\":1}}],[\"标记\",{\"1\":{\"38\":1,\"84\":1,\"107\":2,\"118\":1,\"161\":1,\"200\":1,\"256\":2}}],[\"标记函数作为基准测试的某个部分\",{\"1\":{\"1\":1}}],[\"标记函数作为单元测试\",{\"1\":{\"1\":1}}],[\"标量类型\",{\"0\":{\"20\":1}}],[\"语句导致了更加繁琐的代码\",{\"1\":{\"225\":1}}],[\"语句和提前返回\",{\"1\":{\"220\":1}}],[\"语句来解开\",{\"1\":{\"219\":1}}],[\"语句来提前返一个值\",{\"1\":{\"10\":1}}],[\"语句给已有的类型取个新的名字\",{\"1\":{\"191\":1}}],[\"语句statement\",{\"1\":{\"110\":1}}],[\"语句在任何时候退出一个循环\",{\"1\":{\"78\":1}}],[\"语句块\",{\"1\":{\"76\":1}}],[\"语句\",{\"1\":{\"8\":3,\"215\":1,\"219\":1,\"226\":1}}],[\"语言风格的枚举类型那样使用\",{\"1\":{\"201\":1}}],[\"语言风格结构体\",{\"1\":{\"60\":1}}],[\"语言库的外部语言函数接口\",{\"1\":{\"159\":1}}],[\"语言包括\",{\"1\":{\"135\":1}}],[\"语言类似\",{\"1\":{\"135\":1}}],[\"语言\",{\"1\":{\"112\":1}}],[\"语言参考\",{\"1\":{\"83\":1}}],[\"语言中的布尔判断条件不必使用小括号包裹\",{\"1\":{\"75\":1}}],[\"语言中的这部分内容\",{\"1\":{\"9\":1}}],[\"语言的惯例\",{\"1\":{\"193\":1}}],[\"语言的\",{\"1\":{\"79\":1}}],[\"语言的各种测试手段\",{\"1\":{\"15\":1}}],[\"语言的库\",{\"1\":{\"1\":1}}],[\"语言处理失败的方式\",{\"1\":{\"15\":1}}],[\"语言正在快速发展\",{\"1\":{\"3\":1}}],[\"语法表示该闭包\",{\"1\":{\"293\":1}}],[\"语法如下\",{\"1\":{\"266\":1}}],[\"语法索引\",{\"1\":{\"188\":1}}],[\"语法之前\",{\"1\":{\"185\":1}}],[\"语法书写\",{\"1\":{\"170\":1}}],[\"语法定义的函数只在父模块中可见\",{\"1\":{\"133\":1}}],[\"语法定义的函数只在给定的路径中可见\",{\"1\":{\"133\":1}}],[\"语法定义的函数则只在当前模块中可见\",{\"1\":{\"133\":1}}],[\"语法树\",{\"1\":{\"112\":1}}],[\"语法为\",{\"1\":{\"1\":1}}],[\"语法\",{\"0\":{\"115\":1},\"1\":{\"0\":1,\"16\":1,\"51\":1}}],[\"链接在一起\",{\"1\":{\"219\":1}}],[\"链接到上节新建的库\",{\"1\":{\"54\":1}}],[\"链接到一个非\",{\"1\":{\"1\":1}}],[\"链表\",{\"0\":{\"205\":1},\"1\":{\"0\":1}}],[\"等于\",{\"1\":{\"228\":1}}],[\"等等\",{\"1\":{\"191\":1,\"288\":1,\"289\":1}}],[\"等语言\",{\"1\":{\"135\":1}}],[\"等同于\",{\"1\":{\"135\":2}}],[\"等价于\",{\"1\":{\"203\":2}}],[\"等价\",{\"1\":{\"132\":1}}],[\"等函数\",{\"1\":{\"111\":1}}],[\"等运算符\",{\"1\":{\"111\":1}}],[\"等看完这一节再回头看这个定义就很明白了\",{\"1\":{\"87\":1}}],[\"等\",{\"1\":{\"1\":1,\"9\":1}}],[\"等待线程结束\",{\"1\":{\"167\":1}}],[\"等待\",{\"0\":{\"292\":1},\"1\":{\"0\":1}}],[\"宏完成的\",{\"1\":{\"222\":1}}],[\"宏的一个\",{\"1\":{\"168\":1}}],[\"宏的参数使用一个美元符号\",{\"1\":{\"110\":1}}],[\"宏可用来初始化一个\",{\"1\":{\"154\":1}}],[\"宏可用于产生一个\",{\"1\":{\"148\":1}}],[\"宏可以重载\",{\"1\":{\"113\":1}}],[\"宏可以让你写出\",{\"1\":{\"111\":1}}],[\"宏改写成可变参数接口\",{\"1\":{\"116\":1}}],[\"宏定义的最后一个分支可以不用分号作为结束\",{\"1\":{\"114\":1}}],[\"宏在参数列表中可以使用\",{\"1\":{\"114\":1}}],[\"宏把\",{\"1\":{\"110\":1}}],[\"宏允许你为特定的目的创造特定的\",{\"1\":{\"16\":1}}],[\"宏来创建的\",{\"1\":{\"16\":1}}],[\"宏是通过\",{\"1\":{\"16\":1}}],[\"宏是一种编写代码来编写其他代码的方法\",{\"1\":{\"15\":1}}],[\"宏并不产生函数调用\",{\"1\":{\"16\":1}}],[\"宏看起来和函数很像\",{\"1\":{\"16\":1}}],[\"宏\",{\"0\":{\"222\":1},\"1\":{\"1\":1,\"15\":1,\"36\":1,\"37\":1,\"108\":1,\"310\":1}}],[\"警告\",{\"1\":{\"1\":1}}],[\"禁用对未使用模块发出警告的\",{\"1\":{\"107\":1}}],[\"禁用\",{\"1\":{\"1\":1}}],[\"mkdir\",{\"1\":{\"288\":1}}],[\"mm\",{\"1\":{\"249\":2}}],[\"mmm\",{\"1\":{\"217\":1}}],[\"msb\",{\"1\":{\"193\":3}}],[\"mpsc\",{\"1\":{\"158\":3}}],[\"mr\",{\"1\":{\"146\":1}}],[\"mdbook\",{\"1\":{\"125\":2}}],[\"misc\",{\"0\":{\"331\":1}}],[\"mismatch\",{\"1\":{\"111\":1}}],[\"middle\",{\"1\":{\"300\":3}}],[\"million\",{\"1\":{\"135\":1}}],[\"minim\",{\"1\":{\"288\":2}}],[\"minmax\",{\"1\":{\"256\":8}}],[\"min\",{\"1\":{\"114\":7}}],[\"mollit\",{\"1\":{\"288\":2}}],[\"months\",{\"1\":{\"254\":1}}],[\"monday\",{\"1\":{\"215\":2}}],[\"money\",{\"1\":{\"203\":2}}],[\"most\",{\"1\":{\"193\":1}}],[\"moooooo\",{\"1\":{\"184\":1}}],[\"movable\",{\"1\":{\"235\":3}}],[\"moving\",{\"1\":{\"167\":1}}],[\"moved\",{\"1\":{\"178\":5,\"235\":1}}],[\"move\",{\"0\":{\"350\":1},\"1\":{\"73\":1,\"140\":1,\"144\":1,\"158\":1,\"167\":1,\"178\":2,\"179\":1,\"185\":1,\"235\":4,\"242\":4,\"282\":2,\"293\":5}}],[\"mode\",{\"1\":{\"288\":2,\"289\":1}}],[\"mod`\",{\"1\":{\"133\":2}}],[\"module\",{\"1\":{\"18\":1,\"133\":2,\"195\":1}}],[\"mod\",{\"0\":{\"327\":1},\"1\":{\"5\":1,\"111\":1,\"120\":1,\"128\":6,\"129\":1,\"131\":3,\"132\":2,\"133\":35,\"151\":1,\"168\":1,\"173\":2,\"174\":1,\"175\":1,\"177\":1,\"193\":1,\"286\":1}}],[\"multi\",{\"1\":{\"268\":1}}],[\"multi`\",{\"1\":{\"268\":1}}],[\"multi<\",{\"1\":{\"268\":1}}],[\"multiple\",{\"0\":{\"338\":1},\"1\":{\"97\":1,\"153\":1,\"181\":1}}],[\"multiply<\",{\"1\":{\"272\":1}}],[\"multiply\",{\"1\":{\"70\":3,\"220\":3,\"221\":3,\"222\":4,\"223\":3,\"225\":7,\"272\":1}}],[\"mul\",{\"1\":{\"111\":6}}],[\"mutex\",{\"1\":{\"293\":1}}],[\"mutabook\",{\"1\":{\"261\":3}}],[\"mutably\",{\"1\":{\"73\":1,\"261\":1}}],[\"mutable\",{\"1\":{\"21\":6,\"197\":9,\"198\":4,\"259\":8,\"260\":7,\"261\":1,\"263\":8,\"281\":6}}],[\"mutation\",{\"1\":{\"198\":2}}],[\"mut`\",{\"1\":{\"154\":1,\"235\":1,\"298\":2}}],[\"mut\",{\"1\":{\"21\":2,\"22\":1,\"30\":2,\"50\":1,\"55\":1,\"73\":5,\"78\":1,\"80\":1,\"81\":2,\"84\":1,\"85\":1,\"86\":4,\"111\":4,\"142\":1,\"146\":1,\"152\":2,\"154\":2,\"158\":1,\"159\":1,\"161\":7,\"167\":1,\"183\":1,\"185\":1,\"186\":2,\"194\":1,\"197\":1,\"198\":2,\"205\":1,\"207\":1,\"209\":1,\"211\":1,\"213\":1,\"227\":1,\"235\":7,\"240\":5,\"242\":3,\"251\":1,\"256\":3,\"259\":3,\"260\":1,\"261\":5,\"263\":6,\"268\":3,\"273\":2,\"281\":1,\"284\":1,\"285\":2,\"288\":1,\"289\":3,\"291\":2,\"292\":1,\"293\":2,\"298\":5,\"306\":3,\"308\":4,\"310\":1}}],[\"me<f\",{\"1\":{\"238\":1}}],[\"means\",{\"1\":{\"153\":1}}],[\"measured\",{\"1\":{\"45\":2,\"111\":1,\"170\":2,\"173\":3,\"174\":1,\"175\":2,\"176\":4,\"177\":4}}],[\"memcheck\",{\"1\":{\"141\":1,\"148\":1}}],[\"memory\",{\"1\":{\"141\":2,\"148\":1,\"275\":1}}],[\"mem\",{\"1\":{\"121\":1,\"134\":2,\"145\":7,\"178\":1,\"195\":8,\"235\":2,\"236\":1,\"240\":2,\"241\":1}}],[\"met\",{\"1\":{\"200\":2}}],[\"meters\",{\"1\":{\"249\":2}}],[\"meter`\",{\"1\":{\"249\":2}}],[\"meter\",{\"1\":{\"179\":3,\"249\":6}}],[\"method\",{\"1\":{\"86\":3}}],[\"meta\",{\"0\":{\"326\":1}}],[\"metaprogramming\",{\"1\":{\"15\":1,\"16\":1}}],[\"metadata\",{\"1\":{\"1\":1,\"15\":1,\"164\":1,\"165\":1}}],[\"me\",{\"1\":{\"79\":1,\"228\":1,\"231\":1,\"238\":2,\"304\":1}}],[\"meet\",{\"1\":{\"35\":1}}],[\"mytrait\",{\"1\":{\"185\":2}}],[\"mytrait<a\",{\"1\":{\"103\":2}}],[\"my\",{\"1\":{\"34\":2,\"43\":3,\"45\":2,\"47\":4,\"48\":1,\"57\":1,\"107\":1,\"128\":8,\"129\":4,\"131\":2,\"133\":20,\"146\":1,\"153\":4,\"156\":2,\"189\":3,\"228\":1,\"287\":1}}],[\"m\",{\"1\":{\"14\":1,\"68\":1,\"153\":1,\"159\":1,\"228\":3,\"238\":2,\"275\":1,\"296\":4,\"298\":3}}],[\"magenta\",{\"1\":{\"296\":2}}],[\"magna\",{\"1\":{\"288\":2}}],[\"max\",{\"1\":{\"193\":1}}],[\"made\",{\"1\":{\"142\":1}}],[\"matter\",{\"1\":{\"304\":2}}],[\"mathresult\",{\"1\":{\"151\":4,\"286\":5}}],[\"matherror>\",{\"1\":{\"151\":1,\"286\":1}}],[\"matherror\",{\"1\":{\"151\":4,\"286\":7}}],[\"matrix\",{\"1\":{\"136\":4,\"137\":7}}],[\"match卫语句\",{\"1\":{\"231\":1}}],[\"matches\",{\"1\":{\"152\":1}}],[\"matched\",{\"1\":{\"76\":3}}],[\"match\",{\"0\":{\"79\":1,\"342\":1},\"1\":{\"0\":1,\"57\":1,\"58\":1,\"59\":1,\"68\":2,\"73\":4,\"76\":4,\"79\":5,\"81\":2,\"84\":3,\"113\":1,\"146\":3,\"147\":1,\"151\":4,\"153\":1,\"161\":5,\"164\":1,\"203\":2,\"204\":1,\"205\":3,\"207\":1,\"209\":1,\"211\":1,\"213\":3,\"215\":6,\"217\":4,\"219\":1,\"220\":3,\"221\":1,\"222\":1,\"223\":1,\"225\":5,\"228\":4,\"230\":1,\"231\":1,\"284\":1,\"286\":3,\"287\":16,\"288\":2,\"289\":2,\"291\":3,\"296\":1,\"298\":4,\"300\":1,\"304\":3}}],[\"make\",{\"1\":{\"44\":1,\"185\":2}}],[\"markdown\",{\"1\":{\"118\":1,\"170\":1}}],[\"marker\",{\"1\":{\"101\":1,\"249\":1}}],[\"mark\",{\"1\":{\"44\":2}}],[\"main`\",{\"1\":{\"171\":2}}],[\"main\",{\"1\":{\"8\":3,\"10\":1,\"11\":1,\"13\":1,\"16\":1,\"21\":1,\"30\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"39\":1,\"40\":3,\"43\":3,\"44\":3,\"45\":1,\"47\":1,\"48\":1,\"50\":2,\"51\":1,\"52\":1,\"54\":1,\"55\":2,\"57\":1,\"58\":1,\"60\":1,\"63\":1,\"64\":1,\"65\":1,\"66\":2,\"67\":1,\"68\":1,\"69\":1,\"70\":1,\"72\":2,\"73\":3,\"75\":1,\"76\":3,\"78\":1,\"79\":1,\"80\":1,\"81\":1,\"83\":1,\"84\":3,\"85\":1,\"86\":1,\"89\":1,\"91\":1,\"93\":1,\"95\":1,\"97\":1,\"99\":1,\"101\":1,\"103\":1,\"105\":2,\"107\":1,\"110\":1,\"112\":1,\"113\":1,\"114\":1,\"116\":1,\"118\":1,\"125\":1,\"128\":1,\"129\":1,\"131\":1,\"132\":1,\"133\":1,\"134\":1,\"135\":1,\"136\":1,\"138\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":2,\"144\":1,\"145\":1,\"146\":1,\"147\":1,\"148\":1,\"149\":1,\"151\":1,\"152\":1,\"153\":3,\"154\":1,\"156\":1,\"158\":1,\"159\":1,\"161\":1,\"164\":1,\"166\":1,\"167\":1,\"170\":1,\"171\":8,\"178\":1,\"179\":1,\"181\":1,\"183\":2,\"184\":1,\"185\":2,\"186\":1,\"187\":1,\"189\":1,\"191\":1,\"193\":1,\"194\":1,\"195\":1,\"196\":1,\"197\":1,\"198\":1,\"199\":3,\"200\":1,\"201\":1,\"203\":1,\"205\":1,\"207\":1,\"209\":1,\"210\":2,\"211\":1,\"213\":1,\"215\":1,\"217\":1,\"219\":1,\"220\":1,\"221\":1,\"222\":1,\"223\":1,\"225\":3,\"226\":1,\"227\":1,\"228\":2,\"231\":1,\"233\":1,\"235\":2,\"238\":1,\"240\":1,\"242\":1,\"244\":1,\"246\":1,\"247\":1,\"249\":1,\"251\":1,\"254\":2,\"256\":1,\"259\":1,\"260\":1,\"261\":1,\"263\":1,\"264\":1,\"266\":1,\"268\":1,\"270\":1,\"272\":1,\"273\":1,\"275\":1,\"277\":1,\"279\":1,\"281\":1,\"282\":1,\"284\":1,\"285\":1,\"286\":1,\"287\":1,\"288\":1,\"289\":1,\"290\":1,\"291\":1,\"292\":3,\"293\":1,\"296\":1,\"298\":1,\"300\":1,\"302\":1,\"304\":1,\"306\":1,\"308\":1,\"310\":1}}],[\"map\",{\"0\":{\"217\":1,\"225\":1,\"293\":1},\"1\":{\"0\":3,\"63\":2,\"64\":2,\"65\":1,\"66\":4,\"85\":1,\"146\":1,\"185\":3,\"207\":2,\"209\":2,\"210\":6,\"211\":3,\"215\":3,\"216\":1,\"217\":6,\"218\":1,\"223\":1,\"225\":2,\"293\":3}}],[\"macros\",{\"0\":{\"325\":1},\"1\":{\"13\":1,\"109\":1,\"258\":1}}],[\"macro\",{\"0\":{\"16\":1},\"1\":{\"0\":1,\"16\":2,\"110\":2,\"111\":3,\"112\":1,\"113\":2,\"114\":1,\"116\":1}}],[\"psasword123\",{\"1\":{\"284\":1}}],[\"push\",{\"1\":{\"152\":2,\"154\":3,\"158\":1,\"167\":1,\"194\":2,\"240\":1,\"293\":2}}],[\"pub\",{\"1\":{\"38\":2,\"53\":2,\"99\":2,\"118\":3,\"120\":2,\"121\":1,\"122\":1,\"128\":5,\"129\":5,\"131\":3,\"132\":2,\"133\":13,\"151\":5,\"168\":1,\"170\":2,\"171\":1,\"173\":2,\"174\":1,\"175\":1,\"177\":1,\"249\":1,\"286\":1,\"306\":1,\"308\":1}}],[\"public\",{\"1\":{\"18\":1,\"38\":1,\"53\":1,\"54\":1,\"128\":2,\"129\":1,\"133\":17}}],[\"plain\",{\"1\":{\"242\":2}}],[\"playground\",{\"1\":{\"124\":1,\"126\":2}}],[\"playpen\",{\"0\":{\"124\":1},\"1\":{\"0\":1,\"124\":1}}],[\"plus\",{\"1\":{\"185\":2}}],[\"please\",{\"1\":{\"146\":1,\"209\":1,\"213\":1}}],[\"phonenumber\",{\"1\":{\"219\":2}}],[\"phone\",{\"1\":{\"219\":5}}],[\"php\",{\"1\":{\"135\":1}}],[\"phantomstruct\",{\"1\":{\"101\":2}}],[\"phantomstruct<char\",{\"1\":{\"101\":2}}],[\"phantomstruct<a\",{\"1\":{\"101\":1}}],[\"phantomtuple\",{\"1\":{\"101\":2}}],[\"phantomtuple<char\",{\"1\":{\"101\":2}}],[\"phantomtuple<a\",{\"1\":{\"101\":1}}],[\"phantomdata<unit>\",{\"1\":{\"249\":1}}],[\"phantomdata<b>\",{\"1\":{\"101\":2}}],[\"phantomdata\",{\"1\":{\"101\":5,\"249\":4}}],[\"phantom\",{\"0\":{\"346\":1},\"1\":{\"101\":4}}],[\"piped\",{\"1\":{\"291\":2}}],[\"pizza\",{\"1\":{\"146\":1}}],[\"pi\",{\"1\":{\"108\":4}}],[\"p2\",{\"1\":{\"86\":7,\"145\":3}}],[\"p1\",{\"1\":{\"86\":7,\"145\":3}}],[\"potato\",{\"1\":{\"217\":5}}],[\"poor`\",{\"1\":{\"203\":1}}],[\"poor\",{\"1\":{\"203\":5}}],[\"pop\",{\"1\":{\"154\":2}}],[\"posix\",{\"1\":{\"164\":2}}],[\"position\",{\"1\":{\"154\":1,\"209\":1}}],[\"positives<\",{\"1\":{\"185\":1}}],[\"positive\",{\"1\":{\"75\":1}}],[\"possible\",{\"1\":{\"141\":1,\"148\":1}}],[\"points\",{\"1\":{\"256\":1}}],[\"point2d\",{\"1\":{\"256\":4,\"257\":1}}],[\"point`\",{\"1\":{\"145\":2,\"263\":1}}],[\"pointer\",{\"1\":{\"33\":1,\"34\":2,\"140\":1}}],[\"pointers\",{\"1\":{\"24\":1}}],[\"point\",{\"1\":{\"20\":1,\"60\":19,\"61\":1,\"86\":16,\"145\":20,\"148\":1,\"226\":1,\"256\":4,\"259\":24,\"263\":15}}],[\"peel\",{\"1\":{\"217\":3}}],[\"peeled\",{\"1\":{\"217\":6}}],[\"perimeter\",{\"1\":{\"86\":5}}],[\"person<\",{\"1\":{\"254\":1}}],[\"person\",{\"1\":{\"60\":2,\"118\":8,\"189\":4,\"219\":3,\"228\":2,\"254\":1,\"282\":13}}],[\"peter\",{\"1\":{\"60\":3,\"254\":3}}],[\"predicate\",{\"1\":{\"306\":1,\"308\":1}}],[\"prepend\",{\"1\":{\"205\":4}}],[\"pretty\",{\"1\":{\"168\":3}}],[\"prelude\",{\"1\":{\"121\":1,\"161\":1,\"164\":2,\"288\":1,\"289\":1,\"291\":1}}],[\"pressed\",{\"1\":{\"57\":3}}],[\"proident\",{\"1\":{\"288\":2}}],[\"product\",{\"1\":{\"272\":1}}],[\"processed\",{\"1\":{\"293\":1}}],[\"process\",{\"0\":{\"355\":1},\"1\":{\"166\":5,\"183\":1,\"217\":3,\"291\":6,\"292\":3}}],[\"programmer\",{\"1\":{\"189\":3}}],[\"programming\",{\"1\":{\"87\":1}}],[\"program\",{\"1\":{\"68\":1,\"292\":1}}],[\"provides\",{\"1\":{\"42\":1}}],[\"project\",{\"1\":{\"41\":1}}],[\"prime\",{\"1\":{\"79\":1}}],[\"primitives\",{\"0\":{\"328\":1},\"1\":{\"19\":1}}],[\"princess\",{\"1\":{\"68\":3,\"69\":3}}],[\"print<\",{\"1\":{\"273\":1}}],[\"print<t>\",{\"1\":{\"270\":1}}],[\"printinoption\",{\"1\":{\"103\":2}}],[\"prints\",{\"1\":{\"97\":2}}],[\"prints<t\",{\"1\":{\"97\":1}}],[\"printer<t\",{\"1\":{\"89\":1}}],[\"print\",{\"0\":{\"347\":1,\"359\":1},\"1\":{\"38\":1,\"50\":1,\"53\":1,\"75\":3,\"89\":3,\"103\":3,\"107\":4,\"110\":3,\"128\":1,\"131\":1,\"133\":4,\"166\":2,\"207\":4,\"209\":4,\"211\":4,\"213\":4,\"220\":3,\"221\":3,\"222\":3,\"223\":3,\"225\":6,\"233\":2,\"235\":3,\"254\":2,\"266\":2,\"268\":6,\"270\":3,\"273\":1,\"289\":1,\"291\":1}}],[\"println\",{\"1\":{\"8\":3,\"10\":4,\"13\":2,\"14\":1,\"16\":1,\"30\":4,\"35\":3,\"36\":5,\"38\":2,\"47\":1,\"48\":1,\"50\":2,\"51\":1,\"53\":2,\"55\":3,\"57\":5,\"60\":5,\"63\":1,\"64\":1,\"65\":1,\"66\":4,\"67\":3,\"68\":4,\"69\":1,\"70\":2,\"72\":8,\"73\":5,\"75\":3,\"76\":11,\"78\":4,\"79\":6,\"80\":4,\"81\":4,\"83\":4,\"84\":3,\"85\":3,\"86\":3,\"89\":4,\"95\":1,\"97\":4,\"99\":3,\"101\":2,\"103\":1,\"105\":2,\"107\":16,\"108\":1,\"110\":2,\"112\":1,\"113\":2,\"114\":3,\"116\":2,\"118\":1,\"125\":1,\"128\":6,\"129\":2,\"131\":4,\"132\":4,\"133\":9,\"134\":9,\"135\":11,\"136\":10,\"137\":2,\"138\":2,\"139\":2,\"140\":5,\"142\":2,\"144\":1,\"145\":6,\"146\":5,\"147\":4,\"148\":1,\"149\":12,\"151\":1,\"152\":6,\"153\":12,\"154\":12,\"156\":2,\"158\":2,\"159\":2,\"161\":20,\"164\":1,\"167\":1,\"178\":7,\"179\":3,\"181\":1,\"183\":6,\"184\":1,\"185\":1,\"186\":13,\"187\":4,\"191\":1,\"193\":9,\"194\":1,\"195\":5,\"196\":3,\"198\":2,\"199\":5,\"200\":1,\"201\":4,\"203\":4,\"205\":2,\"207\":2,\"209\":2,\"210\":6,\"211\":2,\"213\":2,\"215\":2,\"217\":2,\"220\":2,\"221\":2,\"222\":2,\"223\":2,\"225\":4,\"226\":4,\"228\":7,\"231\":5,\"233\":1,\"235\":6,\"238\":2,\"240\":4,\"242\":3,\"244\":4,\"246\":4,\"247\":3,\"249\":2,\"251\":2,\"254\":5,\"256\":8,\"259\":5,\"260\":1,\"261\":2,\"263\":4,\"264\":4,\"266\":1,\"268\":2,\"270\":2,\"272\":2,\"273\":1,\"275\":3,\"277\":4,\"279\":1,\"281\":3,\"282\":4,\"284\":7,\"285\":6,\"286\":1,\"287\":8,\"288\":1,\"290\":1,\"291\":1,\"292\":1,\"293\":4,\"296\":9,\"298\":4,\"300\":5,\"302\":3,\"304\":4,\"306\":4,\"308\":4,\"310\":1}}],[\"private\",{\"1\":{\"18\":1,\"38\":2,\"53\":2,\"54\":1,\"128\":6,\"133\":11}}],[\"ptr\",{\"1\":{\"34\":1}}],[\"p\",{\"1\":{\"33\":2,\"161\":2,\"219\":2,\"290\":2,\"308\":2}}],[\"pangram\",{\"1\":{\"152\":5,\"291\":3}}],[\"panics\",{\"1\":{\"170\":3}}],[\"panicked\",{\"1\":{\"148\":1,\"174\":1}}],[\"panic\",{\"0\":{\"69\":1,\"148\":1,\"175\":1},\"1\":{\"0\":2,\"7\":2,\"68\":5,\"69\":3,\"70\":3,\"84\":2,\"134\":1,\"147\":1,\"148\":11,\"151\":3,\"154\":1,\"164\":1,\"166\":1,\"170\":3,\"171\":1,\"174\":2,\"175\":14,\"176\":7,\"211\":1,\"220\":2,\"221\":4,\"225\":1,\"286\":1,\"288\":2,\"289\":2,\"291\":3}}],[\"pat\",{\"1\":{\"110\":1}}],[\"paths\",{\"1\":{\"161\":2}}],[\"path`\",{\"1\":{\"161\":3}}],[\"path\",{\"1\":{\"44\":1,\"110\":1,\"133\":2,\"156\":2,\"161\":20,\"164\":21,\"195\":1,\"288\":6,\"289\":6,\"290\":2}}],[\"pair`\",{\"1\":{\"178\":4}}],[\"pair\",{\"1\":{\"60\":9,\"86\":8,\"136\":7,\"178\":14,\"231\":3}}],[\"passing\",{\"1\":{\"287\":1}}],[\"password123\",{\"1\":{\"284\":2}}],[\"password\",{\"1\":{\"284\":7}}],[\"pass<\",{\"1\":{\"264\":1}}],[\"pass`\",{\"1\":{\"264\":5}}],[\"pass\",{\"1\":{\"195\":2,\"264\":3,\"268\":2}}],[\"passed\",{\"1\":{\"45\":2,\"111\":1,\"170\":2,\"173\":3,\"174\":1,\"175\":2,\"176\":4,\"177\":4}}],[\"pasted\",{\"1\":{\"57\":3}}],[\"paste\",{\"1\":{\"57\":3}}],[\"page\",{\"1\":{\"57\":2}}],[\"pageunload\",{\"1\":{\"57\":3}}],[\"pageload\",{\"1\":{\"57\":3}}],[\"pariatur\",{\"1\":{\"288\":2}}],[\"parameter\",{\"1\":{\"242\":1}}],[\"parent\",{\"1\":{\"133\":1}}],[\"partiaeq\",{\"1\":{\"284\":1}}],[\"partial\",{\"1\":{\"282\":1}}],[\"partialord\",{\"1\":{\"179\":2}}],[\"partialeq\",{\"1\":{\"52\":1,\"76\":3,\"101\":2,\"179\":2,\"284\":2}}],[\"partition\",{\"1\":{\"66\":2}}],[\"parts\",{\"1\":{\"34\":3}}],[\"parse<i32>\",{\"1\":{\"225\":1}}],[\"parseinterror\",{\"1\":{\"210\":2,\"213\":3,\"220\":1,\"221\":1,\"222\":1,\"223\":1,\"225\":2}}],[\"parseinterror>`\",{\"1\":{\"223\":1,\"225\":1}}],[\"parseinterror>>\",{\"1\":{\"210\":1}}],[\"parseinterror>\",{\"1\":{\"67\":1,\"210\":1,\"220\":2,\"221\":2,\"222\":2,\"223\":1,\"225\":4}}],[\"parsed\",{\"1\":{\"51\":4,\"211\":2,\"213\":2}}],[\"parse\",{\"1\":{\"51\":4,\"63\":1,\"64\":1,\"65\":1,\"66\":2,\"67\":2,\"70\":6,\"207\":1,\"209\":1,\"210\":3,\"211\":3,\"213\":5,\"220\":2,\"221\":2,\"222\":2,\"223\":2,\"225\":7,\"287\":2}}],[\"package\",{\"1\":{\"41\":1,\"44\":3}}],[\"pauses\",{\"1\":{\"30\":1}}],[\"原因采取内部对错误类型的实现\",{\"1\":{\"213\":1}}],[\"原文没有具体讲如何确定\",{\"1\":{\"225\":1}}],[\"原文\",{\"1\":{\"163\":1}}],[\"原来的所有者不能再被使用\",{\"1\":{\"140\":1}}],[\"原样\",{\"1\":{\"110\":1}}],[\"原始数据才可以再次借用\",{\"1\":{\"259\":1}}],[\"原始数据不能使用可变借用\",{\"1\":{\"259\":1}}],[\"原始字节串和原始字符串的写法一样\",{\"1\":{\"153\":1}}],[\"原始指针\",{\"0\":{\"33\":1},\"1\":{\"33\":1}}],[\"原始标识符允许你使用通常不允许的关键字\",{\"1\":{\"40\":1}}],[\"原始标识符\",{\"1\":{\"3\":1}}],[\"原始标志符\",{\"0\":{\"40\":1},\"1\":{\"0\":1}}],[\"原生类型是例外\",{\"1\":{\"191\":1}}],[\"原生类型的类型转换\",{\"1\":{\"31\":1}}],[\"原生类型\",{\"0\":{\"19\":1},\"1\":{\"0\":1,\"15\":1,\"25\":1,\"27\":1}}],[\"兼容性\",{\"0\":{\"3\":1},\"1\":{\"0\":1,\"15\":1}}],[\"不使用涡轮鱼写法\",{\"1\":{\"293\":1}}],[\"不使用关联类型\",{\"1\":{\"246\":1}}],[\"不需要其它分支\",{\"1\":{\"296\":1}}],[\"不需要\",{\"1\":{\"293\":1}}],[\"不包含任何功能\",{\"1\":{\"247\":1}}],[\"不符合上面的范围\",{\"1\":{\"228\":1}}],[\"不够灵活\",{\"1\":{\"211\":1}}],[\"不提供隐式转换\",{\"1\":{\"193\":1}}],[\"不提供原生类型之间的隐式类型转换\",{\"1\":{\"193\":1}}],[\"不显示类型转换产生的溢出警告\",{\"1\":{\"193\":1}}],[\"不带参数的函数\",{\"1\":{\"266\":1}}],[\"不带附加属性的元组结构体\",{\"1\":{\"179\":1}}],[\"不带字段\",{\"1\":{\"60\":1}}],[\"不含重复值\",{\"1\":{\"285\":1}}],[\"不含资源的单元结构体\",{\"1\":{\"178\":1}}],[\"不含此值\",{\"1\":{\"72\":1}}],[\"不等\",{\"1\":{\"174\":1}}],[\"不等于\",{\"1\":{\"57\":2}}],[\"不如把失败的原因包装在\",{\"1\":{\"151\":1}}],[\"不如让编译器辨别没有礼物的情况\",{\"1\":{\"68\":1}}],[\"不管\",{\"1\":{\"118\":1}}],[\"不能可变地借用一个不可变对象\",{\"1\":{\"261\":1}}],[\"不能再以不可变方式来借用\",{\"1\":{\"259\":1}}],[\"不能以可变方式借用\",{\"1\":{\"259\":1}}],[\"不能使用\",{\"1\":{\"256\":1,\"282\":1}}],[\"不能作用于\",{\"1\":{\"247\":1}}],[\"不能得到\",{\"1\":{\"205\":1}}],[\"不能打印\",{\"1\":{\"179\":1}}],[\"不能在非测试代码中使用\",{\"1\":{\"168\":1}}],[\"不能访问数据\",{\"1\":{\"140\":1}}],[\"不能将其销毁\",{\"1\":{\"138\":1}}],[\"不能参与运算\",{\"1\":{\"101\":1}}],[\"不能修改一个\",{\"1\":{\"55\":1}}],[\"不会消耗\",{\"1\":{\"249\":1}}],[\"不会泄露内存\",{\"1\":{\"148\":1}}],[\"不会\",{\"1\":{\"101\":1,\"147\":1,\"183\":1}}],[\"不可读\",{\"1\":{\"289\":1}}],[\"不可复制类型必须移动\",{\"1\":{\"235\":1}}],[\"不可复制类型\",{\"1\":{\"235\":1}}],[\"不可复制的类型\",{\"1\":{\"93\":1,\"240\":1}}],[\"不可增长\",{\"1\":{\"154\":1}}],[\"不可变地借用一个可变对象\",{\"1\":{\"261\":1}}],[\"不可变地借用一个不可变对象\",{\"1\":{\"261\":1}}],[\"不可变的引用不再用于其余的代码\",{\"1\":{\"259\":1}}],[\"不可变\",{\"1\":{\"154\":1}}],[\"不可改变的值\",{\"1\":{\"55\":1}}],[\"不要包含此项到文档中\",{\"1\":{\"122\":1}}],[\"不要写重复代码\",{\"1\":{\"111\":1}}],[\"不要理会就是了\",{\"1\":{\"87\":1}}],[\"不要忘记在这里加上一个分号\",{\"1\":{\"75\":1}}],[\"不要忘了安装\",{\"1\":{\"15\":1}}],[\"不属于引用类型\",{\"1\":{\"83\":1}}],[\"不断增加的代码\",{\"1\":{\"81\":1}}],[\"不觉得这行很多余吗\",{\"1\":{\"76\":1}}],[\"不缩进就不能运行\",{\"1\":{\"76\":1}}],[\"不同的是\",{\"1\":{\"75\":1}}],[\"不同于为类型取别名时的\",{\"1\":{\"246\":1}}],[\"不同于\",{\"1\":{\"52\":1}}],[\"不存在资源移动\",{\"1\":{\"140\":1}}],[\"不存在\",{\"1\":{\"68\":1,\"289\":1}}],[\"不仅仅是一个包依赖管理器\",{\"1\":{\"44\":1}}],[\"不是泛型的\",{\"1\":{\"249\":1}}],[\"不是一个泛型类型\",{\"1\":{\"91\":1}}],[\"不是\",{\"1\":{\"36\":1}}],[\"不安全代码块主要用于四件事情\",{\"1\":{\"32\":1}}],[\"不安全代码块用于避开编译器的保护策略\",{\"1\":{\"32\":1}}],[\"不安全操作\",{\"0\":{\"32\":1},\"1\":{\"0\":1,\"15\":1}}],[\"不\",{\"1\":{\"10\":1}}],[\"不一样\",{\"1\":{\"10\":1}}],[\"不过我们已经知道这个实例不为空值\",{\"1\":{\"291\":1}}],[\"不过我们已经决定要尽可能避免\",{\"1\":{\"221\":1}}],[\"不过集合\",{\"1\":{\"285\":1}}],[\"不过有一个生命周期参数\",{\"1\":{\"266\":1}}],[\"不过可以加上\",{\"1\":{\"133\":1}}],[\"不过带有私有字段的结构体可以使用公有的构造器来创建\",{\"1\":{\"129\":1}}],[\"不过块注释在临时注释大块代码特别有用\",{\"1\":{\"105\":1}}],[\"不过类型标注和使用\",{\"1\":{\"83\":1}}],[\"不过调用闭包时\",{\"1\":{\"83\":1}}],[\"不过考虑到我们免费获得了\",{\"1\":{\"48\":1}}],[\"不过在多数情况下\",{\"1\":{\"35\":1}}],[\"不过这时使用\",{\"1\":{\"7\":1}}],[\"不过\",{\"1\":{\"4\":1,\"38\":1,\"211\":1,\"270\":1,\"275\":1}}],[\"不过你可以在\",{\"1\":{\"2\":1}}],[\"不写重复代码\",{\"0\":{\"111\":1},\"1\":{\"0\":1,\"16\":1}}],[\"文字或符号之类的\",{\"1\":{\"135\":1}}],[\"文档中可以查看格式化\",{\"1\":{\"251\":1}}],[\"文档中关于指定依赖的部分\",{\"1\":{\"169\":1}}],[\"文档属性\",{\"0\":{\"119\":1}}],[\"文档注释通常可能带有\",{\"1\":{\"170\":1}}],[\"文档注释使用\",{\"1\":{\"170\":1}}],[\"文档注释就会编译成文档\",{\"1\":{\"118\":1}}],[\"文档注释对于需要文档的大型项目来说非常重要\",{\"1\":{\"118\":1}}],[\"文档注释\",{\"0\":{\"118\":1},\"1\":{\"105\":1,\"106\":1}}],[\"文档和基准测试\",{\"1\":{\"15\":1}}],[\"文档\",{\"0\":{\"117\":1},\"1\":{\"0\":1,\"17\":1,\"28\":1}}],[\"文档测试应当可以作为完整的代码段被直接使用\",{\"1\":{\"171\":1}}],[\"文档测试的主要目的是作为使用函数功能的例子\",{\"1\":{\"171\":1}}],[\"文档测试的目的\",{\"0\":{\"171\":1}}],[\"文档测试\",{\"0\":{\"170\":1},\"1\":{\"0\":1}}],[\"文件将被关闭\",{\"1\":{\"289\":1}}],[\"文件的名字\",{\"1\":{\"53\":1}}],[\"文件的相应声明处\",{\"1\":{\"5\":1}}],[\"文件中\",{\"1\":{\"173\":1}}],[\"文件中写上\",{\"1\":{\"44\":1}}],[\"文件中的\",{\"1\":{\"44\":1}}],[\"文件\",{\"1\":{\"5\":1,\"41\":1,\"42\":1,\"44\":1,\"128\":1,\"168\":2,\"173\":2,\"290\":1}}],[\"文件系统操作\",{\"0\":{\"161\":1},\"1\":{\"0\":1}}],[\"文件输入输出\",{\"0\":{\"160\":1},\"1\":{\"0\":1,\"26\":1}}],[\"文件分层\",{\"0\":{\"128\":1},\"1\":{\"0\":1}}],[\"单位说明\",{\"0\":{\"249\":1}}],[\"单位检查\",{\"1\":{\"0\":1}}],[\"单精度复数的最简实现\",{\"1\":{\"159\":1}}],[\"单行注释\",{\"1\":{\"105\":1}}],[\"单元结构体\",{\"1\":{\"60\":2}}],[\"单元\",{\"1\":{\"28\":1}}],[\"单元类型\",{\"1\":{\"20\":1}}],[\"单元测试一次仅能单独测试一个模块\",{\"1\":{\"173\":1}}],[\"单元测试\",{\"0\":{\"174\":1},\"1\":{\"0\":1}}],[\"单个值可以用\",{\"1\":{\"300\":1}}],[\"单个\",{\"1\":{\"20\":1,\"116\":1}}],[\"单击上面的\",{\"1\":{\"14\":1}}],[\"管道也被关闭\",{\"1\":{\"291\":1}}],[\"管道\",{\"0\":{\"291\":1},\"1\":{\"0\":1}}],[\"子进程\",{\"0\":{\"166\":1},\"1\":{\"0\":1}}],[\"子句\",{\"1\":{\"0\":1}}],[\"our\",{\"1\":{\"292\":1}}],[\"outer\",{\"1\":{\"199\":3,\"226\":4}}],[\"out\",{\"1\":{\"45\":2,\"149\":2,\"170\":2,\"173\":3,\"174\":1,\"175\":2,\"176\":4,\"177\":4,\"288\":4}}],[\"output<\",{\"1\":{\"268\":1}}],[\"output`\",{\"1\":{\"249\":1}}],[\"output=t>\",{\"1\":{\"111\":1}}],[\"output\",{\"1\":{\"42\":1,\"166\":6,\"187\":2,\"242\":1,\"249\":4}}],[\"occaecat\",{\"1\":{\"288\":2}}],[\"occupies\",{\"1\":{\"134\":1,\"145\":6}}],[\"octal\",{\"1\":{\"107\":1}}],[\"overloading\",{\"1\":{\"250\":1}}],[\"overflowing\",{\"1\":{\"193\":1}}],[\"over\",{\"1\":{\"107\":1,\"152\":1,\"291\":1}}],[\"object=\",{\"1\":{\"107\":1}}],[\"object\",{\"1\":{\"107\":1,\"134\":1}}],[\"old\",{\"1\":{\"99\":8,\"228\":1}}],[\"ord\",{\"1\":{\"179\":1,\"247\":1,\"248\":1}}],[\"order\",{\"1\":{\"85\":1}}],[\"or\",{\"1\":{\"105\":1,\"113\":3,\"135\":2,\"161\":7,\"163\":1,\"166\":1,\"200\":1,\"207\":1,\"209\":1,\"210\":1,\"211\":1,\"213\":1,\"287\":3}}],[\"original\",{\"1\":{\"178\":3}}],[\"origin\",{\"1\":{\"86\":3,\"145\":8}}],[\"org\",{\"1\":{\"83\":1}}],[\"odd\",{\"1\":{\"84\":3,\"85\":6,\"231\":1}}],[\"oh\",{\"1\":{\"68\":1,\"215\":1,\"217\":1}}],[\"owner\",{\"1\":{\"273\":6}}],[\"ownership\",{\"1\":{\"15\":1,\"23\":1,\"140\":1}}],[\"owned`\",{\"1\":{\"240\":1}}],[\"owned\",{\"1\":{\"57\":2,\"181\":2,\"209\":2,\"240\":1,\"242\":3}}],[\"ok<t>\",{\"1\":{\"70\":1}}],[\"ok\",{\"1\":{\"45\":8,\"52\":3,\"64\":1,\"66\":2,\"70\":1,\"78\":1,\"111\":4,\"151\":7,\"153\":2,\"161\":8,\"170\":5,\"171\":2,\"173\":4,\"174\":1,\"175\":5,\"176\":7,\"177\":5,\"207\":2,\"209\":2,\"210\":1,\"211\":3,\"213\":3,\"220\":4,\"221\":2,\"222\":2,\"223\":1,\"225\":5,\"286\":7,\"287\":2,\"288\":2,\"289\":2,\"290\":3,\"291\":3}}],[\"other\",{\"1\":{\"43\":3,\"45\":1,\"132\":2,\"300\":2}}],[\"otherwise\",{\"1\":{\"41\":1}}],[\"only\",{\"1\":{\"275\":1,\"288\":1,\"289\":1}}],[\"once\",{\"1\":{\"242\":2}}],[\"ones\",{\"1\":{\"300\":1}}],[\"one`\",{\"1\":{\"268\":1}}],[\"one<\",{\"1\":{\"268\":2,\"273\":1}}],[\"one\",{\"1\":{\"79\":1,\"83\":3,\"135\":1,\"136\":1,\"179\":8,\"185\":2,\"201\":3,\"209\":1,\"213\":1,\"231\":1,\"249\":13,\"268\":4,\"273\":1,\"287\":3}}],[\"on\",{\"1\":{\"36\":3,\"83\":1,\"170\":1,\"186\":1,\"215\":2}}],[\"oslo\",{\"1\":{\"251\":1}}],[\"osstr\",{\"1\":{\"164\":1,\"165\":1}}],[\"os\",{\"1\":{\"36\":3,\"161\":1,\"167\":1,\"200\":2}}],[\"officia\",{\"1\":{\"288\":2}}],[\"of\",{\"1\":{\"15\":1,\"50\":2,\"84\":1,\"85\":3,\"134\":5,\"136\":3,\"141\":1,\"145\":6,\"148\":1,\"149\":8,\"154\":1,\"159\":1,\"183\":1,\"186\":2,\"195\":13,\"203\":1,\"228\":4,\"263\":1,\"286\":2,\"292\":2}}],[\"opt\",{\"1\":{\"210\":2}}],[\"option<self\",{\"1\":{\"308\":1}}],[\"option<string>\",{\"1\":{\"219\":1}}],[\"option<phonenumber>\",{\"1\":{\"219\":1}}],[\"option<peeled>\",{\"1\":{\"217\":2}}],[\"option<job>\",{\"1\":{\"219\":1}}],[\"option<u8>\",{\"1\":{\"219\":3}}],[\"option<u32>\",{\"1\":{\"186\":1,\"228\":1}}],[\"option<cooked>\",{\"1\":{\"217\":3}}],[\"option<chopped>\",{\"1\":{\"217\":2}}],[\"option<option<food>>\",{\"1\":{\"215\":1}}],[\"option<option<t>>\",{\"1\":{\"215\":1}}],[\"option<food>\",{\"1\":{\"215\":5,\"217\":2}}],[\"option<result<i32\",{\"1\":{\"210\":1}}],[\"option<\",{\"1\":{\"68\":2,\"146\":1,\"207\":1,\"209\":1,\"213\":1}}],[\"option<t>\",{\"1\":{\"68\":1,\"103\":1,\"147\":1,\"215\":1}}],[\"option<i32>\",{\"1\":{\"24\":1,\"76\":2,\"147\":2}}],[\"optional\",{\"1\":{\"24\":1,\"76\":3,\"81\":8,\"147\":3}}],[\"option\",{\"0\":{\"68\":1,\"147\":1,\"210\":1,\"219\":1,\"339\":1},\"1\":{\"0\":4,\"7\":2,\"65\":1,\"67\":3,\"68\":2,\"70\":3,\"77\":1,\"82\":1,\"85\":1,\"103\":3,\"147\":1,\"151\":1,\"164\":1,\"215\":2,\"216\":2,\"217\":2,\"218\":2,\"219\":2,\"225\":1,\"228\":1,\"229\":1,\"308\":1}}],[\"op\",{\"1\":{\"111\":4,\"151\":2,\"286\":4}}],[\"ops\",{\"1\":{\"111\":1,\"187\":4,\"249\":1}}],[\"operator\",{\"1\":{\"135\":1}}],[\"operations\",{\"1\":{\"58\":2}}],[\"opened\",{\"1\":{\"163\":1}}],[\"openoptions\",{\"1\":{\"161\":2}}],[\"openbox\",{\"1\":{\"129\":1}}],[\"openbox<t>\",{\"1\":{\"129\":1}}],[\"open\",{\"0\":{\"289\":1},\"1\":{\"0\":1,\"129\":3,\"161\":3,\"288\":1,\"289\":5,\"290\":2}}],[\"o\",{\"0\":{\"160\":1},\"1\":{\"0\":1,\"26\":1,\"107\":1,\"160\":2,\"163\":2,\"251\":2}}],[\"路径绑定到\",{\"1\":{\"132\":1}}],[\"路径\",{\"0\":{\"164\":1},\"1\":{\"0\":1}}],[\"线程的机制\",{\"1\":{\"167\":1}}],[\"线程的自定义类型\",{\"1\":{\"15\":1}}],[\"线程将在发送完消息后\",{\"1\":{\"158\":1}}],[\"线程可以使用分配在\",{\"1\":{\"144\":1}}],[\"线程\",{\"0\":{\"167\":1},\"1\":{\"0\":1,\"26\":1,\"167\":1,\"293\":1}}],[\"aute\",{\"1\":{\"288\":2}}],[\"author\",{\"1\":{\"261\":2}}],[\"authors\",{\"1\":{\"44\":3}}],[\"ad\",{\"1\":{\"288\":2}}],[\"adipisicing\",{\"1\":{\"288\":2}}],[\"added\",{\"1\":{\"298\":1}}],[\"adder\",{\"1\":{\"173\":4,\"185\":2}}],[\"add<rhs\",{\"1\":{\"249\":1}}],[\"add<foo>\",{\"1\":{\"187\":1}}],[\"add<bar>\",{\"1\":{\"187\":1}}],[\"add`\",{\"1\":{\"187\":1}}],[\"addition\",{\"1\":{\"84\":3}}],[\"add\",{\"1\":{\"58\":4,\"111\":6,\"168\":3,\"170\":3,\"173\":6,\"174\":11,\"177\":7,\"187\":10,\"188\":1,\"249\":8,\"268\":2,\"273\":2}}],[\"amet\",{\"1\":{\"288\":2}}],[\"among\",{\"1\":{\"73\":3}}],[\"after\",{\"1\":{\"198\":1}}],[\"a>>\",{\"1\":{\"284\":1}}],[\"a>\",{\"1\":{\"185\":1,\"254\":1,\"264\":2,\"266\":2,\"268\":3,\"270\":1,\"272\":1,\"273\":2,\"275\":1,\"277\":3,\"279\":3,\"284\":6}}],[\"a`\",{\"1\":{\"149\":2,\"161\":4,\"183\":1,\"246\":1,\"266\":7,\"268\":4,\"270\":4,\"272\":1}}],[\"awesome\",{\"1\":{\"146\":1}}],[\"await\",{\"1\":{\"122\":1}}],[\"append\",{\"1\":{\"288\":1}}],[\"apply\",{\"1\":{\"233\":1,\"240\":3}}],[\"apply<f>\",{\"1\":{\"233\":2,\"240\":1}}],[\"apple\",{\"1\":{\"144\":5,\"217\":6}}],[\"api\",{\"1\":{\"29\":1,\"112\":1,\"159\":1,\"172\":1}}],[\"actor=\",{\"1\":{\"254\":1}}],[\"actor\",{\"1\":{\"254\":2}}],[\"acquisition\",{\"1\":{\"141\":1}}],[\"accountinfo\",{\"1\":{\"284\":1}}],[\"accountinfo<\",{\"1\":{\"284\":2}}],[\"account\",{\"1\":{\"284\":9}}],[\"accounts\",{\"1\":{\"284\":7}}],[\"accounts<\",{\"1\":{\"284\":2}}],[\"account<\",{\"1\":{\"284\":1}}],[\"acc\",{\"1\":{\"84\":3,\"85\":3}}],[\"accessible\",{\"1\":{\"275\":1}}],[\"access\",{\"1\":{\"38\":2,\"53\":2,\"54\":2,\"128\":4,\"133\":3,\"163\":1}}],[\"again\",{\"1\":{\"81\":2,\"146\":2}}],[\"age`\",{\"1\":{\"219\":3,\"282\":1}}],[\"agewidget>\",{\"1\":{\"181\":1}}],[\"agewidget\",{\"1\":{\"181\":3}}],[\"age\",{\"1\":{\"60\":3,\"99\":8,\"181\":5,\"219\":4,\"228\":5,\"254\":3,\"282\":7}}],[\"ain\",{\"1\":{\"79\":1}}],[\"abc\",{\"1\":{\"135\":1}}],[\"abs\",{\"1\":{\"86\":3,\"251\":2}}],[\"abstract\",{\"1\":{\"16\":1}}],[\"about\",{\"1\":{\"79\":1,\"231\":1,\"304\":1}}],[\"aaaaaaaa\",{\"1\":{\"68\":1,\"69\":1}}],[\"attempting\",{\"1\":{\"284\":1}}],[\"attend\",{\"1\":{\"189\":1}}],[\"attributes\",{\"1\":{\"255\":1}}],[\"attribute\",{\"0\":{\"314\":1},\"1\":{\"1\":7,\"107\":1}}],[\"atomic\",{\"1\":{\"144\":1}}],[\"at\",{\"1\":{\"57\":1,\"141\":1,\"148\":2,\"174\":1,\"209\":1,\"213\":1}}],[\"asref<path>\",{\"1\":{\"290\":2}}],[\"ashley\",{\"1\":{\"146\":5}}],[\"async\",{\"1\":{\"122\":1}}],[\"assoc\",{\"0\":{\"344\":1}}],[\"associated\",{\"1\":{\"87\":1}}],[\"assign\",{\"1\":{\"111\":9}}],[\"assign`\",{\"1\":{\"111\":6}}],[\"assertion\",{\"1\":{\"174\":1}}],[\"assertions\",{\"1\":{\"168\":3}}],[\"assert\",{\"1\":{\"33\":1,\"34\":1,\"52\":4,\"111\":4,\"168\":3,\"170\":2,\"173\":2,\"174\":6,\"175\":1,\"177\":4,\"181\":2,\"185\":6,\"219\":1,\"227\":1,\"285\":3}}],[\"assembly\",{\"1\":{\"32\":1}}],[\"as\",{\"1\":{\"34\":2,\"131\":1,\"132\":2,\"134\":2,\"135\":1,\"146\":1,\"153\":2,\"158\":1,\"161\":1,\"179\":1,\"181\":2,\"191\":2,\"193\":18,\"201\":4,\"288\":1,\"291\":1}}],[\"ast\",{\"1\":{\"16\":1}}],[\"al\",{\"1\":{\"141\":1,\"148\":1}}],[\"aliquip\",{\"1\":{\"288\":2}}],[\"aliqua\",{\"1\":{\"288\":2}}],[\"alice\",{\"1\":{\"107\":1,\"152\":4,\"282\":1}}],[\"aliasedresult<i32>\",{\"1\":{\"223\":2}}],[\"aliasedresult<t>\",{\"1\":{\"223\":1}}],[\"alias\",{\"1\":{\"31\":1}}],[\"also\",{\"0\":{\"100\":1,\"214\":1},\"1\":{\"153\":1}}],[\"all\",{\"1\":{\"85\":1,\"141\":1,\"148\":1,\"161\":2,\"185\":1,\"288\":1,\"291\":1,\"300\":1}}],[\"allocs\",{\"1\":{\"141\":1,\"148\":1}}],[\"allocated\",{\"1\":{\"24\":1,\"141\":1,\"148\":1}}],[\"allowed\",{\"1\":{\"153\":1}}],[\"allow\",{\"1\":{\"39\":2,\"57\":1,\"60\":1,\"89\":1,\"107\":2,\"128\":2,\"129\":1,\"133\":2,\"145\":2,\"174\":1,\"191\":1,\"193\":1,\"201\":1,\"203\":1,\"215\":1,\"217\":1,\"226\":1,\"261\":1,\"296\":1,\"297\":1}}],[\"already\",{\"1\":{\"30\":1,\"285\":1}}],[\"a\",{\"1\":{\"11\":7,\"14\":1,\"20\":1,\"21\":1,\"30\":1,\"35\":3,\"41\":1,\"46\":2,\"68\":1,\"72\":2,\"73\":3,\"75\":2,\"76\":12,\"79\":2,\"84\":1,\"91\":5,\"101\":2,\"103\":1,\"134\":3,\"135\":1,\"136\":3,\"140\":7,\"141\":1,\"142\":1,\"145\":2,\"146\":2,\"148\":1,\"149\":15,\"153\":3,\"161\":28,\"163\":2,\"164\":2,\"168\":2,\"170\":4,\"171\":2,\"173\":2,\"174\":5,\"175\":3,\"177\":2,\"183\":6,\"185\":2,\"187\":2,\"193\":7,\"196\":4,\"199\":1,\"209\":1,\"210\":1,\"213\":1,\"228\":2,\"238\":2,\"242\":3,\"244\":4,\"246\":6,\"247\":3,\"254\":2,\"264\":3,\"266\":8,\"268\":8,\"270\":10,\"272\":6,\"273\":2,\"275\":2,\"277\":4,\"279\":1,\"284\":6,\"285\":9,\"293\":1,\"298\":6,\"302\":3}}],[\"area<t\",{\"1\":{\"89\":1}}],[\"area\",{\"1\":{\"61\":1,\"86\":3,\"89\":7,\"219\":5}}],[\"are\",{\"1\":{\"36\":6,\"141\":1,\"148\":1,\"149\":1,\"153\":1,\"186\":2,\"201\":2,\"228\":1,\"231\":1,\"277\":1,\"304\":1}}],[\"array2\",{\"1\":{\"306\":3,\"308\":3}}],[\"array1\",{\"1\":{\"306\":3,\"308\":3}}],[\"array\",{\"1\":{\"21\":1,\"97\":3,\"134\":7,\"186\":4,\"300\":14}}],[\"argument\",{\"1\":{\"287\":2}}],[\"arguments\",{\"1\":{\"156\":2,\"287\":1}}],[\"arg2\",{\"1\":{\"156\":1}}],[\"arg1\",{\"1\":{\"156\":1}}],[\"args\",{\"1\":{\"156\":9,\"287\":18}}],[\"arg\",{\"0\":{\"353\":1},\"1\":{\"11\":3,\"166\":1,\"292\":1}}],[\"arc\",{\"0\":{\"144\":1},\"1\":{\"0\":1,\"144\":3}}],[\"anim\",{\"1\":{\"288\":2}}],[\"animal>\",{\"1\":{\"184\":2}}],[\"animaltrait\",{\"1\":{\"30\":1}}],[\"animal\",{\"1\":{\"30\":5,\"184\":13}}],[\"antimatter\",{\"1\":{\"231\":1}}],[\"answer\",{\"1\":{\"228\":1,\"287\":7}}],[\"another\",{\"1\":{\"196\":6,\"259\":3}}],[\"analyze\",{\"1\":{\"134\":3}}],[\"ancestor\",{\"1\":{\"133\":1}}],[\"annotated\",{\"1\":{\"83\":3,\"264\":4}}],[\"annotation\",{\"1\":{\"21\":1}}],[\"an\",{\"1\":{\"21\":1,\"35\":3,\"76\":1,\"136\":1,\"184\":1,\"228\":1,\"287\":2}}],[\"and\",{\"0\":{\"52\":1,\"215\":1},\"1\":{\"0\":1,\"57\":1,\"60\":2,\"75\":2,\"76\":1,\"84\":1,\"113\":3,\"135\":2,\"140\":1,\"141\":3,\"146\":1,\"148\":3,\"149\":1,\"153\":4,\"163\":2,\"166\":2,\"184\":1,\"189\":1,\"207\":1,\"208\":1,\"209\":1,\"211\":2,\"214\":1,\"215\":4,\"216\":1,\"223\":1,\"225\":2,\"244\":1,\"246\":1,\"256\":1,\"266\":1,\"277\":1,\"292\":1,\"296\":1,\"300\":3,\"304\":2}}],[\"any<f>\",{\"1\":{\"306\":1}}],[\"any\",{\"0\":{\"306\":1},\"1\":{\"0\":1,\"123\":1,\"175\":2,\"176\":3,\"306\":5,\"307\":1}}],[\"共享引用计数\",{\"0\":{\"144\":1},\"1\":{\"0\":1,\"144\":1}}],[\"引用的值\",{\"1\":{\"298\":1}}],[\"引用\",{\"1\":{\"37\":1,\"270\":2,\"298\":1}}],[\"引用计数就会减少\",{\"1\":{\"149\":1}}],[\"引用计数\",{\"0\":{\"149\":1},\"1\":{\"0\":1,\"149\":1}}],[\"引入新关键字时\",{\"1\":{\"40\":1}}],[\"引入\",{\"0\":{\"221\":1},\"1\":{\"0\":1}}],[\"散列集\",{\"0\":{\"285\":1},\"1\":{\"0\":1}}],[\"散列表\",{\"0\":{\"146\":1},\"1\":{\"0\":1,\"146\":1}}],[\"hue\",{\"1\":{\"296\":2}}],[\"hundred\",{\"1\":{\"177\":1}}],[\"hsl\",{\"1\":{\"296\":2}}],[\"hsv\",{\"1\":{\"296\":2}}],[\"h\",{\"1\":{\"141\":1,\"148\":1,\"296\":4}}],[\"hi\",{\"1\":{\"146\":1}}],[\"hidden\",{\"1\":{\"122\":1}}],[\"higher\",{\"1\":{\"85\":1}}],[\"hosts\",{\"1\":{\"290\":2}}],[\"home\",{\"1\":{\"256\":1}}],[\"hofstadter\",{\"1\":{\"261\":1}}],[\"hof\",{\"1\":{\"85\":2}}],[\"how\",{\"1\":{\"68\":1}}],[\"html\",{\"1\":{\"83\":1,\"105\":1,\"126\":1}}],[\"https\",{\"1\":{\"44\":1,\"83\":1}}],[\"help\",{\"1\":{\"287\":4}}],[\"hello`\",{\"1\":{\"16\":1}}],[\"hello\",{\"0\":{\"13\":1,\"324\":1},\"1\":{\"0\":1,\"13\":6,\"14\":1,\"15\":2,\"16\":4,\"24\":1,\"47\":1,\"73\":3,\"105\":1,\"118\":4,\"125\":1,\"136\":1,\"146\":1,\"161\":4,\"240\":1,\"289\":7}}],[\"head\",{\"1\":{\"205\":2}}],[\"heap\",{\"1\":{\"24\":1,\"141\":4,\"148\":3}}],[\"hexadecimal\",{\"1\":{\"107\":1}}],[\"height\",{\"1\":{\"89\":5}}],[\"here\",{\"1\":{\"42\":1,\"153\":3,\"209\":1}}],[\"haystack\",{\"1\":{\"235\":3}}],[\"haven\",{\"1\":{\"228\":1}}],[\"have\",{\"1\":{\"146\":2,\"154\":1,\"203\":2,\"215\":6}}],[\"handle\",{\"1\":{\"293\":1}}],[\"handling\",{\"1\":{\"7\":1,\"24\":1}}],[\"hang\",{\"1\":{\"146\":1}}],[\"has\",{\"1\":{\"134\":1,\"163\":1,\"205\":1,\"259\":4}}],[\"hasarea>\",{\"1\":{\"89\":1}}],[\"hasarea\",{\"1\":{\"89\":2}}],[\"hash\",{\"0\":{\"351\":1},\"1\":{\"146\":4,\"179\":2,\"284\":10}}],[\"hashset<i32>\",{\"1\":{\"285\":2}}],[\"hashset<t>\",{\"1\":{\"285\":1}}],[\"hashset\",{\"0\":{\"285\":1},\"1\":{\"0\":1,\"285\":5}}],[\"hashmap<t\",{\"1\":{\"285\":1}}],[\"hashmap<account<\",{\"1\":{\"284\":1}}],[\"hashmap\",{\"0\":{\"146\":1},\"1\":{\"0\":1,\"146\":10,\"284\":5,\"285\":1}}],[\"half\",{\"1\":{\"75\":1}}],[\"haircut\",{\"1\":{\"30\":1}}],[\"选项类型\",{\"1\":{\"24\":1}}],[\"选项\",{\"0\":{\"147\":1},\"1\":{\"0\":1,\"54\":1,\"68\":2}}],[\"字\",{\"1\":{\"134\":1}}],[\"字段\",{\"1\":{\"302\":1}}],[\"字段也拥有\",{\"1\":{\"291\":1}}],[\"字段的拷贝\",{\"1\":{\"263\":1}}],[\"字段的引用\",{\"1\":{\"263\":1}}],[\"字段是私有的\",{\"1\":{\"129\":1}}],[\"字段是使用语义版本控制\",{\"1\":{\"44\":1}}],[\"字段默认拥有私有的可见性\",{\"1\":{\"129\":1}}],[\"字段表明发布\",{\"1\":{\"44\":1}}],[\"字段表明项目的名称\",{\"1\":{\"44\":1}}],[\"字节串可以不使用\",{\"1\":{\"153\":1}}],[\"字节串可以使用单字节的转义字符\",{\"1\":{\"153\":1}}],[\"字节串没有实现\",{\"1\":{\"153\":1}}],[\"字节串\",{\"1\":{\"153\":1}}],[\"字节\",{\"1\":{\"20\":1}}],[\"字符的意义在这里稍微有些不同\",{\"1\":{\"270\":1}}],[\"字符\",{\"1\":{\"20\":2,\"135\":1}}],[\"字符串写进\",{\"1\":{\"288\":1}}],[\"字符串字面量拥有\",{\"1\":{\"261\":1}}],[\"字符串表示的\",{\"1\":{\"164\":1}}],[\"字符串切片\",{\"1\":{\"118\":1}}],[\"字符串成功和失败时会发生什么\",{\"1\":{\"70\":1}}],[\"字符串\",{\"0\":{\"152\":1},\"1\":{\"0\":1,\"24\":1,\"135\":1,\"146\":1,\"153\":1,\"290\":1}}],[\"字面量并打印它\",{\"1\":{\"275\":1}}],[\"字面量中出现的字符串或字符定界符必须转义\",{\"1\":{\"153\":1}}],[\"字面量也有多种写法\",{\"1\":{\"153\":1}}],[\"字面量与转义字符\",{\"0\":{\"153\":1}}],[\"字面量\",{\"0\":{\"195\":1},\"1\":{\"0\":1,\"55\":1,\"135\":1,\"275\":1}}],[\"字面量和运算符\",{\"0\":{\"135\":1},\"1\":{\"0\":1}}],[\"箱子\",{\"0\":{\"145\":1},\"1\":{\"0\":1,\"145\":1}}],[\"遍历就被终止\",{\"1\":{\"65\":1}}],[\"遍历\",{\"0\":{\"63\":1},\"1\":{\"0\":1,\"186\":1}}],[\"装箱\",{\"0\":{\"207\":1},\"1\":{\"0\":1,\"207\":2}}],[\"中解构\",{\"1\":{\"304\":1}}],[\"中解构出\",{\"1\":{\"76\":1}}],[\"中你无需面对并行处理的很多传统难题\",{\"1\":{\"293\":1}}],[\"中以允许匹配错误\",{\"1\":{\"290\":1}}],[\"中间函数\",{\"1\":{\"286\":1}}],[\"中呀\",{\"1\":{\"285\":1}}],[\"中移走\",{\"1\":{\"282\":1}}],[\"中任一个的周期\",{\"1\":{\"266\":1}}],[\"中作为输出类型\",{\"1\":{\"246\":1}}],[\"中显式地指出所有的泛型类型\",{\"1\":{\"244\":1}}],[\"中生存\",{\"1\":{\"199\":1}}],[\"中所有整型转换都是定义良好的\",{\"1\":{\"193\":1}}],[\"中关于\",{\"1\":{\"182\":1}}],[\"中关于测试的章节\",{\"1\":{\"29\":1}}],[\"中获取选定的年龄\",{\"1\":{\"181\":1}}],[\"中获取选定的用户名\",{\"1\":{\"181\":1}}],[\"中展开它\",{\"1\":{\"171\":1}}],[\"中并返回\",{\"1\":{\"151\":1}}],[\"中取得堆分配的内存的所有权\",{\"1\":{\"140\":1}}],[\"中取出\",{\"0\":{\"210\":1},\"1\":{\"0\":1}}],[\"中数据的引用\",{\"1\":{\"138\":1}}],[\"中可见\",{\"1\":{\"133\":1}}],[\"中定义的\",{\"1\":{\"195\":1}}],[\"中定义的其他方法\",{\"1\":{\"30\":1}}],[\"中定义此函数\",{\"1\":{\"173\":1}}],[\"中定义宏\",{\"1\":{\"115\":1}}],[\"中指定一个整数确定将替换哪个附加参数\",{\"1\":{\"107\":1}}],[\"中指定它\",{\"1\":{\"41\":1}}],[\"中有两种字符串类型\",{\"1\":{\"152\":1}}],[\"中有个叫做\",{\"1\":{\"68\":1}}],[\"中有多种处理错误的方式\",{\"1\":{\"7\":1}}],[\"中保存着\",{\"1\":{\"66\":1}}],[\"中来的\",{\"1\":{\"60\":1}}],[\"中稳定下来\",{\"1\":{\"58\":1}}],[\"中也合法\",{\"1\":{\"57\":1}}],[\"中合法的取值在\",{\"1\":{\"57\":1}}],[\"中访问常量\",{\"1\":{\"55\":1}}],[\"中起着重要作用\",{\"1\":{\"15\":1,\"23\":1}}],[\"中文意思是\",{\"1\":{\"68\":1}}],[\"中文资源的开源组织发展离不开大家\",{\"1\":{\"15\":1}}],[\"中文版最后更新时间\",{\"1\":{\"15\":1}}],[\"中文版\",{\"1\":{\"15\":1}}],[\"中文翻译注\",{\"1\":{\"15\":1}}],[\"中文有\",{\"1\":{\"5\":1}}],[\"中的任何\",{\"1\":{\"270\":1}}],[\"中的任何地方访问\",{\"1\":{\"133\":1}}],[\"中的所有引用都必须比\",{\"1\":{\"270\":1}}],[\"中的所有引用都必须比生命周期\",{\"1\":{\"270\":1}}],[\"中的所有方法\",{\"1\":{\"30\":1}}],[\"中的哪种\",{\"1\":{\"233\":1}}],[\"中的一种捕获方式\",{\"1\":{\"240\":1}}],[\"中的一种来指定的\",{\"1\":{\"240\":1}}],[\"中的一种\",{\"1\":{\"233\":1}}],[\"中的一个\",{\"1\":{\"68\":1}}],[\"中的结果\",{\"1\":{\"151\":1}}],[\"中的数据复制到\",{\"1\":{\"145\":1}}],[\"中的析构函数概念是通过\",{\"1\":{\"142\":1}}],[\"中的内存\",{\"1\":{\"141\":1}}],[\"中的借用检查器\",{\"1\":{\"139\":1}}],[\"中的方法签名中就可以使用这些占位符类型\",{\"1\":{\"87\":1}}],[\"中的闭包\",{\"1\":{\"83\":1}}],[\"中的关于测试的章节\",{\"1\":{\"45\":1}}],[\"中的编译单元\",{\"1\":{\"15\":1}}],[\"中的\",{\"1\":{\"11\":1,\"187\":1,\"270\":1,\"284\":1,\"298\":1}}],[\"中的例子\",{\"0\":{\"237\":1},\"1\":{\"0\":1}}],[\"中\",{\"1\":{\"11\":1,\"32\":2,\"91\":1,\"125\":1,\"145\":1,\"154\":1,\"187\":1,\"228\":1,\"233\":1,\"251\":1,\"254\":1,\"285\":1}}],[\"中一定有值\",{\"1\":{\"7\":1}}],[\"给一个友好的问候\",{\"1\":{\"118\":1}}],[\"给类型取别名\",{\"1\":{\"31\":1}}],[\"给\",{\"0\":{\"223\":1},\"1\":{\"0\":1,\"85\":1,\"166\":1,\"279\":1}}],[\"的简写\",{\"1\":{\"306\":1}}],[\"的简单实现\",{\"1\":{\"161\":3}}],[\"的右边已经是一个引用\",{\"1\":{\"298\":1}}],[\"的形式返回\",{\"1\":{\"293\":1}}],[\"的元素类型实现了\",{\"1\":{\"285\":1}}],[\"的独特之处在于\",{\"1\":{\"285\":1}}],[\"的封装\",{\"1\":{\"285\":1}}],[\"的细节内容\",{\"1\":{\"284\":1}}],[\"的键\",{\"1\":{\"284\":1}}],[\"的键可以是布尔型\",{\"1\":{\"146\":1}}],[\"的部分\",{\"1\":{\"282\":1}}],[\"的存活时间\",{\"1\":{\"268\":1}}],[\"的输入引用\",{\"1\":{\"268\":1}}],[\"的输出进行比较\",{\"1\":{\"256\":1}}],[\"的输出\",{\"1\":{\"166\":1}}],[\"的输出仍显得不太有意义\",{\"1\":{\"68\":1}}],[\"的长\",{\"1\":{\"266\":1}}],[\"的长度只要小于该容量\",{\"1\":{\"154\":1}}],[\"的长度\",{\"1\":{\"154\":1,\"205\":1}}],[\"的短\",{\"1\":{\"266\":1}}],[\"的周期\",{\"1\":{\"266\":1}}],[\"的周期没有关联\",{\"1\":{\"139\":1}}],[\"的情况\",{\"1\":{\"268\":1}}],[\"的情况下\",{\"1\":{\"266\":1}}],[\"的情形\",{\"1\":{\"7\":1}}],[\"的可变拷贝\",{\"1\":{\"261\":1,\"263\":1}}],[\"的可能性的情况\",{\"1\":{\"68\":1}}],[\"的不可变的\",{\"1\":{\"261\":1}}],[\"的不可变引用\",{\"1\":{\"235\":1}}],[\"的效果可能比\",{\"1\":{\"256\":1}}],[\"的用法和\",{\"1\":{\"256\":1}}],[\"的第一个元素写入到给定的输出流\",{\"1\":{\"256\":1}}],[\"的第一次使用\",{\"1\":{\"11\":1}}],[\"的格式化打印\",{\"1\":{\"254\":1}}],[\"的默认值\",{\"1\":{\"249\":1}}],[\"的定义语法如下\",{\"1\":{\"246\":1}}],[\"的全部泛型类型\",{\"1\":{\"244\":1}}],[\"的全部或部分引用\",{\"1\":{\"152\":1}}],[\"的使用者必须指出\",{\"1\":{\"244\":1}}],[\"的闭包作为参数\",{\"1\":{\"240\":1}}],[\"的闭包\",{\"1\":{\"240\":3}}],[\"的要求没那么严格\",{\"1\":{\"235\":1}}],[\"的更多用法\",{\"1\":{\"222\":1}}],[\"的话\",{\"1\":{\"222\":1}}],[\"的错误处理都在强迫我们一层层地嵌套\",{\"1\":{\"221\":1}}],[\"的错误类型中\",{\"1\":{\"213\":1}}],[\"的结合\",{\"1\":{\"220\":1}}],[\"的结构体\",{\"1\":{\"164\":1,\"184\":1,\"254\":1,\"257\":1,\"310\":1}}],[\"的转换\",{\"1\":{\"207\":1,\"213\":1}}],[\"的空列表\",{\"1\":{\"205\":1}}],[\"的完整名称是\",{\"1\":{\"205\":1}}],[\"的逻辑单元\",{\"1\":{\"195\":1}}],[\"的方式如下\",{\"1\":{\"296\":1}}],[\"的方式把变量传给函数\",{\"1\":{\"195\":1}}],[\"的方法\",{\"1\":{\"70\":1,\"89\":1,\"181\":2,\"186\":1,\"286\":1}}],[\"的向量了\",{\"1\":{\"194\":1}}],[\"的具体类型\",{\"1\":{\"194\":1}}],[\"的二进制补码是\",{\"1\":{\"193\":1}}],[\"的范围内\",{\"1\":{\"193\":2}}],[\"的新名字\",{\"1\":{\"191\":1}}],[\"的新选项卡中打开了代码示例\",{\"1\":{\"126\":1}}],[\"的父\",{\"1\":{\"189\":1}}],[\"的超集\",{\"1\":{\"189\":1}}],[\"的功能\",{\"1\":{\"187\":1,\"254\":1}}],[\"的一个问题是不能控制输出的形式\",{\"1\":{\"254\":1}}],[\"的一个可用的方法\",{\"1\":{\"217\":1}}],[\"的一个常见用法就是创建链表\",{\"1\":{\"205\":1}}],[\"的一部分\",{\"1\":{\"187\":1}}],[\"的一系列值\",{\"1\":{\"72\":1}}],[\"的前\",{\"1\":{\"186\":1}}],[\"的前面\",{\"1\":{\"103\":1}}],[\"的下一个值\",{\"1\":{\"186\":1}}],[\"的主要作用是释放实现者的实例拥有的资源\",{\"1\":{\"183\":1}}],[\"的章节\",{\"1\":{\"182\":1}}],[\"的表达式后面\",{\"1\":{\"286\":1}}],[\"的表单\",{\"1\":{\"181\":1}}],[\"的表示\",{\"1\":{\"118\":1}}],[\"的基本实现\",{\"1\":{\"179\":1}}],[\"的基本形式如下\",{\"1\":{\"107\":1}}],[\"的程序那样\",{\"1\":{\"173\":1}}],[\"的公共接口\",{\"1\":{\"173\":1}}],[\"的别名\",{\"1\":{\"160\":1,\"163\":1}}],[\"的消息的类型\",{\"1\":{\"158\":1}}],[\"的最佳实践\",{\"1\":{\"157\":1}}],[\"的最后一个元素并将它返回\",{\"1\":{\"154\":1}}],[\"的同时\",{\"1\":{\"154\":1}}],[\"的当前大小\",{\"1\":{\"154\":1}}],[\"的尾部插入一个新的元素\",{\"1\":{\"154\":1}}],[\"的数目没有限制\",{\"1\":{\"153\":1}}],[\"的重新实现\",{\"1\":{\"148\":1}}],[\"的整数除法\",{\"1\":{\"147\":1}}],[\"的整数相加\",{\"1\":{\"21\":1}}],[\"的散列表词条\",{\"1\":{\"146\":1}}],[\"的工作原理\",{\"1\":{\"146\":1}}],[\"的其他类型\",{\"1\":{\"146\":1}}],[\"的其他用法\",{\"0\":{\"211\":1},\"1\":{\"0\":1}}],[\"的宽度就是指针宽度\",{\"1\":{\"145\":1}}],[\"的宽度和\",{\"1\":{\"134\":1}}],[\"的变量不只是在栈中保存数据\",{\"1\":{\"141\":1}}],[\"的指针地址\",{\"1\":{\"140\":1}}],[\"的产生\",{\"1\":{\"140\":1}}],[\"的时候\",{\"1\":{\"140\":1,\"210\":1}}],[\"的时候才会编译\",{\"1\":{\"36\":1}}],[\"的生命周期\",{\"1\":{\"275\":1}}],[\"的生命周期会赋给所有的输出生命周期参数\",{\"1\":{\"273\":1}}],[\"的生命周期会被编译器自动添加\",{\"1\":{\"264\":1}}],[\"的生命周期也不能超出\",{\"1\":{\"270\":1}}],[\"的生命周期都必须比\",{\"1\":{\"266\":1}}],[\"的生命周期不够长\",{\"1\":{\"266\":1}}],[\"的生命周期不能超出\",{\"1\":{\"266\":2}}],[\"的生命周期最长\",{\"1\":{\"139\":1}}],[\"的生态链标配\",{\"1\":{\"44\":1}}],[\"的引用强制转换成\",{\"1\":{\"275\":1}}],[\"的引用计数变为\",{\"1\":{\"149\":1}}],[\"的引用计数就会增加\",{\"1\":{\"149\":1}}],[\"的引用\",{\"1\":{\"138\":1,\"205\":1,\"266\":1,\"270\":2,\"275\":1,\"277\":1,\"298\":1,\"310\":1}}],[\"的练习中要用到下面这个结构体\",{\"1\":{\"136\":1}}],[\"的值\",{\"1\":{\"136\":1,\"256\":1,\"263\":1}}],[\"的对象的集合\",{\"1\":{\"134\":1}}],[\"的遮蔽只存在这个代码块中\",{\"1\":{\"132\":1}}],[\"的模块\",{\"1\":{\"133\":1}}],[\"的模块里面\",{\"1\":{\"128\":1}}],[\"的模式\",{\"1\":{\"116\":1}}],[\"的文件\",{\"1\":{\"128\":1}}],[\"的文档\",{\"1\":{\"120\":2}}],[\"的内容之后可以再次借用\",{\"1\":{\"138\":1}}],[\"的内容\",{\"1\":{\"128\":4,\"138\":1,\"152\":1,\"281\":1}}],[\"的按钮\",{\"1\":{\"126\":1}}],[\"的作用刚刚已经介绍了\",{\"1\":{\"266\":1}}],[\"的作用\",{\"1\":{\"263\":1}}],[\"的作用类似于匹配\",{\"1\":{\"113\":1}}],[\"的作用事实上很有限\",{\"1\":{\"38\":1}}],[\"的关键字\",{\"1\":{\"112\":1}}],[\"的宏中集成的微型\",{\"1\":{\"112\":1}}],[\"的宏会展开为抽象语法树\",{\"1\":{\"16\":1}}],[\"的缩写\",{\"1\":{\"111\":1}}],[\"的代码如下\",{\"1\":{\"249\":1}}],[\"的代码\",{\"1\":{\"111\":1}}],[\"的近似值\",{\"1\":{\"108\":1}}],[\"的必须是\",{\"1\":{\"99\":1}}],[\"的泛型\",{\"1\":{\"93\":1}}],[\"的泛型函数\",{\"1\":{\"91\":1}}],[\"的参数\",{\"1\":{\"89\":1,\"215\":1}}],[\"的说法\",{\"1\":{\"87\":1,\"140\":1}}],[\"的语法糖\",{\"1\":{\"86\":3}}],[\"的写法\",{\"1\":{\"85\":1}}],[\"的返回类型\",{\"1\":{\"84\":1}}],[\"的分支中所写的类型不同\",{\"1\":{\"73\":1}}],[\"的非官方吉祥物\",{\"1\":{\"73\":1}}],[\"的枚举类型\",{\"1\":{\"68\":1}}],[\"的两个实例生成了不同的错误类型\",{\"1\":{\"67\":1}}],[\"的所有方法都返回\",{\"1\":{\"160\":1}}],[\"的所有方法都在这里给出\",{\"1\":{\"86\":1}}],[\"的所有权概念与别名规则结合起来\",{\"1\":{\"293\":1}}],[\"的所有权\",{\"1\":{\"158\":1,\"205\":1}}],[\"的所有权并销毁它\",{\"1\":{\"138\":1}}],[\"的所有结果\",{\"1\":{\"64\":1}}],[\"的所有可用配置选项都列在\",{\"1\":{\"44\":1}}],[\"的字段\",{\"1\":{\"60\":2,\"263\":1}}],[\"的是\",{\"1\":{\"52\":1}}],[\"的例子\",{\"1\":{\"50\":1,\"121\":1,\"137\":1}}],[\"的实现后\",{\"1\":{\"251\":1}}],[\"的实现者使用\",{\"1\":{\"187\":1}}],[\"的实现会指定在\",{\"1\":{\"87\":1}}],[\"的实现\",{\"1\":{\"47\":1,\"213\":1,\"254\":1}}],[\"的实例可以使用\",{\"1\":{\"30\":1}}],[\"的配置文件\",{\"1\":{\"44\":1}}],[\"的先决条件\",{\"1\":{\"42\":1}}],[\"的函数就不需要写出\",{\"1\":{\"246\":1}}],[\"的函数作为\",{\"1\":{\"215\":1}}],[\"的函数\",{\"1\":{\"40\":1,\"84\":1,\"110\":2,\"131\":1,\"184\":1}}],[\"的函数定义位置是没有限制的\",{\"1\":{\"10\":1}}],[\"的库拥有与新版本中引入的关键字同名的变量或函数\",{\"1\":{\"40\":1}}],[\"的概念\",{\"1\":{\"40\":1}}],[\"的概念和基本库\",{\"1\":{\"15\":1}}],[\"的名称\",{\"1\":{\"38\":1}}],[\"的集合\",{\"1\":{\"18\":1}}],[\"的类型都可以充当\",{\"1\":{\"284\":1}}],[\"的类型有效\",{\"1\":{\"247\":1}}],[\"的类型是\",{\"1\":{\"194\":1,\"195\":1}}],[\"的类型而已\",{\"1\":{\"194\":1}}],[\"的类型推断引擎是很聪明的\",{\"1\":{\"194\":1}}],[\"的类型标记为\",{\"1\":{\"134\":1}}],[\"的类型\",{\"1\":{\"101\":2,\"185\":1,\"207\":1,\"225\":2,\"242\":1,\"249\":1,\"293\":1,\"298\":1}}],[\"的类型实现类似的功能\",{\"1\":{\"16\":1}}],[\"的类型参数也可以隐式地指定\",{\"1\":{\"11\":1}}],[\"的类型参数是显式指定的\",{\"1\":{\"11\":1}}],[\"的演变和潜在的兼容性问题\",{\"1\":{\"15\":1}}],[\"的现代系统编程语言\",{\"1\":{\"15\":1}}],[\"的编译器\",{\"1\":{\"13\":1}}],[\"的编译单元\",{\"1\":{\"5\":1}}],[\"的任何参数\",{\"1\":{\"11\":1}}],[\"的任何内容\",{\"1\":{\"11\":1}}],[\"的好方法\",{\"1\":{\"7\":1}}],[\"的选项\",{\"1\":{\"5\":1}}],[\"的\",{\"0\":{\"225\":1},\"1\":{\"0\":1,\"11\":1,\"44\":2,\"54\":1,\"59\":1,\"72\":1,\"89\":1,\"95\":3,\"101\":1,\"126\":1,\"139\":1,\"164\":2,\"168\":1,\"173\":1,\"174\":1,\"181\":1,\"184\":3,\"190\":1,\"201\":2,\"205\":1,\"215\":1,\"220\":1,\"221\":1,\"223\":1,\"225\":1,\"233\":1,\"240\":1,\"254\":1,\"256\":1,\"263\":2,\"266\":1,\"275\":1,\"289\":1,\"291\":1,\"306\":2,\"308\":2}}],[\"结合这些模式\",{\"1\":{\"300\":1}}],[\"结合以创建可变引用\",{\"1\":{\"263\":1}}],[\"结束时\",{\"1\":{\"186\":1}}],[\"结构会使用\",{\"1\":{\"186\":1}}],[\"结构读作\",{\"1\":{\"76\":1}}],[\"结构能以几种方式与\",{\"1\":{\"73\":1}}],[\"结构可以遍历一个\",{\"1\":{\"72\":1}}],[\"结构体代表了一个正在运行的子进程\",{\"1\":{\"291\":1}}],[\"结构体代表了底层文件系统的文件路径\",{\"1\":{\"164\":1}}],[\"结构体增加一个名为\",{\"1\":{\"257\":1}}],[\"结构体实现\",{\"1\":{\"252\":1}}],[\"结构体是一个进程创建者\",{\"1\":{\"166\":1}}],[\"结构体表示已结束的子进程\",{\"1\":{\"166\":1}}],[\"结构体表示一个被打开的文件\",{\"1\":{\"160\":1,\"163\":1}}],[\"结构体类型\",{\"1\":{\"164\":1}}],[\"结构体的字段也是一个可见性的层次\",{\"1\":{\"129\":1}}],[\"结构体的实例化也是一个表达式\",{\"1\":{\"60\":1}}],[\"结构体的可见性\",{\"0\":{\"129\":1},\"1\":{\"0\":1}}],[\"结构体可以作为另一个结构体的字段\",{\"1\":{\"60\":1}}],[\"结构体\",{\"0\":{\"60\":1,\"277\":1,\"302\":1},\"1\":{\"0\":3,\"15\":1,\"18\":1,\"60\":1,\"102\":1,\"137\":1,\"249\":1,\"278\":1,\"303\":1}}],[\"结果表明操作成功或失败\",{\"1\":{\"256\":1}}],[\"结果表明\",{\"1\":{\"225\":1}}],[\"结果就和\",{\"1\":{\"193\":1}}],[\"结果是不是我们所期望的\",{\"1\":{\"174\":1}}],[\"结果\",{\"0\":{\"70\":1,\"151\":1},\"1\":{\"0\":2,\"147\":1}}],[\"解析命令\",{\"1\":{\"287\":1}}],[\"解析数字\",{\"1\":{\"287\":1}}],[\"解析字符串\",{\"0\":{\"51\":1}}],[\"解包\",{\"1\":{\"147\":2}}],[\"解引用使用\",{\"1\":{\"298\":1}}],[\"解引用一个裸指针只能通过不安全代码块执行\",{\"1\":{\"33\":1}}],[\"解引用裸指针\",{\"1\":{\"32\":1}}],[\"解决类型之间的转换问题\",{\"1\":{\"4\":1}}],[\"解开\",{\"0\":{\"219\":1},\"1\":{\"0\":1}}],[\"解构出第二个和第三个元素\",{\"1\":{\"304\":1}}],[\"解构使用\",{\"1\":{\"298\":1}}],[\"解构赋值\",{\"1\":{\"293\":1}}],[\"解构结构体的成员\",{\"1\":{\"302\":1}}],[\"解构结构体\",{\"1\":{\"230\":1}}],[\"解构失败\",{\"1\":{\"76\":2}}],[\"解构成功\",{\"1\":{\"81\":1}}],[\"解构成\",{\"1\":{\"76\":1,\"81\":1,\"308\":2}}],[\"解构一个元组结构体\",{\"1\":{\"60\":1}}],[\"解构给\",{\"1\":{\"57\":1}}],[\"解构\",{\"0\":{\"230\":1},\"1\":{\"0\":1,\"62\":1,\"86\":1,\"228\":1,\"263\":1,\"283\":1,\"295\":1,\"296\":1,\"298\":1,\"302\":1}}],[\"ullamco\",{\"1\":{\"288\":2}}],[\"ut\",{\"1\":{\"288\":6}}],[\"utf8\",{\"1\":{\"153\":2,\"166\":2}}],[\"utf\",{\"1\":{\"152\":2,\"153\":3,\"164\":2}}],[\"u+211d\",{\"1\":{\"153\":1}}],[\"url\",{\"1\":{\"126\":1}}],[\"u\",{\"1\":{\"93\":1,\"97\":5,\"153\":4,\"185\":4}}],[\"u>\",{\"1\":{\"93\":1}}],[\"updated\",{\"1\":{\"154\":1}}],[\"upper\",{\"1\":{\"85\":3}}],[\"up\",{\"1\":{\"84\":3,\"146\":1,\"167\":1}}],[\"usage\",{\"1\":{\"141\":1,\"148\":1,\"287\":3}}],[\"using\",{\"1\":{\"141\":1,\"148\":1,\"186\":1}}],[\"usize\",{\"1\":{\"20\":1,\"107\":1,\"112\":1,\"116\":1,\"134\":1,\"158\":1,\"191\":1}}],[\"us\",{\"1\":{\"73\":3}}],[\"username\",{\"1\":{\"181\":5,\"189\":3,\"256\":1,\"284\":7}}],[\"usernamewidget>\",{\"1\":{\"181\":1}}],[\"usernamewidget\",{\"1\":{\"181\":3}}],[\"used\",{\"1\":{\"39\":2,\"42\":1,\"152\":1,\"209\":1}}],[\"use\",{\"0\":{\"132\":1,\"203\":1},\"1\":{\"0\":2,\"34\":1,\"47\":1,\"48\":1,\"50\":2,\"52\":2,\"89\":1,\"97\":1,\"101\":1,\"103\":1,\"111\":2,\"118\":1,\"120\":1,\"121\":1,\"122\":1,\"131\":1,\"132\":3,\"134\":1,\"141\":1,\"144\":2,\"145\":1,\"146\":1,\"148\":1,\"149\":1,\"153\":2,\"156\":1,\"158\":3,\"159\":1,\"161\":6,\"164\":1,\"166\":1,\"167\":1,\"168\":2,\"174\":1,\"175\":1,\"177\":1,\"185\":2,\"187\":1,\"203\":3,\"204\":1,\"205\":1,\"207\":2,\"209\":3,\"210\":2,\"211\":2,\"213\":4,\"220\":1,\"221\":1,\"222\":1,\"223\":1,\"225\":2,\"235\":1,\"240\":1,\"249\":2,\"251\":1,\"256\":2,\"258\":1,\"270\":1,\"284\":1,\"285\":1,\"287\":1,\"288\":3,\"289\":3,\"290\":3,\"291\":2,\"292\":1,\"293\":1,\"310\":1}}],[\"u128\",{\"1\":{\"20\":1}}],[\"u16\",{\"1\":{\"20\":1,\"193\":3}}],[\"u64\",{\"1\":{\"20\":1,\"191\":6}}],[\"u8\",{\"1\":{\"20\":1,\"60\":1,\"152\":1,\"153\":2,\"181\":3,\"193\":10,\"194\":2,\"219\":1,\"251\":3,\"254\":1,\"282\":1}}],[\"u32\",{\"1\":{\"10\":4,\"20\":1,\"33\":1,\"34\":1,\"76\":1,\"84\":6,\"85\":2,\"135\":1,\"175\":3,\"186\":3,\"205\":3,\"219\":1,\"228\":1,\"261\":1,\"293\":4,\"296\":16,\"302\":3}}],[\"unprintable\",{\"1\":{\"254\":1}}],[\"unreachable\",{\"1\":{\"226\":1}}],[\"unboxed\",{\"1\":{\"145\":3}}],[\"underlying\",{\"1\":{\"163\":1}}],[\"under\",{\"1\":{\"85\":1}}],[\"undefined\",{\"1\":{\"34\":1,\"196\":1}}],[\"until\",{\"1\":{\"78\":1}}],[\"unwind\",{\"1\":{\"69\":1,\"148\":1}}],[\"unwraps\",{\"1\":{\"147\":2}}],[\"unwrap\",{\"0\":{\"68\":1,\"339\":1},\"1\":{\"0\":1,\"7\":2,\"51\":2,\"66\":2,\"67\":3,\"68\":3,\"70\":4,\"147\":2,\"158\":1,\"161\":7,\"166\":1,\"171\":1,\"186\":1,\"211\":3,\"220\":1,\"221\":3,\"291\":2,\"292\":2,\"293\":1}}],[\"unload\",{\"1\":{\"57\":2}}],[\"unloaded\",{\"1\":{\"57\":1}}],[\"unoptimized\",{\"1\":{\"45\":2}}],[\"unused\",{\"1\":{\"35\":2,\"39\":2}}],[\"unsafe\",{\"1\":{\"33\":1,\"34\":2,\"159\":2}}],[\"unsigned\",{\"1\":{\"20\":1}}],[\"union\",{\"1\":{\"285\":3}}],[\"university\",{\"1\":{\"189\":2}}],[\"unix\",{\"1\":{\"161\":3,\"164\":1}}],[\"unit\",{\"1\":{\"20\":1,\"28\":1,\"35\":3,\"60\":4,\"146\":1,\"171\":1,\"191\":1,\"284\":1}}],[\"unicode\",{\"1\":{\"20\":1,\"153\":5}}],[\"unimplemented\",{\"1\":{\"7\":1}}],[\"领域专用语言\",{\"0\":{\"112\":1},\"1\":{\"0\":1,\"16\":1}}],[\"重写后\",{\"1\":{\"211\":1}}],[\"重写之前的例子\",{\"1\":{\"211\":1}}],[\"重新分配一段更大的容量\",{\"1\":{\"154\":1}}],[\"重复之前的例子\",{\"1\":{\"193\":1}}],[\"重复运行这个测试\",{\"1\":{\"81\":1}}],[\"重复\",{\"0\":{\"114\":1},\"1\":{\"0\":1,\"115\":1}}],[\"重载\",{\"0\":{\"113\":1},\"1\":{\"0\":1,\"5\":1}}],[\"指明了被捕获变量的类型\",{\"1\":{\"308\":1}}],[\"指明为该结构体实现的是\",{\"1\":{\"233\":1}}],[\"指出\",{\"1\":{\"246\":1}}],[\"指出每种情况下的做法\",{\"1\":{\"68\":1}}],[\"指导原则中关于文档的原则\",{\"1\":{\"172\":1}}],[\"指导原则中关于文档测试的部分\",{\"1\":{\"29\":1}}],[\"指向堆分配的\",{\"1\":{\"145\":1}}],[\"指定为\",{\"1\":{\"244\":1}}],[\"指定为上面定义的\",{\"1\":{\"95\":1}}],[\"指定\",{\"1\":{\"95\":2,\"249\":1}}],[\"指定字面量的类型\",{\"1\":{\"31\":1}}],[\"指与多种类型的项有关的一组规则\",{\"1\":{\"87\":1}}],[\"指那些输入一个或多个函数\",{\"1\":{\"85\":1}}],[\"指构建一个软件系统所使用的全部代码\",{\"1\":{\"32\":1}}],[\"指针\",{\"1\":{\"184\":1}}],[\"指针宽度\",{\"1\":{\"20\":2}}],[\"指针和引用\",{\"0\":{\"298\":1},\"1\":{\"0\":1}}],[\"指示符表示运算符和标记\",{\"1\":{\"111\":1}}],[\"指示符表示表达式\",{\"1\":{\"110\":1}}],[\"指示符表示的参数\",{\"1\":{\"110\":1}}],[\"指示符用于变量名或函数名\",{\"1\":{\"110\":1}}],[\"指示符\",{\"0\":{\"110\":1},\"1\":{\"0\":1}}],[\"父级\",{\"1\":{\"131\":1,\"190\":1}}],[\"父目录时\",{\"1\":{\"7\":1}}],[\"父\",{\"0\":{\"189\":1},\"1\":{\"0\":1}}],[\"返回相应的错误\",{\"1\":{\"310\":1}}],[\"返回无符号\",{\"1\":{\"293\":1}}],[\"返回新线程的句柄\",{\"1\":{\"293\":1}}],[\"返回传递进来的引用也是可行的\",{\"1\":{\"268\":1}}],[\"返回闭包的有效特征是\",{\"1\":{\"242\":1}}],[\"返回结果\",{\"1\":{\"228\":1}}],[\"返回它\",{\"1\":{\"221\":1}}],[\"返回列表的字符串表示\",{\"1\":{\"205\":1}}],[\"返回被\",{\"1\":{\"186\":1}}],[\"返回使用\",{\"1\":{\"185\":1}}],[\"返回一些实现\",{\"1\":{\"184\":1}}],[\"返回一个指向\",{\"1\":{\"275\":1}}],[\"返回一个指向无效数据的引用\",{\"1\":{\"268\":1}}],[\"返回一个含有和的新的\",{\"1\":{\"249\":1}}],[\"返回一个变量所占的字节数\",{\"1\":{\"195\":1}}],[\"返回一个斐波那契数列生成器\",{\"1\":{\"186\":1}}],[\"返回一个将输入和\",{\"1\":{\"185\":1}}],[\"返回一个结果\",{\"1\":{\"167\":1}}],[\"返回一个迭代器\",{\"1\":{\"146\":1}}],[\"返回一个result\",{\"1\":{\"70\":1}}],[\"返回一个\",{\"1\":{\"67\":1,\"83\":1,\"228\":1,\"240\":1,\"263\":1,\"290\":1}}],[\"返回一个option\",{\"1\":{\"67\":1}}],[\"返回包装在\",{\"1\":{\"151\":1}}],[\"返回数组的大小\",{\"1\":{\"134\":1}}],[\"返回具有指定名字的一个人\",{\"1\":{\"118\":1}}],[\"返回引用的函数\",{\"1\":{\"96\":1}}],[\"返回调用者的绝对值\",{\"1\":{\"86\":1}}],[\"返回类型为\",{\"1\":{\"186\":1}}],[\"返回类型是自动推导的\",{\"1\":{\"83\":1}}],[\"返回类型必须在箭头\",{\"1\":{\"10\":1}}],[\"返回值的函数\",{\"1\":{\"10\":1}}],[\"返回\",{\"0\":{\"184\":1},\"1\":{\"0\":1,\"146\":1,\"161\":6,\"171\":1,\"186\":2,\"205\":1,\"256\":1,\"285\":1,\"288\":2,\"289\":2}}],[\"派生\",{\"0\":{\"179\":1},\"1\":{\"0\":1}}],[\"省略\",{\"0\":{\"264\":1},\"1\":{\"0\":1,\"265\":1,\"266\":1}}],[\"显得很麻烦\",{\"1\":{\"244\":1}}],[\"显式地要求\",{\"1\":{\"244\":1}}],[\"显式地\",{\"1\":{\"203\":1}}],[\"显式地指定类型参数\",{\"1\":{\"91\":1}}],[\"显式地接受了类型参量\",{\"1\":{\"91\":1}}],[\"显式地接受了类型参数\",{\"1\":{\"91\":1}}],[\"显式地处理\",{\"1\":{\"68\":1}}],[\"显式处理将举出更受控制的结果\",{\"1\":{\"68\":1}}],[\"显式的\",{\"1\":{\"7\":1}}],[\"显式标注\",{\"0\":{\"266\":1},\"1\":{\"0\":1}}],[\"显示帮助信息\",{\"1\":{\"287\":1}}],[\"显示链表的最后状态\",{\"1\":{\"205\":1}}],[\"显示消息被发送的次序\",{\"1\":{\"158\":1}}],[\"显示\",{\"0\":{\"256\":1},\"1\":{\"0\":1}}],[\"模棱两可的类型该如何显示呢\",{\"1\":{\"256\":1}}],[\"模式中没有提及\",{\"1\":{\"302\":1}}],[\"模式绑定\",{\"1\":{\"282\":1}}],[\"模式pattern\",{\"1\":{\"110\":1}}],[\"模式\",{\"0\":{\"263\":1},\"1\":{\"0\":1,\"299\":1,\"303\":1}}],[\"模块使\",{\"1\":{\"256\":1}}],[\"模块又是在\",{\"1\":{\"195\":1}}],[\"模块包含几个处理文件系统的函数\",{\"1\":{\"161\":1}}],[\"模块的私有项不能直接访问\",{\"1\":{\"133\":1}}],[\"模块机制消除了相同名字的项之间的歧义\",{\"1\":{\"133\":1}}],[\"模块也可以嵌套\",{\"1\":{\"133\":1}}],[\"模块中定义的\",{\"1\":{\"195\":1}}],[\"模块中\",{\"1\":{\"174\":1}}],[\"模块中找到\",{\"1\":{\"152\":1,\"154\":1}}],[\"模块中的项默认具有私有的可见性\",{\"1\":{\"133\":1}}],[\"模块中的项拥有私有的可见性\",{\"1\":{\"133\":1}}],[\"模块中只有公有的\",{\"1\":{\"133\":1}}],[\"模块外面\",{\"1\":{\"131\":1}}],[\"模块可以分配到文件\",{\"1\":{\"128\":1}}],[\"模块或函数\",{\"1\":{\"105\":1}}],[\"模块是项\",{\"1\":{\"18\":1}}],[\"模块不会单独被编译\",{\"1\":{\"5\":1}}],[\"模块\",{\"0\":{\"18\":1},\"1\":{\"0\":1,\"15\":1,\"18\":1,\"310\":1}}],[\"r`\",{\"1\":{\"298\":1}}],[\"rgb\",{\"1\":{\"252\":3,\"296\":3}}],[\"rich\",{\"1\":{\"203\":4}}],[\"right\",{\"1\":{\"60\":7,\"174\":4}}],[\"rx\",{\"1\":{\"158\":2}}],[\"roses\",{\"1\":{\"201\":1}}],[\"robust\",{\"1\":{\"225\":1}}],[\"robert\",{\"1\":{\"146\":1}}],[\"robin\",{\"1\":{\"68\":1}}],[\"root\",{\"1\":{\"131\":2,\"159\":1,\"286\":1}}],[\"roughly\",{\"1\":{\"108\":1}}],[\"rfc505\",{\"1\":{\"172\":1}}],[\"rfc\",{\"1\":{\"56\":1,\"59\":1,\"77\":1,\"82\":1,\"87\":1,\"88\":1,\"104\":1}}],[\"r\",{\"1\":{\"40\":1,\"153\":4,\"194\":1,\"210\":1,\"296\":2,\"298\":3}}],[\"rlib\",{\"1\":{\"38\":1,\"53\":1,\"54\":2,\"118\":1}}],[\"race\",{\"1\":{\"293\":1}}],[\"range\",{\"1\":{\"256\":5}}],[\"randomly\",{\"1\":{\"184\":1}}],[\"random\",{\"1\":{\"184\":6}}],[\"rand\",{\"1\":{\"44\":2}}],[\"ratio\",{\"1\":{\"151\":2,\"286\":2}}],[\"radius\",{\"1\":{\"50\":8}}],[\"rary=library\",{\"1\":{\"54\":1}}],[\"rary\",{\"1\":{\"38\":5,\"53\":4,\"54\":7}}],[\"raw\",{\"1\":{\"33\":3,\"34\":3,\"153\":7}}],[\"raii\",{\"0\":{\"141\":1},\"1\":{\"0\":1,\"141\":5}}],[\"rbe\",{\"1\":{\"15\":1}}],[\"rhs\",{\"1\":{\"10\":3,\"187\":3,\"249\":7}}],[\"rs`\",{\"1\":{\"128\":4}}],[\"rs\",{\"1\":{\"5\":3,\"13\":1,\"38\":1,\"40\":1,\"41\":3,\"43\":3,\"44\":3,\"45\":3,\"53\":1,\"54\":1,\"111\":1,\"118\":2,\"122\":1,\"128\":9,\"141\":2,\"148\":2,\"161\":1,\"168\":1,\"170\":3,\"173\":5,\"174\":1,\"200\":2,\"288\":1,\"289\":1,\"290\":1,\"292\":1}}],[\"running\",{\"1\":{\"36\":2,\"45\":4,\"111\":1,\"170\":2,\"173\":4,\"174\":1,\"175\":2,\"176\":4,\"177\":4,\"292\":1}}],[\"run\",{\"1\":{\"13\":1,\"14\":1,\"44\":1,\"58\":1,\"126\":1,\"174\":1}}],[\"rustdoc\",{\"1\":{\"17\":1,\"117\":1,\"118\":3,\"119\":1,\"122\":2,\"127\":1}}],[\"rustacean\",{\"1\":{\"14\":1,\"73\":3,\"181\":2}}],[\"rustc\",{\"1\":{\"5\":3,\"13\":3,\"38\":2,\"53\":1,\"54\":2,\"111\":1,\"117\":1,\"118\":1,\"128\":1,\"141\":1,\"148\":1,\"161\":1,\"166\":4,\"200\":4,\"288\":1,\"289\":1,\"290\":1,\"292\":1}}],[\"rust\",{\"0\":{\"15\":1},\"1\":{\"1\":1,\"2\":2,\"3\":1,\"4\":1,\"5\":1,\"6\":1,\"7\":1,\"8\":2,\"9\":1,\"10\":1,\"11\":1,\"13\":1,\"15\":20,\"16\":3,\"18\":1,\"19\":1,\"21\":1,\"28\":2,\"31\":1,\"32\":1,\"35\":1,\"38\":1,\"40\":4,\"42\":1,\"44\":5,\"45\":2,\"54\":1,\"55\":2,\"58\":1,\"68\":1,\"70\":1,\"73\":1,\"75\":1,\"78\":1,\"79\":1,\"83\":2,\"85\":2,\"87\":1,\"105\":1,\"107\":1,\"110\":1,\"112\":3,\"115\":1,\"124\":3,\"126\":2,\"135\":1,\"138\":1,\"140\":1,\"141\":2,\"142\":1,\"145\":1,\"152\":1,\"153\":1,\"157\":1,\"158\":1,\"159\":1,\"164\":1,\"167\":1,\"170\":3,\"173\":1,\"174\":1,\"182\":1,\"184\":2,\"185\":1,\"187\":1,\"189\":1,\"190\":1,\"193\":2,\"194\":1,\"209\":1,\"223\":1,\"225\":1,\"240\":1,\"242\":1,\"254\":1,\"264\":1,\"266\":1,\"272\":1,\"287\":1,\"293\":7,\"298\":1,\"310\":2}}],[\"rules\",{\"0\":{\"16\":1},\"1\":{\"0\":1,\"16\":2,\"110\":2,\"111\":3,\"112\":1,\"113\":2,\"114\":1,\"116\":1}}],[\"rc<string>\",{\"1\":{\"149\":2}}],[\"rc\",{\"0\":{\"149\":1},\"1\":{\"0\":1,\"149\":46,\"150\":1}}],[\"reborrowed\",{\"1\":{\"235\":1}}],[\"reborrow\",{\"1\":{\"235\":2}}],[\"recipe\",{\"1\":{\"215\":3}}],[\"recv\",{\"1\":{\"158\":1}}],[\"receiver<i32>\",{\"1\":{\"158\":1}}],[\"receiver\",{\"1\":{\"158\":2}}],[\"rect\",{\"1\":{\"61\":1}}],[\"rectangle\",{\"1\":{\"60\":3,\"61\":2,\"86\":11,\"89\":6,\"145\":11}}],[\"rev\",{\"1\":{\"152\":1}}],[\"reversed\",{\"1\":{\"136\":1}}],[\"reverse\",{\"1\":{\"136\":2,\"137\":1,\"152\":1}}],[\"remove\",{\"1\":{\"146\":1,\"161\":2}}],[\"re\",{\"1\":{\"146\":1,\"159\":4,\"235\":1}}],[\"rerun\",{\"1\":{\"141\":2,\"148\":2}}],[\"red>\",{\"1\":{\"247\":1}}],[\"red<t\",{\"1\":{\"247\":1}}],[\"red\",{\"1\":{\"201\":2,\"247\":5,\"251\":4,\"296\":4}}],[\"reddit\",{\"1\":{\"123\":2}}],[\"reduce\",{\"0\":{\"293\":1},\"1\":{\"0\":1,\"293\":2}}],[\"reg\",{\"1\":{\"91\":2}}],[\"real\",{\"1\":{\"257\":1}}],[\"really\",{\"1\":{\"76\":1}}],[\"reached\",{\"1\":{\"148\":1,\"226\":1,\"292\":2}}],[\"reader\",{\"1\":{\"290\":1}}],[\"read+write\",{\"1\":{\"288\":1}}],[\"read\",{\"1\":{\"0\":1,\"161\":3,\"163\":1,\"275\":1,\"289\":3,\"290\":5,\"291\":2}}],[\"reprehenderit\",{\"1\":{\"288\":2}}],[\"represents\",{\"1\":{\"163\":1}}],[\"repr\",{\"1\":{\"159\":1}}],[\"replace\",{\"1\":{\"152\":1}}],[\"repetition\",{\"1\":{\"115\":1}}],[\"repeat\",{\"1\":{\"16\":1,\"111\":4}}],[\"report\",{\"1\":{\"58\":1}}],[\"rest\",{\"1\":{\"304\":1}}],[\"responded\",{\"1\":{\"291\":1}}],[\"res\",{\"1\":{\"171\":1}}],[\"resutl<\",{\"1\":{\"161\":1}}],[\"result=\",{\"1\":{\"293\":1}}],[\"result`\",{\"1\":{\"256\":1}}],[\"results\",{\"1\":{\"63\":1,\"64\":1,\"65\":1}}],[\"result<io\",{\"1\":{\"290\":1}}],[\"result<i32>\",{\"1\":{\"207\":2,\"209\":2,\"211\":2,\"213\":2}}],[\"result<i32\",{\"1\":{\"24\":1,\"67\":1,\"171\":1,\"220\":2,\"221\":2,\"222\":2,\"225\":5}}],[\"result<usize>`\",{\"1\":{\"289\":1}}],[\"result<file>`\",{\"1\":{\"288\":1,\"289\":1}}],[\"result<f64\",{\"1\":{\"151\":1,\"286\":1}}],[\"result<option<i32>\",{\"1\":{\"210\":1}}],[\"result<\",{\"1\":{\"161\":6,\"171\":2,\"288\":1}}],[\"result<string>\",{\"1\":{\"161\":2}}],[\"result<self\",{\"1\":{\"52\":1}}],[\"result<t>\",{\"1\":{\"160\":1,\"163\":1,\"207\":1,\"209\":1,\"211\":1,\"213\":1}}],[\"result<t\",{\"1\":{\"67\":1,\"70\":1,\"151\":1,\"160\":1,\"163\":1,\"191\":1,\"207\":1,\"209\":1,\"211\":1,\"213\":1,\"223\":1}}],[\"result<vec<path>>`\",{\"1\":{\"161\":1}}],[\"result<vec<\",{\"1\":{\"65\":1}}],[\"result<vec<t>\",{\"1\":{\"65\":1}}],[\"result<evennumber\",{\"1\":{\"52\":2}}],[\"result\",{\"0\":{\"63\":1,\"70\":1,\"151\":1,\"210\":1,\"223\":1,\"225\":1,\"340\":1,\"352\":1},\"1\":{\"0\":6,\"7\":1,\"45\":2,\"50\":1,\"52\":5,\"65\":2,\"66\":5,\"67\":3,\"70\":4,\"110\":3,\"111\":1,\"147\":1,\"151\":1,\"159\":1,\"170\":6,\"173\":3,\"174\":1,\"175\":8,\"176\":4,\"177\":4,\"207\":4,\"209\":4,\"210\":1,\"211\":5,\"213\":4,\"220\":2,\"221\":2,\"222\":2,\"223\":6,\"224\":1,\"225\":8,\"227\":2,\"251\":1,\"256\":3,\"286\":3,\"290\":1,\"292\":1,\"293\":6,\"310\":4,\"312\":1}}],[\"resource\",{\"1\":{\"141\":2}}],[\"reset\",{\"1\":{\"13\":1}}],[\"returns\",{\"1\":{\"84\":3}}],[\"returning\",{\"1\":{\"83\":1}}],[\"return\",{\"1\":{\"10\":2,\"185\":1,\"211\":2,\"220\":3,\"286\":1,\"287\":1,\"293\":1}}],[\"ref`\",{\"1\":{\"270\":1}}],[\"ref<\",{\"1\":{\"270\":2}}],[\"refs\",{\"1\":{\"266\":1}}],[\"refs<\",{\"1\":{\"266\":1}}],[\"refs`\",{\"1\":{\"266\":3}}],[\"reference\",{\"1\":{\"83\":1,\"110\":1,\"144\":1,\"149\":5,\"195\":1,\"261\":2,\"277\":2,\"282\":1,\"298\":6}}],[\"ref\",{\"0\":{\"263\":1},\"1\":{\"0\":1,\"138\":5,\"205\":2,\"213\":2,\"250\":1,\"263\":16,\"270\":5,\"277\":2,\"282\":1,\"298\":5,\"299\":1,\"303\":1,\"312\":1}}],[\"惯用法\",{\"0\":{\"99\":1},\"1\":{\"0\":1,\"99\":1}}],[\"空约束\",{\"0\":{\"247\":1},\"1\":{\"0\":1}}],[\"约等于\",{\"1\":{\"108\":1}}],[\"约束的工作机制会产生这样的效果\",{\"1\":{\"247\":1}}],[\"约束的闭包\",{\"1\":{\"238\":1}}],[\"约束的封装函数\",{\"1\":{\"238\":1}}],[\"约束的函数都可以作为其参数\",{\"1\":{\"238\":1}}],[\"约束的另一个作用是泛型的实例可以访问作为约束的\",{\"1\":{\"89\":1}}],[\"约束也可以使用\",{\"1\":{\"103\":1}}],[\"约束把泛型类型限制为符合约束的类型\",{\"1\":{\"89\":1}}],[\"约束\",{\"0\":{\"89\":1,\"270\":1},\"1\":{\"0\":2,\"240\":1}}],[\"约定规范\",{\"0\":{\"43\":1},\"1\":{\"0\":1}}],[\"泛型中的多重约束\",{\"1\":{\"271\":1}}],[\"泛型中的约束\",{\"1\":{\"271\":1}}],[\"泛型错误\",{\"1\":{\"207\":1,\"209\":1}}],[\"泛型类型参数\",{\"1\":{\"91\":1}}],[\"泛型类型参数一般用\",{\"1\":{\"11\":1}}],[\"泛型类型\",{\"1\":{\"91\":1,\"95\":1}}],[\"泛型函数\",{\"1\":{\"11\":1}}],[\"泛型的扩展\",{\"1\":{\"87\":1}}],[\"泛型的\",{\"1\":{\"11\":1}}],[\"泛型的类型参数是使用尖括号和大驼峰命名的名称\",{\"1\":{\"11\":1}}],[\"泛型的或具体的\",{\"1\":{\"11\":1}}],[\"泛型最简单和常用的用法是用于类型参数\",{\"1\":{\"11\":1}}],[\"泛型极大地减少了代码的重复\",{\"1\":{\"11\":1}}],[\"泛型\",{\"0\":{\"11\":1},\"1\":{\"0\":1,\"11\":1,\"15\":1,\"89\":1,\"130\":1,\"243\":1,\"267\":1,\"271\":1}}],[\"死代码\",{\"0\":{\"39\":1},\"1\":{\"0\":1,\"39\":1}}],[\"属性会自动创建所需的实现\",{\"1\":{\"254\":1}}],[\"属性的模块中\",{\"1\":{\"174\":1}}],[\"属性的例子\",{\"1\":{\"119\":1}}],[\"属性时\",{\"1\":{\"38\":1}}],[\"属性可以禁用\",{\"1\":{\"39\":1}}],[\"属性可以设定\",{\"1\":{\"38\":1}}],[\"属性可以告知编译器\",{\"1\":{\"38\":1}}],[\"属性可以多个值\",{\"1\":{\"1\":1}}],[\"属性可以接受参数\",{\"1\":{\"1\":1}}],[\"属性是应用于某些模块\",{\"1\":{\"1\":1,\"15\":1}}],[\"属性\",{\"0\":{\"1\":1},\"1\":{\"0\":1,\"15\":1,\"36\":1,\"53\":1,\"62\":1,\"126\":1,\"159\":1,\"174\":1,\"175\":1,\"179\":1,\"192\":1}}],[\"测试就失败\",{\"1\":{\"174\":1}}],[\"测试函数要加上\",{\"1\":{\"174\":1}}],[\"测试函数的函数体通常会进行一些配置\",{\"1\":{\"174\":1}}],[\"测试和示例\",{\"1\":{\"43\":1}}],[\"测试有三种风格\",{\"1\":{\"28\":1}}],[\"测试中\",{\"1\":{\"7\":1}}],[\"测试\",{\"0\":{\"28\":1,\"45\":1,\"175\":1},\"1\":{\"0\":2,\"15\":1,\"17\":1,\"28\":3,\"111\":1,\"174\":1}}],[\"测试实例\",{\"0\":{\"205\":1,\"247\":1,\"249\":1,\"293\":1,\"310\":1},\"1\":{\"0\":5}}],[\"依赖管理和与\",{\"1\":{\"2\":1}}],[\"依赖\",{\"0\":{\"44\":1},\"1\":{\"0\":1}}],[\"库来说\",{\"1\":{\"256\":1}}],[\"库类型都天生可以使用\",{\"1\":{\"254\":1}}],[\"库中的类型\",{\"1\":{\"254\":1}}],[\"库的例子\",{\"1\":{\"122\":1}}],[\"库的名称为\",{\"1\":{\"38\":1}}],[\"库会使用\",{\"1\":{\"53\":1}}],[\"库\",{\"0\":{\"53\":1},\"1\":{\"0\":1,\"22\":1,\"159\":1}}],[\"声明来产生常量\",{\"1\":{\"275\":1}}],[\"声明的话\",{\"1\":{\"203\":1}}],[\"声明一个变量绑定\",{\"1\":{\"196\":1}}],[\"声明可以将一个完整的路径绑定到一个新的名字\",{\"1\":{\"132\":1}}],[\"声明累加器变量\",{\"1\":{\"85\":1}}],[\"声明时使用\",{\"1\":{\"83\":1}}],[\"声明\",{\"0\":{\"132\":1},\"1\":{\"0\":1,\"5\":1}}],[\"可选\",{\"1\":{\"290\":1}}],[\"可看到\",{\"1\":{\"263\":1}}],[\"可看下面两条提示\",{\"1\":{\"252\":1}}],[\"可用来忽略元组的其余部分\",{\"1\":{\"304\":1}}],[\"可用\",{\"1\":{\"256\":1}}],[\"可用于原型开发\",{\"1\":{\"7\":1}}],[\"可复制类型将会复制给闭包\",{\"1\":{\"235\":1}}],[\"可再次被不可变借用\",{\"1\":{\"235\":1}}],[\"可从\",{\"1\":{\"164\":1}}],[\"可使用的\",{\"1\":{\"153\":1}}],[\"可能\",{\"1\":{\"268\":1}}],[\"可能拥有名为\",{\"1\":{\"181\":1}}],[\"可能失败\",{\"1\":{\"153\":1}}],[\"可能你已经在某些\",{\"1\":{\"126\":1}}],[\"可能同时进行多项测试\",{\"1\":{\"45\":1}}],[\"可并不是\",{\"1\":{\"112\":1}}],[\"可增长的向量\",{\"1\":{\"24\":1}}],[\"可增长的\",{\"1\":{\"24\":1,\"152\":1}}],[\"可进行元编程\",{\"1\":{\"16\":1}}],[\"可点击右上角的编辑按钮打开本页对应源码文件进行编辑和修改\",{\"1\":{\"15\":1}}],[\"可参考官方文档的错误处理的章节\",{\"1\":{\"7\":1}}],[\"可以解构一个元组\",{\"1\":{\"304\":1}}],[\"可以解构结构体并重命名变量\",{\"1\":{\"302\":1}}],[\"可以根据闭包的内容推断出\",{\"1\":{\"293\":1}}],[\"可以自动地避免数据竞争\",{\"1\":{\"293\":1}}],[\"可以做更多的事\",{\"1\":{\"285\":1}}],[\"可以同时使用\",{\"1\":{\"282\":1}}],[\"可以参考官方文档的生命周期省略\",{\"1\":{\"264\":1}}],[\"可以与\",{\"1\":{\"263\":1}}],[\"可以实现单位检查\",{\"1\":{\"249\":1}}],[\"可以接受一个由\",{\"1\":{\"238\":1}}],[\"可以加上\",{\"1\":{\"231\":1}}],[\"可以直接匹配\",{\"1\":{\"228\":1}}],[\"可以采取两种行动\",{\"1\":{\"221\":1}}],[\"可以为\",{\"1\":{\"205\":1}}],[\"可以转成整型\",{\"1\":{\"201\":1}}],[\"可以先声明\",{\"1\":{\"196\":1}}],[\"可以增长的数组\",{\"1\":{\"194\":1}}],[\"可以显式转换\",{\"1\":{\"193\":1}}],[\"可以打印的元组结构体\",{\"1\":{\"179\":1}}],[\"可以比较的元组结构体\",{\"1\":{\"179\":1}}],[\"可以把属性\",{\"1\":{\"177\":1}}],[\"可以把值装箱\",{\"1\":{\"145\":1}}],[\"可以仅指定测试名称中的一部分\",{\"1\":{\"176\":1}}],[\"可以表明失败\",{\"1\":{\"151\":1}}],[\"可以看到\",{\"1\":{\"148\":1}}],[\"可以查看\",{\"1\":{\"146\":1}}],[\"可以回顾之前学过的显示\",{\"1\":{\"137\":1}}],[\"可以指向数组的一部分\",{\"1\":{\"134\":1}}],[\"可以像平常一样构造\",{\"1\":{\"129\":1}}],[\"可以传给它表达式\",{\"1\":{\"112\":1}}],[\"可以调用不同的格式\",{\"1\":{\"107\":1}}],[\"可以\",{\"1\":{\"93\":1}}],[\"可以使这段代码变得更加优雅\",{\"1\":{\"81\":1}}],[\"可以使用组合算子\",{\"1\":{\"217\":1}}],[\"可以使用命名参数\",{\"1\":{\"107\":1}}],[\"可以使用位置参数\",{\"1\":{\"107\":1}}],[\"可以使用arc\",{\"1\":{\"144\":1}}],[\"可以使用a\",{\"1\":{\"72\":1}}],[\"可以使用\",{\"1\":{\"54\":1,\"78\":1,\"136\":1,\"144\":1,\"146\":1,\"149\":1,\"174\":1,\"220\":1,\"296\":1}}],[\"可以使用快捷键\",{\"1\":{\"13\":1}}],[\"可以用模式匹配来解析简单的参数\",{\"1\":{\"287\":1}}],[\"可以用撇号显式地标出生命周期\",{\"1\":{\"266\":1}}],[\"可以用十六进制值来表示字节\",{\"1\":{\"153\":1}}],[\"可以用数字\",{\"1\":{\"135\":1}}],[\"可以用来借用数组的一部分\",{\"1\":{\"134\":1}}],[\"可以用指定的宽度对文本进行右对齐\",{\"1\":{\"107\":1}}],[\"可以用额外的泛型类型参数指定数据类型\",{\"1\":{\"101\":1}}],[\"可以用\",{\"1\":{\"76\":1,\"97\":1,\"191\":1}}],[\"可以用一个属性来禁用这个\",{\"1\":{\"39\":1}}],[\"可以有两个结果的其中一个\",{\"1\":{\"70\":1}}],[\"可以被转换成结果包裹着向量\",{\"1\":{\"65\":1}}],[\"可以阅读\",{\"1\":{\"58\":1}}],[\"可以是单元结构体\",{\"1\":{\"57\":1}}],[\"可以是可变的变量\",{\"1\":{\"55\":1}}],[\"可以很容易地把\",{\"1\":{\"47\":1}}],[\"可以管理项目的依赖关系\",{\"1\":{\"44\":1}}],[\"可以在这里查看\",{\"1\":{\"187\":1}}],[\"可以在迭代\",{\"1\":{\"154\":1}}],[\"可以在数值字面量中插入下划线\",{\"1\":{\"135\":1}}],[\"可以在路径中使用\",{\"1\":{\"131\":1}}],[\"可以在空间中给定左上角和右下角在空间中的位置来指定矩形\",{\"1\":{\"60\":1}}],[\"可以在任意作用域声明\",{\"1\":{\"55\":1}}],[\"可以在\",{\"1\":{\"41\":1}}],[\"可以运行的脚本\",{\"1\":{\"41\":1}}],[\"可以给变量名加上下划线前缀来消除警告\",{\"1\":{\"35\":1}}],[\"可以提供默认的方法定义\",{\"1\":{\"30\":1}}],[\"可以将其返回类型编写为\",{\"1\":{\"185\":1}}],[\"可以将\",{\"1\":{\"138\":1}}],[\"可以将代码按层次分成多个逻辑单元\",{\"1\":{\"18\":1}}],[\"可以将文本输出到控制台\",{\"1\":{\"13\":1}}],[\"可以从源程序生成可执行文件\",{\"1\":{\"13\":1}}],[\"可以单击那边的按钮\",{\"1\":{\"13\":1}}],[\"可以不用\",{\"1\":{\"10\":1}}],[\"可以通过添加\",{\"1\":{\"107\":1}}],[\"可以通过\",{\"1\":{\"6\":1}}],[\"可以编译成二进制可执行文件\",{\"1\":{\"5\":1}}],[\"可变数据可以使用\",{\"1\":{\"261\":1}}],[\"可变引用同样也可能拥有生命周期\",{\"1\":{\"268\":1}}],[\"可变引用不再用于其余的代码\",{\"1\":{\"259\":1}}],[\"可变引用能够以不可变类型传入\",{\"1\":{\"259\":1}}],[\"可变类型\",{\"1\":{\"228\":2}}],[\"可变参数的\",{\"1\":{\"116\":1}}],[\"可变参数接口可以接受任意数目的参数\",{\"1\":{\"116\":1}}],[\"可变参数接口\",{\"0\":{\"116\":1},\"1\":{\"0\":1}}],[\"可变对象可以调用可变方法\",{\"1\":{\"86\":1}}],[\"可变地借用一个可变对象\",{\"1\":{\"261\":1}}],[\"可变地\",{\"1\":{\"73\":1}}],[\"可变的\",{\"1\":{\"21\":1,\"154\":1}}],[\"可变接口\",{\"1\":{\"16\":1}}],[\"可变性错误\",{\"1\":{\"281\":1}}],[\"可变性\",{\"0\":{\"261\":1,\"281\":1},\"1\":{\"0\":2}}],[\"可变变量\",{\"0\":{\"198\":1},\"1\":{\"0\":1}}],[\"可见性描述符\",{\"1\":{\"110\":1}}],[\"可见性\",{\"0\":{\"133\":1},\"1\":{\"0\":1,\"128\":1}}],[\"高阶函数\",{\"0\":{\"85\":1},\"1\":{\"0\":1}}],[\"slater\",{\"1\":{\"254\":1}}],[\"sleep\",{\"1\":{\"240\":1,\"292\":1}}],[\"slice\",{\"1\":{\"34\":7,\"134\":16,\"154\":1,\"186\":1}}],[\"skip\",{\"1\":{\"186\":1}}],[\"symmetric\",{\"1\":{\"285\":3}}],[\"symlink\",{\"1\":{\"161\":1}}],[\"sync\",{\"1\":{\"144\":1,\"158\":2}}],[\"syntax\",{\"1\":{\"16\":1,\"181\":1}}],[\"sqrt\",{\"1\":{\"151\":5,\"159\":2,\"286\":3}}],[\"square\",{\"1\":{\"61\":1,\"86\":2,\"159\":1,\"286\":1}}],[\"squared\",{\"1\":{\"8\":3,\"85\":7}}],[\"svn\",{\"1\":{\"148\":1}}],[\"source\",{\"1\":{\"209\":1,\"213\":1}}],[\"soldiers\",{\"1\":{\"203\":1}}],[\"soldier\",{\"1\":{\"203\":2}}],[\"sort\",{\"1\":{\"152\":1}}],[\"sorry\",{\"1\":{\"146\":1}}],[\"something\",{\"1\":{\"287\":1}}],[\"some\",{\"1\":{\"5\":3,\"34\":4,\"68\":7,\"76\":7,\"81\":6,\"84\":2,\"103\":1,\"146\":2,\"147\":4,\"153\":1,\"164\":1,\"185\":5,\"186\":1,\"200\":2,\"210\":1,\"213\":1,\"215\":6,\"217\":9,\"219\":6,\"228\":5,\"284\":1,\"287\":1}}],[\"spin\",{\"1\":{\"167\":1}}],[\"span\",{\"1\":{\"153\":1}}],[\"spawn\",{\"1\":{\"144\":1,\"158\":1,\"167\":2,\"291\":2,\"292\":1,\"293\":2}}],[\"split\",{\"1\":{\"128\":4,\"152\":1,\"293\":1}}],[\"spec\",{\"1\":{\"91\":7}}],[\"special\",{\"1\":{\"79\":1}}],[\"specified\",{\"1\":{\"42\":1}}],[\"specific\",{\"1\":{\"16\":1,\"175\":2,\"176\":1}}],[\"speed\",{\"1\":{\"15\":1}}],[\"sgen\",{\"1\":{\"91\":4}}],[\"sgen<i32>\",{\"1\":{\"91\":1}}],[\"sgen<a>\",{\"1\":{\"91\":1}}],[\"sgen<t>\",{\"1\":{\"91\":2}}],[\"s`\",{\"1\":{\"91\":4}}],[\"s<t\",{\"1\":{\"89\":1}}],[\"switch\",{\"1\":{\"79\":1}}],[\"snake\",{\"1\":{\"68\":6,\"69\":2}}],[\"smaller\",{\"1\":{\"179\":1}}],[\"small\",{\"1\":{\"55\":1,\"75\":1,\"256\":5}}],[\"segment\",{\"1\":{\"293\":5}}],[\"segment`\",{\"1\":{\"293\":1}}],[\"sent\",{\"1\":{\"291\":1}}],[\"send\",{\"1\":{\"158\":1}}],[\"sender<i32>\",{\"1\":{\"158\":1}}],[\"sender\",{\"1\":{\"158\":3}}],[\"sed\",{\"1\":{\"288\":2}}],[\"set\",{\"1\":{\"285\":5}}],[\"setup\",{\"1\":{\"173\":2}}],[\"sequence\",{\"1\":{\"164\":1,\"186\":8}}],[\"seward\",{\"1\":{\"141\":1,\"148\":1}}],[\"see\",{\"0\":{\"100\":1,\"214\":1},\"1\":{\"84\":2}}],[\"section\",{\"1\":{\"134\":1}}],[\"seconds\",{\"1\":{\"179\":2,\"292\":1}}],[\"second\",{\"1\":{\"60\":1,\"70\":4,\"86\":2,\"134\":1,\"136\":1,\"154\":1,\"179\":5,\"220\":6,\"221\":4,\"222\":4,\"223\":3,\"225\":7,\"272\":5,\"287\":2,\"300\":7}}],[\"secs\",{\"1\":{\"45\":2}}],[\"semantics\",{\"1\":{\"179\":2}}],[\"semantic\",{\"1\":{\"44\":1}}],[\"self>\",{\"1\":{\"249\":1}}],[\"self>`\",{\"1\":{\"249\":1}}],[\"self`\",{\"1\":{\"86\":6,\"205\":1,\"306\":2,\"308\":1}}],[\"self\",{\"0\":{\"131\":1},\"1\":{\"0\":1,\"15\":1,\"30\":21,\"47\":1,\"48\":2,\"50\":4,\"52\":1,\"58\":5,\"86\":14,\"89\":4,\"93\":2,\"95\":4,\"99\":4,\"103\":3,\"118\":2,\"122\":1,\"131\":3,\"133\":2,\"142\":1,\"159\":6,\"179\":2,\"181\":6,\"183\":2,\"184\":3,\"186\":7,\"187\":2,\"189\":4,\"205\":6,\"207\":3,\"209\":2,\"211\":1,\"213\":4,\"219\":2,\"244\":10,\"246\":17,\"249\":6,\"250\":1,\"251\":7,\"256\":9,\"273\":5,\"279\":2,\"290\":1,\"306\":2,\"308\":3,\"310\":2}}],[\"screamed\",{\"1\":{\"240\":1}}],[\"script\",{\"1\":{\"42\":1}}],[\"sci\",{\"1\":{\"189\":1}}],[\"science\",{\"1\":{\"189\":1}}],[\"schedule\",{\"1\":{\"167\":1}}],[\"scope\",{\"0\":{\"329\":1},\"1\":{\"149\":2,\"199\":1}}],[\"scalar\",{\"0\":{\"20\":1}}],[\"src\",{\"1\":{\"40\":1,\"43\":2,\"44\":1,\"45\":1,\"168\":1,\"170\":3,\"173\":2,\"174\":1}}],[\"short\",{\"1\":{\"199\":5}}],[\"should\",{\"1\":{\"170\":1,\"175\":4,\"176\":2,\"293\":1}}],[\"showable\",{\"1\":{\"164\":1}}],[\"shift\",{\"1\":{\"153\":3}}],[\"shear\",{\"1\":{\"30\":2}}],[\"sheep\",{\"1\":{\"30\":8,\"184\":3}}],[\"shadowing\",{\"1\":{\"199\":1}}],[\"shadow\",{\"1\":{\"21\":1}}],[\"sint\",{\"1\":{\"288\":2}}],[\"singlegen\",{\"1\":{\"11\":4}}],[\"singlegen<char>\",{\"1\":{\"11\":1}}],[\"singlegen<t>\",{\"1\":{\"11\":1}}],[\"single\",{\"1\":{\"11\":2,\"277\":2}}],[\"sit\",{\"1\":{\"288\":2}}],[\"significant\",{\"1\":{\"193\":2}}],[\"signed\",{\"1\":{\"20\":1}}],[\"size\",{\"1\":{\"111\":4,\"134\":2,\"145\":6,\"154\":1,\"195\":12}}],[\"saturation\",{\"1\":{\"296\":2}}],[\"said\",{\"1\":{\"153\":1,\"240\":1}}],[\"same\",{\"1\":{\"144\":1,\"153\":1}}],[\"says\",{\"1\":{\"30\":1,\"152\":2,\"184\":1}}],[\"say\",{\"1\":{\"16\":2}}],[\"safety\",{\"1\":{\"15\":1}}],[\"s\",{\"1\":{\"11\":1,\"36\":2,\"38\":3,\"45\":2,\"53\":3,\"54\":3,\"57\":2,\"63\":1,\"64\":1,\"65\":1,\"66\":2,\"68\":1,\"69\":1,\"76\":3,\"78\":2,\"89\":2,\"91\":7,\"95\":1,\"146\":3,\"161\":13,\"164\":2,\"166\":4,\"207\":1,\"209\":1,\"211\":1,\"251\":1,\"254\":1,\"282\":3,\"289\":3,\"291\":3,\"296\":4}}],[\"steak\",{\"1\":{\"215\":4}}],[\"student\",{\"1\":{\"189\":12}}],[\"stmt\",{\"1\":{\"110\":1}}],[\"style\",{\"1\":{\"85\":2,\"123\":1}}],[\"stays\",{\"1\":{\"275\":1}}],[\"status\",{\"1\":{\"166\":1,\"203\":4}}],[\"static<\",{\"1\":{\"275\":1}}],[\"static`\",{\"1\":{\"266\":1,\"275\":3}}],[\"static\",{\"0\":{\"275\":1},\"1\":{\"0\":1,\"6\":1,\"30\":7,\"55\":9,\"56\":2,\"86\":1,\"112\":1,\"152\":1,\"158\":1,\"164\":1,\"167\":1,\"183\":1,\"184\":3,\"209\":1,\"213\":1,\"247\":2,\"251\":1,\"261\":4,\"262\":1,\"268\":1,\"275\":13,\"276\":1,\"288\":2,\"291\":2}}],[\"stack\",{\"1\":{\"145\":6}}],[\"stacked\",{\"1\":{\"138\":2}}],[\"starts\",{\"1\":{\"139\":3}}],[\"stabilization\",{\"1\":{\"58\":1}}],[\"str`\",{\"1\":{\"164\":1,\"261\":2}}],[\"struck\",{\"1\":{\"153\":1}}],[\"struct2\",{\"1\":{\"101\":3}}],[\"struct1\",{\"1\":{\"101\":3}}],[\"structs\",{\"1\":{\"92\":1,\"100\":1}}],[\"structures\",{\"1\":{\"256\":1}}],[\"structure\",{\"1\":{\"6\":1,\"60\":1,\"107\":2,\"254\":4,\"256\":2}}],[\"struct\",{\"1\":{\"6\":1,\"11\":4,\"12\":1,\"15\":1,\"30\":1,\"47\":1,\"48\":1,\"50\":2,\"52\":1,\"57\":1,\"60\":10,\"86\":3,\"89\":3,\"90\":1,\"91\":3,\"93\":2,\"94\":1,\"95\":4,\"96\":1,\"99\":2,\"101\":2,\"104\":1,\"107\":2,\"109\":1,\"118\":1,\"120\":1,\"129\":2,\"136\":1,\"142\":1,\"145\":2,\"159\":1,\"163\":1,\"178\":2,\"179\":3,\"181\":1,\"183\":1,\"184\":2,\"186\":1,\"187\":4,\"207\":1,\"209\":1,\"211\":1,\"217\":3,\"219\":3,\"230\":1,\"244\":1,\"245\":1,\"246\":1,\"247\":3,\"249\":1,\"251\":2,\"254\":5,\"255\":1,\"256\":3,\"258\":1,\"259\":1,\"261\":1,\"263\":1,\"270\":1,\"273\":1,\"277\":2,\"279\":1,\"282\":3,\"284\":3,\"302\":2,\"310\":1,\"312\":1}}],[\"strong\",{\"1\":{\"149\":4}}],[\"str>\",{\"1\":{\"67\":1,\"68\":2,\"207\":1,\"209\":1,\"210\":2,\"211\":1,\"213\":1}}],[\"str\",{\"1\":{\"30\":7,\"47\":3,\"55\":2,\"69\":1,\"70\":6,\"118\":1,\"146\":2,\"152\":9,\"153\":14,\"161\":1,\"164\":2,\"183\":1,\"184\":3,\"207\":1,\"220\":6,\"221\":6,\"222\":6,\"223\":6,\"225\":12,\"240\":1,\"247\":2,\"251\":1,\"254\":1,\"261\":2,\"275\":1,\"284\":8,\"288\":1,\"291\":1,\"293\":1}}],[\"string`\",{\"1\":{\"275\":1}}],[\"string>\",{\"1\":{\"171\":2}}],[\"stringify\",{\"1\":{\"110\":2,\"111\":2,\"112\":1,\"113\":4,\"116\":1,\"205\":3}}],[\"strings\",{\"1\":{\"63\":2,\"64\":2,\"65\":2,\"66\":4,\"67\":2,\"153\":1,\"207\":2,\"209\":2,\"210\":4,\"211\":2,\"213\":2}}],[\"string\",{\"1\":{\"0\":1,\"4\":2,\"24\":1,\"47\":3,\"50\":6,\"55\":1,\"57\":2,\"59\":1,\"60\":2,\"76\":1,\"97\":2,\"107\":1,\"118\":2,\"149\":1,\"152\":13,\"153\":8,\"161\":4,\"166\":2,\"171\":1,\"181\":3,\"183\":1,\"189\":5,\"205\":1,\"235\":1,\"268\":3,\"275\":4,\"282\":2,\"284\":2,\"287\":3,\"289\":2,\"290\":1,\"291\":2}}],[\"stdio\",{\"1\":{\"291\":3}}],[\"stdin\",{\"1\":{\"291\":4}}],[\"stdcrate\",{\"1\":{\"195\":1}}],[\"stderr\",{\"1\":{\"107\":1,\"166\":2,\"291\":1}}],[\"stdout\",{\"1\":{\"42\":1,\"107\":1,\"166\":2,\"174\":1,\"291\":4}}],[\"std\",{\"0\":{\"237\":1,\"330\":1,\"331\":1},\"1\":{\"0\":1,\"15\":1,\"22\":1,\"34\":2,\"47\":1,\"48\":1,\"50\":2,\"52\":2,\"68\":1,\"89\":1,\"90\":1,\"97\":1,\"98\":1,\"101\":2,\"103\":1,\"107\":2,\"108\":1,\"109\":1,\"111\":2,\"114\":1,\"134\":1,\"144\":2,\"145\":1,\"146\":1,\"149\":1,\"150\":2,\"152\":2,\"153\":1,\"154\":1,\"156\":2,\"158\":3,\"159\":1,\"161\":7,\"164\":1,\"166\":1,\"167\":1,\"178\":1,\"185\":2,\"187\":1,\"193\":1,\"195\":6,\"207\":3,\"209\":3,\"210\":2,\"211\":3,\"213\":4,\"220\":1,\"221\":1,\"222\":1,\"223\":1,\"225\":3,\"235\":1,\"236\":1,\"240\":1,\"241\":1,\"248\":2,\"249\":2,\"251\":1,\"253\":1,\"254\":3,\"255\":1,\"256\":5,\"258\":1,\"270\":1,\"284\":1,\"285\":1,\"287\":1,\"288\":3,\"289\":3,\"290\":3,\"291\":3,\"292\":1,\"293\":1,\"307\":1,\"309\":1,\"310\":1}}],[\"sunt\",{\"1\":{\"288\":2}}],[\"sushi\",{\"1\":{\"215\":5}}],[\"such\",{\"1\":{\"200\":1}}],[\"succeeded\",{\"1\":{\"166\":1}}],[\"success\",{\"1\":{\"166\":1}}],[\"successfully\",{\"1\":{\"288\":2}}],[\"successful\",{\"1\":{\"153\":1,\"284\":1}}],[\"suppressed\",{\"1\":{\"141\":2,\"148\":2}}],[\"super\",{\"0\":{\"131\":1},\"1\":{\"0\":1,\"111\":1,\"131\":2,\"133\":5,\"168\":1,\"174\":1,\"175\":1,\"177\":1}}],[\"sub\",{\"1\":{\"111\":6}}],[\"subject=\",{\"1\":{\"107\":1}}],[\"subject\",{\"1\":{\"107\":1}}],[\"subtract\",{\"1\":{\"58\":3}}],[\"sugar\",{\"1\":{\"86\":1}}],[\"sums\",{\"1\":{\"293\":4}}],[\"sum\",{\"1\":{\"51\":3,\"84\":3,\"85\":4,\"293\":6}}],[\"summary\",{\"0\":{\"0\":1},\"1\":{\"141\":2,\"148\":2}}],[\"sure\",{\"1\":{\"36\":1}}],[\"suffix\",{\"1\":{\"21\":1}}],[\"作业\",{\"0\":{\"294\":1}}],[\"作为散列表的\",{\"1\":{\"284\":1}}],[\"作为键来创建\",{\"1\":{\"284\":1}}],[\"作为显式类型标注将导致失败\",{\"1\":{\"266\":1}}],[\"作为前缀\",{\"1\":{\"110\":1}}],[\"作为\",{\"1\":{\"108\":1}}],[\"作为虚类型参数的类型\",{\"1\":{\"101\":1}}],[\"作为泛型方法实现了\",{\"1\":{\"93\":1}}],[\"作为约束\",{\"1\":{\"89\":1,\"103\":1}}],[\"作为参数\",{\"1\":{\"57\":1,\"137\":1}}],[\"作为类型的代号\",{\"1\":{\"11\":1}}],[\"作为输出参数\",{\"0\":{\"242\":1},\"1\":{\"0\":1}}],[\"作为输入参数\",{\"0\":{\"240\":1},\"1\":{\"0\":1}}],[\"作用域是最外面的作用域\",{\"1\":{\"131\":1}}],[\"作用域内绑定\",{\"1\":{\"131\":1}}],[\"作用域告诉编译器什么时候借用是合法的\",{\"1\":{\"23\":1}}],[\"作用域在所有权\",{\"1\":{\"15\":1,\"23\":1}}],[\"作用域\",{\"1\":{\"15\":1}}],[\"作用域规则\",{\"0\":{\"23\":1},\"1\":{\"0\":1,\"15\":1}}],[\"作用域和遮蔽\",{\"0\":{\"199\":1},\"1\":{\"0\":1}}],[\"捕获变量\",{\"1\":{\"240\":1}}],[\"捕获\",{\"0\":{\"235\":1},\"1\":{\"0\":1,\"233\":1,\"240\":1}}],[\"闭包作为输入参数是可能的\",{\"1\":{\"242\":1}}],[\"闭包处理一个\",{\"1\":{\"240\":1}}],[\"闭包没有输入值和返回值\",{\"1\":{\"240\":1}}],[\"闭包不再借用\",{\"1\":{\"235\":1}}],[\"闭包本身存储到\",{\"1\":{\"235\":1}}],[\"闭包本质上很灵活\",{\"1\":{\"235\":1}}],[\"闭包优先通过引用来捕获变量\",{\"1\":{\"235\":1}}],[\"闭包可以通过以下方式捕获变量\",{\"1\":{\"235\":1}}],[\"闭包定义的方式决定了这是必要的\",{\"1\":{\"233\":1}}],[\"闭包从周围的作用域中捕获变量是简单明了的\",{\"1\":{\"233\":1}}],[\"闭包的迭代器\",{\"1\":{\"185\":1}}],[\"闭包类型\",{\"1\":{\"83\":1}}],[\"闭包表达式产生的类型就是\",{\"1\":{\"83\":1}}],[\"闭包是匿名的\",{\"1\":{\"83\":1}}],[\"闭包和高阶函数\",{\"1\":{\"15\":1}}],[\"闭包\",{\"0\":{\"83\":1},\"1\":{\"0\":1,\"216\":1,\"218\":1,\"240\":1,\"267\":1}}],[\"函数一样长\",{\"1\":{\"266\":1}}],[\"函数看起来会像是这样\",{\"1\":{\"222\":1}}],[\"函数拥有更小的作用域\",{\"1\":{\"199\":1}}],[\"函数中\",{\"1\":{\"199\":1}}],[\"函数中的变量离开作用域\",{\"1\":{\"142\":1}}],[\"函数中的行\",{\"1\":{\"105\":1}}],[\"函数是在\",{\"1\":{\"195\":1}}],[\"函数来销毁\",{\"1\":{\"183\":1}}],[\"函数增加了打印到控制台的功能\",{\"1\":{\"183\":1}}],[\"函数会返回\",{\"1\":{\"171\":1}}],[\"函数将会\",{\"1\":{\"170\":1}}],[\"函数提供了创建本地操作系统\",{\"1\":{\"167\":1}}],[\"函数的返回类型详情\",{\"1\":{\"225\":1}}],[\"函数的\",{\"1\":{\"225\":1}}],[\"函数的方式是使用\",{\"1\":{\"161\":1}}],[\"函数的输出可以装箱\",{\"1\":{\"145\":1}}],[\"函数的参数需要标注类型\",{\"1\":{\"10\":1}}],[\"函数作为样板\",{\"1\":{\"137\":1}}],[\"函数可以使用元组来返回多个值\",{\"1\":{\"136\":1}}],[\"函数式的写法\",{\"1\":{\"85\":1}}],[\"函数体定界符\",{\"1\":{\"83\":1}}],[\"函数名和其他位置使用它们\",{\"1\":{\"40\":1}}],[\"函数签名可以省略返回类型\",{\"1\":{\"10\":1}}],[\"函数最后的表达式将作为返回值\",{\"1\":{\"10\":1}}],[\"函数\",{\"0\":{\"10\":1,\"91\":1,\"268\":1},\"1\":{\"0\":3,\"10\":1,\"15\":1,\"18\":1,\"51\":1,\"55\":1,\"73\":2,\"89\":1,\"92\":1,\"99\":1,\"133\":1,\"137\":1,\"171\":1,\"174\":1,\"228\":1,\"229\":1,\"244\":1,\"269\":1}}],[\"绑定来进行模式匹配或解构时\",{\"1\":{\"263\":1}}],[\"绑定来解构\",{\"1\":{\"60\":1}}],[\"绑定到\",{\"1\":{\"178\":1,\"228\":1}}],[\"绑定拥有局部作用域\",{\"1\":{\"132\":1}}],[\"绑定都需要它\",{\"1\":{\"75\":1}}],[\"绑定操作可以将值\",{\"1\":{\"35\":1}}],[\"绑定\",{\"0\":{\"228\":1},\"1\":{\"0\":1,\"35\":1,\"147\":1}}],[\"卫语句\",{\"0\":{\"231\":1},\"1\":{\"0\":1}}],[\"匹配任意其他值\",{\"1\":{\"228\":1}}],[\"匹配任意其他数字\",{\"1\":{\"228\":1}}],[\"匹配任何枚举值\",{\"1\":{\"76\":1}}],[\"匹配一个具体的\",{\"1\":{\"205\":1}}],[\"匹配一个闭区间范围\",{\"1\":{\"79\":1}}],[\"匹配分支\",{\"1\":{\"84\":1}}],[\"匹配多个值\",{\"1\":{\"79\":1}}],[\"匹配单个值\",{\"1\":{\"79\":1}}],[\"匹配到了\",{\"1\":{\"76\":2}}],[\"匹配枚举类型并不优雅\",{\"1\":{\"76\":1}}],[\"匹配\",{\"0\":{\"79\":1},\"1\":{\"0\":1,\"306\":1}}],[\"fs\",{\"1\":{\"161\":11,\"288\":1,\"289\":1,\"290\":1}}],[\"fugiat\",{\"1\":{\"288\":2}}],[\"full\",{\"1\":{\"195\":1}}],[\"fully\",{\"1\":{\"181\":1}}],[\"futures\",{\"1\":{\"122\":1}}],[\"funcion\",{\"1\":{\"133\":1}}],[\"funcion`\",{\"1\":{\"132\":1}}],[\"functional\",{\"1\":{\"85\":2}}],[\"function`\",{\"1\":{\"54\":1,\"131\":1,\"132\":3,\"133\":2}}],[\"function\",{\"1\":{\"10\":1,\"38\":5,\"39\":4,\"53\":5,\"54\":4,\"83\":4,\"84\":2,\"85\":1,\"110\":3,\"128\":18,\"131\":15,\"132\":10,\"133\":34,\"159\":1,\"183\":1,\"185\":2,\"200\":2,\"238\":4}}],[\"fun\",{\"1\":{\"91\":1,\"195\":2}}],[\"feter\",{\"1\":{\"249\":1}}],[\"feet\",{\"1\":{\"249\":2}}],[\"feature\",{\"1\":{\"84\":1}}],[\"ferris\",{\"1\":{\"73\":7}}],[\"flow\",{\"0\":{\"321\":1}}],[\"float\",{\"1\":{\"21\":2,\"147\":3}}],[\"floating\",{\"1\":{\"20\":1}}],[\"flatmap\",{\"1\":{\"215\":1}}],[\"flag\",{\"1\":{\"166\":1}}],[\"fly\",{\"1\":{\"83\":1}}],[\"fred\",{\"1\":{\"146\":1}}],[\"freeze\",{\"1\":{\"197\":1,\"260\":1}}],[\"free\",{\"1\":{\"164\":1}}],[\"freed\",{\"1\":{\"141\":1,\"148\":1}}],[\"frees\",{\"1\":{\"141\":1,\"148\":1}}],[\"frank\",{\"1\":{\"73\":3}}],[\"from<parseinterror>\",{\"1\":{\"213\":1}}],[\"from<i32>\",{\"1\":{\"47\":1}}],[\"fromiter\",{\"1\":{\"65\":1}}],[\"fromstr\",{\"0\":{\"49\":1},\"1\":{\"0\":1,\"51\":2}}],[\"from\",{\"0\":{\"46\":1},\"1\":{\"0\":1,\"4\":1,\"34\":3,\"46\":1,\"47\":6,\"48\":2,\"52\":5,\"60\":1,\"141\":2,\"148\":2,\"152\":1,\"153\":2,\"166\":2,\"171\":1,\"207\":1,\"211\":6,\"212\":2,\"213\":1,\"214\":2,\"235\":1,\"268\":2,\"282\":2}}],[\"f\",{\"1\":{\"50\":2,\"159\":3,\"161\":6,\"195\":2,\"207\":2,\"209\":2,\"211\":2,\"213\":3,\"217\":5,\"233\":8,\"238\":3,\"240\":8,\"251\":2,\"256\":6,\"306\":3,\"310\":7}}],[\"fmt\",{\"1\":{\"50\":5,\"89\":1,\"90\":1,\"97\":1,\"98\":1,\"103\":1,\"107\":6,\"108\":1,\"109\":1,\"137\":1,\"159\":5,\"207\":5,\"209\":5,\"211\":5,\"213\":6,\"251\":6,\"252\":1,\"253\":1,\"254\":6,\"255\":1,\"256\":27,\"258\":1,\"270\":1,\"310\":9}}],[\"ffi\",{\"1\":{\"32\":1,\"159\":1}}],[\"f64没有实现\",{\"1\":{\"284\":1}}],[\"f64>\",{\"1\":{\"101\":2}}],[\"f64>`\",{\"1\":{\"101\":2}}],[\"f64类型\",{\"1\":{\"21\":1}}],[\"f64\",{\"1\":{\"20\":1,\"21\":2,\"86\":8,\"89\":7,\"95\":2,\"107\":1,\"145\":2,\"151\":7,\"179\":2,\"184\":1,\"195\":1,\"249\":1,\"256\":2,\"286\":8}}],[\"f32>\",{\"1\":{\"101\":2}}],[\"f32>`\",{\"1\":{\"101\":2}}],[\"f32\",{\"1\":{\"20\":1,\"60\":3,\"61\":2,\"136\":4,\"159\":2,\"191\":1,\"193\":1,\"199\":1,\"251\":2,\"284\":1}}],[\"following\",{\"1\":{\"186\":1}}],[\"fold\",{\"1\":{\"75\":1,\"85\":1}}],[\"four\",{\"1\":{\"186\":3,\"266\":2}}],[\"fourth\",{\"1\":{\"154\":1}}],[\"found\",{\"1\":{\"40\":2,\"181\":1,\"225\":1,\"313\":1}}],[\"fox\",{\"1\":{\"107\":1,\"152\":1,\"291\":1}}],[\"foo<\",{\"1\":{\"266\":2}}],[\"foo<t>\",{\"1\":{\"11\":1}}],[\"foot`\",{\"1\":{\"249\":2}}],[\"foot\",{\"1\":{\"179\":5,\"249\":6}}],[\"foobar`\",{\"1\":{\"187\":1}}],[\"foobar\",{\"1\":{\"76\":3,\"187\":4}}],[\"food\",{\"1\":{\"68\":2,\"215\":29,\"217\":20}}],[\"foo\",{\"1\":{\"11\":1,\"40\":6,\"43\":2,\"44\":6,\"45\":7,\"76\":15,\"84\":1,\"110\":2,\"140\":1,\"187\":10,\"195\":2,\"251\":4,\"266\":2,\"268\":2,\"302\":11}}],[\"form\",{\"1\":{\"181\":8}}],[\"formatting\",{\"1\":{\"153\":1}}],[\"formatter\",{\"1\":{\"50\":1,\"159\":1,\"179\":1,\"207\":1,\"209\":1,\"211\":1,\"213\":1,\"251\":2,\"256\":3,\"310\":1}}],[\"format\",{\"1\":{\"50\":1,\"107\":2,\"189\":1,\"205\":2,\"219\":1,\"251\":3}}],[\"foreign\",{\"1\":{\"159\":1}}],[\"force\",{\"1\":{\"116\":1}}],[\"for\",{\"0\":{\"71\":1,\"72\":1,\"73\":1},\"1\":{\"0\":1,\"9\":1,\"10\":1,\"15\":1,\"30\":1,\"41\":1,\"47\":1,\"48\":1,\"50\":2,\"52\":1,\"72\":4,\"73\":5,\"84\":1,\"85\":1,\"89\":1,\"93\":1,\"103\":3,\"111\":2,\"123\":1,\"139\":1,\"141\":3,\"142\":1,\"144\":1,\"146\":2,\"148\":2,\"152\":2,\"154\":3,\"158\":2,\"159\":1,\"161\":1,\"167\":2,\"174\":1,\"181\":2,\"183\":1,\"184\":2,\"186\":6,\"187\":2,\"207\":2,\"209\":2,\"211\":2,\"213\":3,\"244\":1,\"246\":1,\"247\":2,\"249\":2,\"250\":1,\"251\":3,\"256\":3,\"279\":1,\"290\":1,\"292\":1,\"293\":2,\"310\":2,\"312\":1}}],[\"farewell\",{\"1\":{\"240\":4}}],[\"favorite\",{\"1\":{\"189\":1}}],[\"fav\",{\"1\":{\"189\":2}}],[\"family\",{\"1\":{\"161\":1}}],[\"fancier\",{\"1\":{\"153\":1}}],[\"false\",{\"1\":{\"10\":1,\"20\":1,\"30\":1,\"76\":2,\"79\":1,\"84\":1,\"113\":1,\"135\":4,\"174\":1,\"285\":1,\"306\":2}}],[\"failures\",{\"1\":{\"170\":1,\"174\":2}}],[\"failure\",{\"1\":{\"68\":1}}],[\"failed\",{\"1\":{\"45\":2,\"111\":1,\"147\":1,\"153\":1,\"166\":2,\"170\":2,\"173\":3,\"174\":4,\"175\":2,\"176\":4,\"177\":4,\"266\":2,\"284\":1}}],[\"fail\",{\"1\":{\"7\":1}}],[\"fnmut\",{\"1\":{\"233\":2,\"234\":1,\"238\":1,\"239\":1,\"240\":2,\"241\":1,\"242\":5,\"243\":1,\"306\":1,\"308\":1}}],[\"fnonce\",{\"1\":{\"233\":3,\"234\":1,\"238\":1,\"239\":1,\"240\":4,\"241\":1,\"242\":5}}],[\"fn`\",{\"1\":{\"91\":1}}],[\"fn\",{\"0\":{\"322\":1},\"1\":{\"8\":3,\"10\":5,\"11\":2,\"13\":1,\"16\":1,\"21\":1,\"30\":11,\"33\":1,\"34\":1,\"35\":1,\"36\":3,\"38\":3,\"39\":4,\"40\":2,\"47\":2,\"48\":2,\"50\":4,\"51\":1,\"52\":2,\"53\":3,\"54\":1,\"55\":2,\"57\":2,\"58\":2,\"59\":1,\"60\":1,\"63\":1,\"64\":1,\"65\":1,\"66\":2,\"67\":2,\"68\":3,\"69\":2,\"70\":2,\"72\":2,\"73\":3,\"75\":1,\"76\":3,\"78\":1,\"79\":1,\"80\":1,\"81\":1,\"83\":2,\"84\":8,\"85\":2,\"86\":7,\"89\":6,\"91\":7,\"93\":3,\"95\":3,\"97\":3,\"99\":4,\"101\":1,\"103\":3,\"105\":1,\"107\":1,\"110\":2,\"111\":2,\"112\":1,\"113\":1,\"114\":1,\"116\":1,\"118\":3,\"125\":1,\"128\":8,\"129\":2,\"131\":6,\"132\":3,\"133\":13,\"134\":2,\"135\":1,\"136\":2,\"138\":3,\"139\":1,\"140\":2,\"141\":2,\"142\":2,\"144\":1,\"145\":3,\"146\":2,\"147\":3,\"148\":2,\"149\":1,\"151\":5,\"152\":1,\"153\":3,\"154\":1,\"156\":1,\"158\":1,\"159\":5,\"161\":5,\"164\":1,\"166\":1,\"167\":1,\"168\":2,\"170\":2,\"171\":4,\"173\":4,\"174\":4,\"175\":4,\"177\":4,\"178\":1,\"179\":2,\"181\":5,\"183\":2,\"184\":5,\"185\":7,\"186\":3,\"187\":3,\"189\":6,\"191\":1,\"193\":1,\"194\":1,\"195\":1,\"196\":1,\"197\":1,\"198\":1,\"199\":1,\"200\":2,\"201\":1,\"203\":1,\"205\":5,\"207\":6,\"209\":5,\"210\":4,\"211\":4,\"213\":6,\"215\":6,\"217\":6,\"219\":3,\"220\":3,\"221\":3,\"222\":3,\"223\":3,\"225\":7,\"226\":1,\"227\":1,\"228\":4,\"231\":1,\"233\":6,\"234\":1,\"235\":2,\"238\":5,\"239\":1,\"240\":7,\"241\":1,\"242\":15,\"243\":1,\"244\":9,\"246\":11,\"247\":3,\"249\":3,\"251\":2,\"254\":2,\"256\":4,\"259\":1,\"260\":1,\"261\":3,\"263\":1,\"264\":5,\"266\":3,\"268\":6,\"270\":3,\"272\":3,\"273\":3,\"275\":2,\"277\":1,\"279\":2,\"281\":1,\"282\":1,\"284\":2,\"285\":1,\"286\":6,\"287\":4,\"288\":1,\"289\":1,\"290\":2,\"291\":1,\"292\":1,\"293\":1,\"296\":1,\"298\":1,\"300\":1,\"302\":1,\"304\":1,\"306\":2,\"308\":2,\"310\":2}}],[\"fight\",{\"1\":{\"203\":1}}],[\"fibonacci\",{\"1\":{\"186\":9}}],[\"fixme\",{\"1\":{\"107\":1,\"108\":1}}],[\"fire\",{\"1\":{\"68\":1}}],[\"first<\",{\"1\":{\"272\":1}}],[\"first\",{\"1\":{\"67\":11,\"70\":4,\"86\":2,\"101\":3,\"134\":2,\"136\":1,\"186\":1,\"207\":8,\"209\":7,\"210\":18,\"211\":9,\"213\":8,\"220\":6,\"221\":4,\"222\":4,\"223\":3,\"225\":7,\"228\":1,\"231\":1,\"244\":5,\"246\":5,\"272\":9,\"300\":2,\"304\":2}}],[\"fish\",{\"1\":{\"51\":1}}],[\"filter\",{\"1\":{\"64\":2,\"85\":1,\"185\":3}}],[\"filtered\",{\"1\":{\"45\":2,\"170\":2,\"173\":3,\"174\":1,\"175\":2,\"176\":4,\"177\":4}}],[\"filename\",{\"1\":{\"290\":2}}],[\"files\",{\"1\":{\"161\":1}}],[\"file\",{\"0\":{\"354\":1},\"1\":{\"5\":3,\"26\":1,\"41\":1,\"45\":2,\"160\":2,\"161\":5,\"163\":6,\"183\":1,\"200\":1,\"288\":6,\"289\":8,\"290\":5}}],[\"final\",{\"1\":{\"293\":3}}],[\"finishes\",{\"1\":{\"292\":1}}],[\"finished\",{\"1\":{\"45\":2,\"158\":1}}],[\"find<p>\",{\"1\":{\"308\":1}}],[\"find\",{\"0\":{\"308\":1},\"1\":{\"0\":1,\"85\":1,\"114\":5,\"308\":9,\"309\":1}}],[\"fizz\",{\"1\":{\"10\":1,\"72\":2,\"80\":1}}],[\"fizzbuzz\",{\"1\":{\"10\":6,\"72\":3,\"80\":3}}],[\"wait\",{\"1\":{\"292\":4}}],[\"wasn\",{\"1\":{\"217\":1}}],[\"was\",{\"1\":{\"166\":2,\"187\":2,\"300\":1}}],[\"wc\",{\"1\":{\"291\":6}}],[\"w\",{\"1\":{\"251\":1}}],[\"wrote\",{\"1\":{\"288\":2}}],[\"wrapper\",{\"1\":{\"213\":1,\"238\":1}}],[\"wrap\",{\"1\":{\"186\":1}}],[\"wraps\",{\"1\":{\"163\":1}}],[\"writing\",{\"1\":{\"153\":1}}],[\"written\",{\"1\":{\"135\":1}}],[\"write\",{\"1\":{\"50\":1,\"159\":2,\"161\":2,\"163\":1,\"207\":1,\"209\":1,\"211\":1,\"213\":1,\"251\":1,\"256\":3,\"288\":3,\"291\":2,\"310\":8}}],[\"won\",{\"1\":{\"107\":1,\"148\":1}}],[\"work\",{\"1\":{\"153\":1,\"203\":5,\"219\":2}}],[\"word\",{\"1\":{\"134\":1,\"152\":2}}],[\"words\",{\"1\":{\"97\":1,\"152\":1}}],[\"world\",{\"0\":{\"13\":1},\"1\":{\"0\":1,\"13\":3,\"14\":1,\"15\":2,\"24\":1,\"105\":1,\"125\":1,\"289\":2}}],[\"wednesday\",{\"1\":{\"215\":2}}],[\"we\",{\"1\":{\"146\":1,\"154\":1,\"215\":2,\"298\":1}}],[\"were\",{\"1\":{\"141\":1,\"148\":1,\"300\":2}}],[\"well\",{\"1\":{\"68\":1}}],[\"webevent\",{\"1\":{\"57\":12}}],[\"web\",{\"1\":{\"57\":1}}],[\"widget\",{\"1\":{\"181\":2}}],[\"width\",{\"1\":{\"107\":1}}],[\"width=5\",{\"1\":{\"107\":1}}],[\"windows\",{\"1\":{\"164\":3}}],[\"wikipedia\",{\"1\":{\"146\":1}}],[\"with\",{\"1\":{\"42\":1,\"76\":3,\"141\":2,\"146\":1,\"148\":2,\"153\":2,\"158\":1,\"174\":1,\"209\":1,\"213\":1,\"291\":1}}],[\"will\",{\"1\":{\"41\":1,\"84\":1,\"219\":1,\"226\":1,\"254\":2}}],[\"whether\",{\"1\":{\"287\":3}}],[\"where\",{\"0\":{\"103\":1},\"1\":{\"0\":1,\"89\":1,\"103\":6,\"233\":2,\"240\":2,\"244\":1,\"246\":1,\"270\":2,\"290\":1,\"306\":1,\"308\":1}}],[\"whitespace\",{\"1\":{\"152\":1,\"293\":1}}],[\"while\",{\"0\":{\"80\":1,\"81\":1},\"1\":{\"0\":2,\"72\":1,\"80\":3,\"81\":3,\"85\":1}}],[\"why\",{\"1\":{\"151\":9,\"161\":12,\"286\":2,\"288\":4,\"289\":4,\"291\":6}}],[\"who\",{\"1\":{\"146\":1}}],[\"whole\",{\"1\":{\"134\":1}}],[\"what\",{\"1\":{\"146\":1,\"153\":1,\"228\":1,\"256\":1,\"296\":1,\"304\":1}}],[\"从借用的数据创建有所有权的数据\",{\"1\":{\"240\":1}}],[\"从最低有效位\",{\"1\":{\"193\":1}}],[\"从这个\",{\"1\":{\"181\":2}}],[\"从外部作用域导入所有名字\",{\"1\":{\"174\":1}}],[\"从不执行深拷贝\",{\"1\":{\"149\":1}}],[\"从句\",{\"1\":{\"103\":2}}],[\"从句比正常语法更有表现力时\",{\"1\":{\"103\":1}}],[\"从句来表达约束\",{\"1\":{\"103\":1}}],[\"从句可以用于任意类型的限定\",{\"1\":{\"103\":1}}],[\"从而计算每一位的和\",{\"1\":{\"293\":1}}],[\"从而可以对具体值创建引用\",{\"1\":{\"298\":1}}],[\"从而可以通过管道与所代表的进程交互\",{\"1\":{\"291\":1}}],[\"从而可以在需要精确类型的地方使用\",{\"1\":{\"84\":1}}],[\"从而原始值不受影响\",{\"1\":{\"235\":1}}],[\"从而缩短了\",{\"1\":{\"186\":1}}],[\"从而显示出生命周期\",{\"1\":{\"139\":1}}],[\"从而取代通过值\",{\"1\":{\"138\":1}}],[\"从而将值绑定给变量\",{\"1\":{\"136\":1}}],[\"从而更容易访问\",{\"1\":{\"132\":1}}],[\"从而在访问项时消除歧义\",{\"1\":{\"131\":1}}],[\"从而接受不同的参数组合\",{\"1\":{\"113\":1}}],[\"从而允许集合被就地修改\",{\"1\":{\"73\":1}}],[\"从而大大减少了类型说明的工作\",{\"1\":{\"35\":1}}],[\"从一个字符串切片中创建一个具有所有权的\",{\"1\":{\"57\":1}}],[\"从经典的\",{\"1\":{\"15\":1}}],[\"从\",{\"0\":{\"210\":1,\"227\":1},\"1\":{\"0\":2,\"57\":1,\"154\":1,\"164\":1,\"171\":1,\"179\":1,\"201\":1,\"282\":1}}],[\"循环中返回\",{\"0\":{\"227\":1}}],[\"循环必须用一些\",{\"1\":{\"226\":1}}],[\"循环写一下臭名昭著的\",{\"1\":{\"80\":1}}],[\"循环之后仍可以使用\",{\"1\":{\"73\":1}}],[\"循环会对给出的集合应用\",{\"1\":{\"73\":1}}],[\"循环和区间\",{\"1\":{\"0\":1}}],[\"循环返回\",{\"1\":{\"0\":1}}],[\"循环\",{\"0\":{\"71\":1,\"78\":1,\"80\":1},\"1\":{\"0\":2}}],[\"l\",{\"1\":{\"296\":2}}],[\"ln\",{\"1\":{\"151\":6,\"286\":5}}],[\"laborum\",{\"1\":{\"288\":2}}],[\"laboris\",{\"1\":{\"288\":2}}],[\"labore\",{\"1\":{\"288\":2}}],[\"label\",{\"1\":{\"226\":1}}],[\"large\",{\"1\":{\"260\":2}}],[\"lat\",{\"1\":{\"251\":8}}],[\"last\",{\"1\":{\"154\":1,\"244\":5,\"246\":5,\"263\":2,\"300\":2}}],[\"lazy\",{\"1\":{\"85\":1,\"107\":1,\"152\":1,\"291\":1}}],[\"lambda\",{\"1\":{\"83\":2}}],[\"lang\",{\"1\":{\"44\":1,\"83\":1}}],[\"language\",{\"1\":{\"16\":1,\"55\":2,\"87\":1,\"189\":3}}],[\"lsb\",{\"1\":{\"193\":2}}],[\"ls\",{\"1\":{\"38\":1,\"53\":1}}],[\"least\",{\"1\":{\"193\":1,\"209\":1,\"213\":1}}],[\"leaks\",{\"1\":{\"141\":1,\"148\":1}}],[\"leak\",{\"1\":{\"141\":2}}],[\"leaving\",{\"1\":{\"132\":1}}],[\"leetcode\",{\"1\":{\"80\":1}}],[\"left\",{\"1\":{\"60\":4,\"174\":4}}],[\"lender\",{\"1\":{\"139\":1}}],[\"len\",{\"1\":{\"34\":1,\"111\":6,\"134\":2,\"149\":1,\"154\":1,\"156\":1,\"205\":3,\"235\":1,\"287\":1}}],[\"length<mm>\",{\"1\":{\"249\":1}}],[\"length<inch>\",{\"1\":{\"249\":1}}],[\"length<unit>\",{\"1\":{\"249\":5}}],[\"length\",{\"1\":{\"34\":2,\"89\":5,\"134\":2,\"149\":1,\"205\":1,\"249\":3}}],[\"let修复以下示例\",{\"1\":{\"76\":1}}],[\"let`\",{\"1\":{\"76\":2,\"81\":2}}],[\"letters\",{\"1\":{\"76\":3}}],[\"letter\",{\"1\":{\"76\":4}}],[\"let\",{\"0\":{\"76\":1,\"81\":1},\"1\":{\"0\":2,\"8\":6,\"11\":5,\"21\":8,\"30\":1,\"33\":1,\"34\":4,\"35\":7,\"47\":3,\"48\":2,\"50\":2,\"51\":3,\"52\":2,\"55\":1,\"57\":5,\"58\":1,\"60\":10,\"63\":2,\"64\":2,\"65\":2,\"66\":6,\"67\":4,\"68\":6,\"70\":4,\"73\":3,\"75\":2,\"76\":22,\"78\":2,\"79\":3,\"80\":1,\"81\":6,\"83\":4,\"84\":4,\"85\":4,\"86\":8,\"89\":3,\"93\":2,\"95\":2,\"97\":3,\"99\":2,\"101\":4,\"103\":1,\"105\":1,\"107\":2,\"108\":1,\"110\":1,\"111\":3,\"112\":1,\"116\":1,\"118\":2,\"129\":3,\"134\":2,\"136\":8,\"138\":3,\"139\":3,\"140\":5,\"141\":3,\"142\":1,\"144\":2,\"145\":6,\"146\":1,\"147\":3,\"148\":1,\"149\":3,\"152\":7,\"153\":14,\"154\":2,\"156\":1,\"158\":3,\"159\":2,\"161\":5,\"164\":3,\"166\":3,\"167\":2,\"170\":2,\"171\":1,\"178\":5,\"179\":6,\"181\":3,\"183\":4,\"184\":2,\"185\":5,\"186\":3,\"191\":2,\"193\":4,\"194\":2,\"195\":5,\"196\":3,\"197\":2,\"198\":2,\"199\":4,\"203\":2,\"205\":1,\"207\":3,\"209\":3,\"210\":7,\"211\":5,\"213\":5,\"215\":1,\"217\":6,\"219\":2,\"220\":2,\"221\":2,\"222\":2,\"225\":5,\"227\":2,\"231\":1,\"233\":2,\"235\":12,\"238\":1,\"240\":4,\"242\":6,\"244\":3,\"246\":3,\"247\":3,\"249\":5,\"251\":2,\"254\":3,\"256\":4,\"259\":7,\"260\":2,\"261\":2,\"263\":11,\"264\":1,\"266\":3,\"268\":4,\"270\":2,\"272\":2,\"273\":1,\"275\":3,\"277\":6,\"279\":1,\"281\":2,\"282\":2,\"284\":4,\"285\":2,\"286\":2,\"287\":4,\"288\":3,\"289\":4,\"290\":3,\"291\":2,\"292\":2,\"293\":7,\"296\":1,\"298\":5,\"300\":1,\"302\":5,\"304\":1,\"306\":4,\"308\":6,\"310\":2}}],[\"lorem\",{\"1\":{\"288\":7}}],[\"logarithm\",{\"1\":{\"286\":1}}],[\"login\",{\"1\":{\"284\":1}}],[\"logical\",{\"1\":{\"21\":1}}],[\"logon\",{\"1\":{\"284\":6}}],[\"logon<\",{\"1\":{\"284\":1}}],[\"lon\",{\"1\":{\"251\":8}}],[\"longer\",{\"1\":{\"153\":2}}],[\"long\",{\"1\":{\"76\":1,\"136\":8,\"153\":2,\"199\":9}}],[\"lots\",{\"1\":{\"203\":1}}],[\"lossy\",{\"1\":{\"166\":2}}],[\"love\",{\"1\":{\"68\":1,\"69\":1,\"217\":1}}],[\"load\",{\"1\":{\"57\":2}}],[\"loaded\",{\"1\":{\"57\":1}}],[\"looks\",{\"1\":{\"179\":1}}],[\"look\",{\"1\":{\"41\":1,\"256\":1}}],[\"loop\",{\"0\":{\"78\":1,\"227\":1,\"341\":1},\"1\":{\"0\":2,\"78\":2,\"81\":1,\"84\":1,\"226\":5,\"227\":3}}],[\"lhs\",{\"1\":{\"10\":2}}],[\"lightness\",{\"1\":{\"296\":1}}],[\"lived\",{\"1\":{\"199\":10}}],[\"live\",{\"1\":{\"199\":1}}],[\"literals\",{\"1\":{\"153\":1,\"193\":1}}],[\"literal\",{\"1\":{\"110\":1,\"135\":1}}],[\"like\",{\"1\":{\"76\":3,\"152\":1,\"153\":1,\"179\":1,\"256\":1}}],[\"like`\",{\"1\":{\"57\":1}}],[\"libm\",{\"1\":{\"159\":1}}],[\"libvex\",{\"1\":{\"141\":1,\"148\":1}}],[\"libcore\",{\"1\":{\"121\":1}}],[\"libdoc\",{\"1\":{\"118\":1}}],[\"lib\",{\"1\":{\"38\":3,\"44\":1,\"53\":2,\"118\":1,\"168\":1,\"170\":3,\"173\":1,\"174\":1}}],[\"library\",{\"1\":{\"5\":1,\"38\":1,\"53\":1,\"54\":1}}],[\"lifetime\",{\"0\":{\"349\":1},\"1\":{\"15\":1,\"23\":1,\"139\":5,\"275\":2}}],[\"linked\",{\"1\":{\"205\":2}}],[\"link\",{\"1\":{\"159\":2}}],[\"linebreak\",{\"1\":{\"153\":1}}],[\"line\",{\"1\":{\"44\":1,\"84\":2,\"170\":3,\"290\":2}}],[\"lines<io\",{\"1\":{\"290\":1}}],[\"lines<p>\",{\"1\":{\"290\":1}}],[\"lines\",{\"1\":{\"0\":1,\"153\":1,\"290\":8}}],[\"linux\",{\"1\":{\"36\":12}}],[\"lint\",{\"1\":{\"1\":1,\"39\":3}}],[\"list`\",{\"1\":{\"205\":1}}],[\"list\",{\"0\":{\"310\":1},\"1\":{\"0\":1,\"205\":22,\"310\":3}}],[\"ip\",{\"1\":{\"290\":2}}],[\"ipsum`\",{\"1\":{\"288\":1}}],[\"ipsum\",{\"1\":{\"288\":7}}],[\"irure\",{\"1\":{\"288\":2}}],[\"immutabook\",{\"1\":{\"261\":4}}],[\"immutably\",{\"1\":{\"260\":1,\"261\":1}}],[\"immutable\",{\"1\":{\"198\":3,\"261\":1,\"281\":5}}],[\"imag\",{\"1\":{\"257\":1}}],[\"im\",{\"1\":{\"159\":5}}],[\"imperative\",{\"1\":{\"85\":2}}],[\"import\",{\"1\":{\"1\":1}}],[\"impl<\",{\"1\":{\"279\":1}}],[\"impl<unit>\",{\"1\":{\"249\":1}}],[\"impl<u>\",{\"1\":{\"249\":1}}],[\"impl<t>\",{\"1\":{\"103\":1,\"129\":1}}],[\"impl<t\",{\"1\":{\"93\":1}}],[\"implicit\",{\"1\":{\"201\":1}}],[\"implementor\",{\"1\":{\"30\":1}}],[\"impl\",{\"0\":{\"185\":1},\"1\":{\"0\":1,\"18\":1,\"30\":2,\"47\":1,\"48\":1,\"50\":2,\"52\":1,\"58\":2,\"86\":4,\"89\":1,\"95\":6,\"96\":1,\"99\":2,\"103\":3,\"118\":1,\"142\":1,\"159\":1,\"179\":1,\"181\":3,\"183\":1,\"184\":2,\"185\":7,\"186\":2,\"187\":2,\"189\":2,\"205\":1,\"207\":2,\"209\":2,\"211\":2,\"213\":3,\"219\":1,\"242\":3,\"243\":1,\"244\":1,\"246\":1,\"247\":2,\"250\":1,\"251\":1,\"256\":3,\"273\":1,\"279\":2,\"310\":1}}],[\"ids\",{\"1\":{\"158\":3}}],[\"id\",{\"1\":{\"158\":4,\"288\":2}}],[\"ident\",{\"1\":{\"110\":2,\"111\":7}}],[\"identifier\",{\"1\":{\"40\":2}}],[\"ignore\",{\"1\":{\"125\":2,\"177\":4}}],[\"ignored\",{\"1\":{\"45\":2,\"111\":1,\"170\":2,\"173\":3,\"174\":1,\"175\":2,\"176\":4,\"177\":10,\"300\":2}}],[\"i|\",{\"1\":{\"85\":1}}],[\"it\",{\"1\":{\"36\":2,\"153\":1,\"163\":1,\"184\":1,\"217\":1,\"296\":1,\"304\":1}}],[\"iterate\",{\"1\":{\"186\":2}}],[\"iterators\",{\"1\":{\"295\":1}}],[\"iterator<item\",{\"1\":{\"185\":1}}],[\"iterator<item=i32>\",{\"1\":{\"185\":1}}],[\"iterator\",{\"0\":{\"186\":1,\"306\":1,\"308\":1},\"1\":{\"0\":3,\"72\":1,\"73\":1,\"74\":1,\"85\":1,\"154\":3,\"186\":3,\"306\":3,\"307\":1,\"308\":2,\"309\":1}}],[\"iter\",{\"1\":{\"63\":2,\"64\":1,\"65\":1,\"66\":4,\"73\":8,\"111\":6,\"146\":2,\"154\":3,\"185\":7,\"186\":2,\"251\":2,\"285\":2,\"293\":1,\"306\":7,\"307\":1,\"308\":10,\"309\":1,\"310\":1}}],[\"items\",{\"0\":{\"344\":1}}],[\"item>\",{\"1\":{\"308\":1}}],[\"item`\",{\"1\":{\"306\":1,\"308\":1}}],[\"item\",{\"1\":{\"1\":1,\"18\":1,\"47\":2,\"87\":1,\"110\":1,\"186\":1,\"207\":2,\"209\":1,\"211\":1,\"306\":2,\"308\":2}}],[\"i128\",{\"1\":{\"20\":1}}],[\"i16\",{\"1\":{\"20\":1,\"193\":2}}],[\"i64\",{\"1\":{\"20\":1,\"21\":3,\"57\":2,\"99\":2,\"256\":2}}],[\"i8\",{\"1\":{\"20\":1,\"193\":5}}],[\"i32`\",{\"1\":{\"91\":1,\"138\":8,\"272\":2,\"298\":2,\"306\":3,\"308\":6}}],[\"i32|\",{\"1\":{\"83\":1,\"185\":1}}],[\"i32>>\",{\"1\":{\"285\":4}}],[\"i32>\",{\"1\":{\"24\":1,\"185\":1,\"244\":1}}],[\"i32\",{\"1\":{\"11\":1,\"20\":1,\"21\":2,\"47\":2,\"48\":2,\"50\":2,\"51\":1,\"52\":2,\"55\":2,\"58\":3,\"60\":1,\"67\":1,\"70\":1,\"83\":3,\"91\":2,\"107\":1,\"134\":3,\"135\":1,\"136\":2,\"138\":29,\"147\":4,\"148\":3,\"158\":1,\"167\":1,\"168\":3,\"170\":6,\"171\":2,\"173\":3,\"174\":6,\"177\":3,\"179\":2,\"185\":3,\"195\":2,\"201\":4,\"225\":1,\"240\":3,\"244\":10,\"246\":15,\"254\":3,\"256\":1,\"259\":3,\"263\":2,\"264\":6,\"266\":3,\"268\":7,\"272\":6,\"273\":1,\"275\":3,\"277\":5,\"279\":1,\"287\":3}}],[\"ingredients\",{\"1\":{\"215\":3}}],[\"ingredient\",{\"1\":{\"215\":1}}],[\"input<\",{\"1\":{\"264\":1}}],[\"input`\",{\"1\":{\"264\":5}}],[\"input\",{\"1\":{\"210\":1,\"264\":3}}],[\"inputs\",{\"1\":{\"42\":1}}],[\"invalid\",{\"1\":{\"207\":2,\"209\":1,\"211\":1,\"268\":1,\"287\":2}}],[\"incididunt\",{\"1\":{\"288\":2}}],[\"inc\",{\"1\":{\"235\":3}}],[\"inch\",{\"1\":{\"191\":2,\"249\":1}}],[\"inches\",{\"1\":{\"179\":6,\"191\":4}}],[\"increase|decrease\",{\"1\":{\"287\":3}}],[\"increase\",{\"1\":{\"75\":1,\"287\":7}}],[\"initialize\",{\"1\":{\"196\":1}}],[\"initialization\",{\"1\":{\"141\":1}}],[\"initial\",{\"1\":{\"154\":1}}],[\"index\",{\"1\":{\"293\":1}}],[\"indentation\",{\"1\":{\"153\":1}}],[\"indirect\",{\"1\":{\"38\":1,\"53\":1,\"54\":1,\"128\":4,\"131\":3,\"133\":3}}],[\"inaccessible`\",{\"1\":{\"128\":1}}],[\"inaccessible\",{\"1\":{\"128\":4}}],[\"info\",{\"1\":{\"141\":1,\"148\":1,\"284\":5}}],[\"information\",{\"1\":{\"129\":3}}],[\"infinity\",{\"1\":{\"78\":1}}],[\"inference\",{\"1\":{\"31\":1}}],[\"inferred\",{\"1\":{\"21\":2,\"83\":3}}],[\"infer\",{\"1\":{\"21\":1}}],[\"insert\",{\"1\":{\"146\":6,\"284\":1,\"285\":4}}],[\"instance\",{\"1\":{\"86\":1}}],[\"inside\",{\"1\":{\"68\":3,\"149\":1}}],[\"inspect\",{\"1\":{\"57\":6}}],[\"inner\",{\"1\":{\"68\":2,\"199\":2,\"226\":2}}],[\"inline\",{\"1\":{\"32\":1,\"120\":1,\"121\":1}}],[\"int\",{\"1\":{\"48\":2,\"138\":1,\"284\":1}}],[\"intermediate\",{\"1\":{\"293\":6}}],[\"intersection\",{\"1\":{\"285\":3}}],[\"interesting\",{\"1\":{\"228\":1}}],[\"interface\",{\"1\":{\"16\":1,\"44\":1,\"159\":1}}],[\"integration\",{\"1\":{\"28\":1,\"173\":3}}],[\"integer`\",{\"1\":{\"35\":2,\"197\":4,\"260\":4}}],[\"integer\",{\"1\":{\"21\":2,\"35\":5,\"60\":2,\"136\":3,\"193\":4,\"197\":5,\"260\":6,\"287\":5}}],[\"integers\",{\"1\":{\"20\":2,\"116\":1}}],[\"intoiter<i32>>>\",{\"1\":{\"185\":1}}],[\"intoiter\",{\"1\":{\"185\":1}}],[\"into<number>\",{\"1\":{\"48\":1}}],[\"into\",{\"0\":{\"46\":1},\"1\":{\"0\":1,\"4\":1,\"46\":1,\"48\":7,\"52\":4,\"63\":1,\"64\":1,\"65\":1,\"66\":4,\"73\":3,\"154\":2,\"185\":4,\"186\":1,\"207\":2,\"211\":1,\"285\":2,\"306\":2,\"308\":4}}],[\"in\",{\"1\":{\"10\":1,\"41\":1,\"45\":2,\"68\":1,\"72\":3,\"73\":4,\"84\":1,\"85\":1,\"103\":3,\"111\":2,\"133\":20,\"141\":3,\"144\":1,\"145\":8,\"146\":1,\"148\":2,\"152\":3,\"153\":1,\"154\":4,\"158\":2,\"161\":1,\"167\":2,\"186\":4,\"195\":5,\"235\":1,\"249\":1,\"251\":2,\"254\":1,\"256\":1,\"275\":1,\"277\":4,\"285\":1,\"288\":6,\"290\":1,\"293\":2,\"306\":4,\"308\":4,\"310\":1}}],[\"isize\",{\"1\":{\"20\":1}}],[\"is\",{\"1\":{\"8\":3,\"10\":4,\"30\":4,\"47\":1,\"48\":1,\"55\":5,\"66\":2,\"67\":3,\"70\":2,\"73\":3,\"75\":5,\"76\":5,\"79\":1,\"81\":2,\"85\":3,\"105\":1,\"107\":3,\"108\":1,\"113\":2,\"123\":1,\"135\":9,\"136\":2,\"138\":1,\"140\":2,\"141\":1,\"142\":1,\"146\":3,\"149\":4,\"153\":5,\"156\":2,\"159\":1,\"164\":2,\"167\":1,\"175\":2,\"179\":2,\"189\":3,\"193\":8,\"201\":2,\"207\":1,\"209\":1,\"210\":7,\"211\":1,\"213\":1,\"220\":1,\"221\":1,\"222\":1,\"223\":1,\"225\":2,\"231\":1,\"242\":3,\"244\":1,\"246\":1,\"247\":3,\"254\":1,\"256\":2,\"259\":1,\"263\":3,\"266\":2,\"268\":3,\"270\":2,\"272\":2,\"277\":3,\"279\":1,\"282\":4,\"285\":1,\"287\":8,\"293\":1,\"296\":4,\"298\":1,\"304\":4}}],[\"ioerror>\",{\"1\":{\"191\":1}}],[\"ioresult<t>\",{\"1\":{\"191\":1}}],[\"io\",{\"1\":{\"2\":1,\"44\":3,\"107\":2,\"160\":2,\"161\":7,\"163\":2,\"223\":1,\"224\":1,\"288\":1,\"289\":1,\"290\":3,\"291\":1}}],[\"i\",{\"0\":{\"160\":1},\"1\":{\"0\":1,\"14\":1,\"26\":1,\"68\":2,\"69\":1,\"76\":12,\"81\":10,\"83\":8,\"84\":4,\"85\":1,\"139\":3,\"146\":1,\"152\":1,\"153\":2,\"154\":2,\"156\":2,\"159\":2,\"160\":2,\"163\":2,\"167\":2,\"186\":8,\"189\":1,\"195\":2,\"207\":1,\"209\":1,\"217\":1,\"219\":1,\"225\":2,\"228\":4,\"238\":2,\"240\":3,\"261\":2,\"275\":1,\"293\":3,\"302\":3}}],[\"if`\",{\"1\":{\"76\":1,\"81\":1}}],[\"if\",{\"0\":{\"75\":1,\"76\":1},\"1\":{\"0\":2,\"9\":1,\"10\":5,\"15\":1,\"30\":2,\"36\":1,\"52\":1,\"55\":1,\"68\":1,\"69\":1,\"72\":6,\"75\":5,\"76\":14,\"78\":2,\"80\":3,\"81\":3,\"85\":2,\"147\":1,\"148\":1,\"151\":3,\"153\":1,\"159\":1,\"161\":1,\"166\":1,\"170\":1,\"171\":1,\"175\":2,\"179\":1,\"184\":1,\"227\":1,\"231\":3,\"251\":2,\"286\":3,\"290\":2,\"310\":1}}],[\"流程控制\",{\"0\":{\"9\":1},\"1\":{\"0\":1,\"15\":1}}],[\"t>\",{\"1\":{\"270\":1}}],[\"title\",{\"1\":{\"261\":4}}],[\"t<u>`\",{\"1\":{\"249\":1}}],[\"t<u>\",{\"1\":{\"249\":3}}],[\"tmp\",{\"1\":{\"175\":1,\"176\":2,\"177\":2}}],[\"txt\",{\"1\":{\"161\":12,\"288\":3,\"289\":5}}],[\"txt`\",{\"1\":{\"161\":10,\"289\":1}}],[\"tx`\",{\"1\":{\"158\":1}}],[\"tx\",{\"1\":{\"158\":4}}],[\"t2\",{\"1\":{\"136\":2}}],[\"t1\",{\"1\":{\"136\":2}}],[\"twins\",{\"1\":{\"231\":1}}],[\"two\",{\"1\":{\"134\":1,\"201\":1,\"249\":4}}],[\"twenty\",{\"1\":{\"70\":2,\"225\":4}}],[\"ty\",{\"1\":{\"110\":1}}],[\"type=lib\",{\"1\":{\"53\":1}}],[\"types<t\",{\"1\":{\"97\":1}}],[\"types\",{\"0\":{\"319\":1,\"334\":1,\"338\":1},\"1\":{\"24\":2,\"83\":2,\"97\":1,\"116\":1,\"191\":1}}],[\"type\",{\"0\":{\"20\":1,\"21\":1,\"99\":1},\"1\":{\"5\":1,\"20\":1,\"21\":3,\"30\":1,\"31\":1,\"38\":5,\"52\":1,\"58\":1,\"84\":1,\"101\":1,\"118\":1,\"151\":1,\"185\":1,\"186\":1,\"187\":2,\"191\":4,\"207\":1,\"209\":1,\"211\":1,\"213\":1,\"223\":1,\"225\":2,\"228\":1,\"235\":1,\"246\":6,\"249\":3,\"284\":1,\"286\":1,\"306\":1,\"308\":1}}],[\"t`\",{\"1\":{\"91\":2,\"191\":1,\"205\":1}}],[\"t必须实现\",{\"1\":{\"89\":1}}],[\"tt\",{\"1\":{\"70\":2,\"110\":1,\"111\":2,\"225\":4}}],[\"tempor\",{\"1\":{\"288\":2}}],[\"terms\",{\"1\":{\"186\":2}}],[\"terminated\",{\"1\":{\"152\":1}}],[\"teen\",{\"1\":{\"79\":1,\"228\":1}}],[\"tell\",{\"1\":{\"79\":1,\"228\":1,\"231\":1,\"304\":1}}],[\"ten\",{\"1\":{\"75\":1}}],[\"teddy\",{\"1\":{\"69\":1}}],[\"text\",{\"1\":{\"57\":1,\"153\":1,\"242\":6}}],[\"testing\",{\"0\":{\"332\":1}}],[\"test\",{\"1\":{\"45\":22,\"101\":1,\"111\":14,\"113\":3,\"117\":2,\"118\":2,\"168\":3,\"170\":7,\"173\":15,\"174\":18,\"175\":17,\"176\":17,\"177\":20}}],[\"tests\",{\"1\":{\"45\":5,\"111\":1,\"168\":1,\"170\":3,\"173\":9,\"174\":9,\"175\":7,\"176\":8,\"177\":7}}],[\"turkey\",{\"1\":{\"247\":5}}],[\"turbo\",{\"1\":{\"51\":3}}],[\"tuesday\",{\"1\":{\"215\":2}}],[\"tuple`\",{\"1\":{\"263\":1}}],[\"tuplestructs\",{\"1\":{\"250\":1}}],[\"tuples\",{\"1\":{\"136\":3}}],[\"tuple2\",{\"1\":{\"101\":3}}],[\"tuple1\",{\"1\":{\"101\":3}}],[\"tuple\",{\"1\":{\"21\":1,\"60\":1,\"136\":14,\"263\":4}}],[\"tail\",{\"1\":{\"205\":6,\"300\":2}}],[\"table\",{\"1\":{\"146\":1}}],[\"take\",{\"1\":{\"85\":1,\"111\":3,\"186\":2}}],[\"target\",{\"1\":{\"36\":3,\"42\":1,\"45\":4,\"117\":1,\"161\":1,\"173\":1,\"200\":1}}],[\"talk\",{\"1\":{\"30\":4}}],[\"third\",{\"1\":{\"300\":4}}],[\"this\",{\"1\":{\"55\":1,\"76\":1,\"79\":1,\"84\":5,\"107\":3,\"138\":1,\"146\":2,\"148\":1,\"153\":1,\"167\":1,\"179\":1,\"226\":1,\"242\":3,\"287\":4}}],[\"than\",{\"1\":{\"81\":2,\"179\":1}}],[\"that\",{\"1\":{\"38\":1,\"42\":1,\"53\":1,\"54\":1,\"68\":1,\"78\":1,\"128\":2,\"131\":1,\"133\":3,\"138\":1,\"140\":1,\"163\":1}}],[\"through\",{\"1\":{\"186\":1}}],[\"throwing\",{\"1\":{\"68\":1}}],[\"thread\",{\"1\":{\"144\":2,\"148\":1,\"158\":5,\"167\":3,\"174\":1,\"293\":2}}],[\"threads\",{\"0\":{\"356\":1},\"1\":{\"26\":1}}],[\"three\",{\"1\":{\"78\":1}}],[\"threshold\",{\"1\":{\"55\":5}}],[\"they\",{\"1\":{\"304\":1}}],[\"these\",{\"1\":{\"231\":1}}],[\"there\",{\"1\":{\"73\":3,\"123\":1,\"153\":1,\"235\":1}}],[\"the\",{\"1\":{\"15\":1,\"35\":1,\"41\":1,\"42\":1,\"55\":1,\"67\":3,\"75\":1,\"83\":1,\"85\":2,\"87\":1,\"107\":2,\"129\":2,\"134\":6,\"136\":1,\"144\":1,\"145\":6,\"146\":1,\"149\":1,\"152\":2,\"153\":2,\"154\":1,\"159\":1,\"163\":2,\"183\":1,\"186\":5,\"203\":2,\"207\":1,\"209\":1,\"210\":8,\"211\":1,\"213\":1,\"226\":3,\"228\":1,\"231\":1,\"244\":1,\"246\":1,\"254\":1,\"256\":2,\"272\":2,\"282\":4,\"287\":7,\"291\":2,\"296\":3,\"300\":2,\"304\":1}}],[\"then\",{\"0\":{\"215\":1},\"1\":{\"0\":1,\"153\":1,\"207\":1,\"209\":1,\"211\":2,\"215\":5,\"216\":1,\"223\":1,\"225\":2,\"240\":1,\"292\":1}}],[\"t\",{\"1\":{\"11\":8,\"16\":1,\"33\":1,\"68\":2,\"70\":2,\"76\":3,\"79\":1,\"89\":11,\"91\":5,\"93\":2,\"95\":3,\"97\":8,\"103\":1,\"107\":1,\"111\":1,\"129\":3,\"134\":4,\"138\":2,\"145\":1,\"146\":2,\"147\":1,\"148\":1,\"151\":1,\"152\":1,\"153\":1,\"179\":3,\"191\":3,\"193\":3,\"210\":1,\"215\":1,\"217\":1,\"220\":1,\"221\":1,\"222\":1,\"223\":1,\"225\":3,\"228\":1,\"235\":3,\"240\":11,\"247\":2,\"261\":2,\"266\":1,\"268\":3,\"270\":17,\"284\":1,\"288\":2,\"289\":2,\"291\":3,\"304\":2}}],[\"touch\",{\"1\":{\"161\":3}}],[\"today\",{\"1\":{\"146\":1}}],[\"todrop\",{\"1\":{\"142\":5}}],[\"todo\",{\"1\":{\"107\":1,\"108\":1,\"259\":3}}],[\"total\",{\"1\":{\"141\":1,\"148\":1}}],[\"too\",{\"1\":{\"136\":3,\"153\":1}}],[\"tokens\",{\"1\":{\"153\":1}}],[\"token\",{\"1\":{\"111\":1}}],[\"tofu\",{\"1\":{\"63\":1,\"64\":1,\"65\":1,\"66\":2,\"67\":1,\"207\":1,\"209\":1,\"210\":2,\"211\":1,\"213\":1}}],[\"top\",{\"1\":{\"60\":4}}],[\"toml\",{\"1\":{\"41\":1,\"43\":2,\"44\":5,\"45\":1,\"168\":2}}],[\"to\",{\"1\":{\"10\":2,\"50\":3,\"57\":1,\"84\":3,\"99\":4,\"116\":1,\"118\":1,\"138\":5,\"147\":2,\"149\":2,\"152\":2,\"161\":2,\"163\":1,\"164\":1,\"166\":1,\"179\":2,\"181\":2,\"207\":2,\"209\":3,\"210\":1,\"211\":1,\"215\":2,\"240\":4,\"242\":3,\"263\":5,\"288\":3,\"289\":1,\"291\":3,\"293\":1,\"298\":1}}],[\"tostring\",{\"0\":{\"49\":1},\"1\":{\"0\":1,\"50\":5,\"107\":1}}],[\"triple\",{\"1\":{\"304\":3}}],[\"trimmed\",{\"1\":{\"152\":2}}],[\"trim\",{\"1\":{\"152\":3}}],[\"triangle\",{\"1\":{\"89\":5}}],[\"trpl\",{\"1\":{\"29\":1,\"87\":1,\"273\":1}}],[\"true\",{\"1\":{\"20\":1,\"21\":4,\"30\":1,\"35\":1,\"79\":2,\"84\":1,\"113\":1,\"135\":7,\"136\":3,\"161\":2,\"179\":1,\"306\":2}}],[\"tree\",{\"1\":{\"16\":1,\"110\":1,\"111\":1,\"128\":1,\"161\":1}}],[\"transpose\",{\"1\":{\"137\":4}}],[\"translate\",{\"1\":{\"86\":3}}],[\"translation\",{\"1\":{\"15\":1}}],[\"trait才能返回一个闭包\",{\"1\":{\"242\":1}}],[\"trait`\",{\"1\":{\"185\":1}}],[\"traits\",{\"1\":{\"107\":1,\"109\":1,\"250\":1,\"251\":1,\"254\":1}}],[\"traitf\",{\"1\":{\"103\":1}}],[\"traitf>\",{\"1\":{\"103\":1}}],[\"traite\",{\"1\":{\"103\":2}}],[\"traitc\",{\"1\":{\"103\":2}}],[\"traitb\",{\"1\":{\"103\":2}}],[\"trait\",{\"0\":{\"30\":1,\"93\":1,\"181\":1,\"184\":1,\"185\":1,\"189\":1,\"279\":1,\"333\":1},\"1\":{\"0\":7,\"4\":3,\"15\":2,\"18\":1,\"30\":8,\"46\":1,\"47\":1,\"48\":3,\"50\":2,\"51\":1,\"52\":2,\"73\":1,\"87\":6,\"89\":6,\"90\":1,\"93\":4,\"94\":1,\"98\":1,\"103\":1,\"104\":1,\"107\":1,\"137\":1,\"142\":3,\"146\":1,\"178\":3,\"179\":6,\"181\":7,\"183\":4,\"184\":7,\"185\":3,\"186\":4,\"187\":6,\"189\":9,\"190\":1,\"207\":1,\"208\":1,\"209\":1,\"213\":2,\"225\":1,\"233\":2,\"238\":2,\"240\":2,\"243\":1,\"244\":6,\"245\":1,\"246\":6,\"247\":6,\"248\":1,\"249\":5,\"251\":3,\"254\":1,\"256\":3,\"258\":1,\"270\":6,\"279\":1,\"280\":1,\"284\":1,\"306\":1,\"308\":1}}],[\"try\",{\"1\":{\"40\":5,\"52\":5,\"81\":2,\"146\":1,\"147\":3,\"171\":8,\"222\":5,\"284\":3,\"287\":1,\"310\":4}}],[\"tryinto\",{\"0\":{\"52\":1},\"1\":{\"0\":1,\"52\":4}}],[\"tryfrom<i32>\",{\"1\":{\"52\":1}}],[\"tryfrom\",{\"0\":{\"52\":1},\"1\":{\"0\":1,\"52\":4}}],[\"和解引用\",{\"1\":{\"298\":1}}],[\"和可变性\",{\"1\":{\"281\":1}}],[\"和前面相似\",{\"1\":{\"296\":1}}],[\"和前面例子一样\",{\"1\":{\"288\":1}}],[\"和前面类似\",{\"1\":{\"277\":1}}],[\"和前面出错的原因一样\",{\"1\":{\"140\":1}}],[\"和闭包类似\",{\"1\":{\"266\":1}}],[\"和none\",{\"1\":{\"217\":1}}],[\"和option\",{\"1\":{\"210\":1}}],[\"和值两者都将被删除\",{\"1\":{\"149\":1}}],[\"和单元类型\",{\"1\":{\"135\":1}}],[\"和直接调用\",{\"1\":{\"131\":1}}],[\"和clap\",{\"1\":{\"112\":1}}],[\"和平常一样\",{\"1\":{\"97\":1}}],[\"和函数类似\",{\"1\":{\"95\":1}}],[\"和任何泛型类型\",{\"1\":{\"93\":1}}],[\"和惰性迭代器\",{\"1\":{\"85\":1}}],[\"和所有其他类型相反\",{\"1\":{\"84\":1}}],[\"和相关的\",{\"1\":{\"77\":1,\"82\":1}}],[\"和iter\",{\"1\":{\"73\":1}}],[\"和其他\",{\"1\":{\"67\":2}}],[\"和一个\",{\"1\":{\"61\":1}}],[\"和引用\",{\"1\":{\"33\":1}}],[\"和生命周期\",{\"1\":{\"15\":1,\"23\":1}}],[\"和并发\",{\"1\":{\"15\":1}}],[\"和\",{\"0\":{\"46\":1,\"49\":1,\"68\":1,\"131\":1},\"1\":{\"0\":5,\"4\":1,\"6\":1,\"7\":1,\"10\":1,\"15\":1,\"20\":3,\"22\":1,\"25\":1,\"27\":1,\"37\":1,\"38\":1,\"46\":1,\"52\":3,\"59\":1,\"62\":1,\"70\":1,\"79\":1,\"81\":1,\"85\":1,\"86\":1,\"90\":1,\"92\":1,\"93\":1,\"94\":1,\"96\":1,\"98\":1,\"101\":1,\"102\":1,\"104\":1,\"109\":1,\"110\":1,\"111\":3,\"113\":1,\"128\":2,\"130\":1,\"131\":1,\"139\":2,\"146\":2,\"150\":1,\"152\":2,\"153\":1,\"154\":1,\"158\":2,\"165\":1,\"170\":2,\"174\":1,\"181\":1,\"185\":1,\"186\":2,\"189\":1,\"204\":1,\"205\":1,\"206\":1,\"211\":1,\"212\":1,\"216\":1,\"218\":1,\"229\":1,\"234\":1,\"236\":1,\"238\":1,\"239\":1,\"240\":1,\"241\":1,\"243\":1,\"244\":6,\"245\":1,\"246\":4,\"247\":1,\"248\":1,\"249\":3,\"250\":1,\"251\":1,\"255\":1,\"256\":2,\"258\":1,\"264\":2,\"266\":4,\"267\":1,\"282\":1,\"284\":7,\"291\":1,\"293\":1,\"295\":1,\"297\":1,\"298\":3,\"312\":1}}],[\"别名规则\",{\"1\":{\"293\":1}}],[\"别名的主要用途是避免写出冗长的模板化代码\",{\"1\":{\"191\":1}}],[\"别名使用\",{\"0\":{\"259\":1},\"1\":{\"0\":1}}],[\"别名\",{\"0\":{\"191\":1},\"1\":{\"0\":1,\"58\":1}}],[\"冻结\",{\"0\":{\"197\":1,\"260\":1},\"1\":{\"0\":1}}],[\"风格用法\",{\"0\":{\"201\":1},\"1\":{\"0\":1}}],[\"cyan\",{\"1\":{\"296\":2}}],[\"cycle\",{\"1\":{\"185\":2}}],[\"cycle<iter\",{\"1\":{\"185\":1}}],[\"cmyk\",{\"1\":{\"296\":2}}],[\"cmy\",{\"1\":{\"296\":2}}],[\"cmd\",{\"1\":{\"287\":2}}],[\"cmp\",{\"1\":{\"114\":1,\"179\":2,\"248\":2}}],[\"c2\",{\"1\":{\"263\":3}}],[\"c1\",{\"1\":{\"263\":3}}],[\"c>\",{\"1\":{\"244\":1,\"246\":1}}],[\"celebrated\",{\"1\":{\"228\":1}}],[\"centimeters\",{\"1\":{\"179\":6}}],[\"cillum\",{\"1\":{\"288\":2}}],[\"city\",{\"1\":{\"251\":7}}],[\"civilians\",{\"1\":{\"203\":1}}],[\"civilian`\",{\"1\":{\"203\":1}}],[\"civilian\",{\"1\":{\"203\":3}}],[\"circle\",{\"1\":{\"50\":12}}],[\"culpa\",{\"1\":{\"288\":2}}],[\"cupidatat\",{\"1\":{\"288\":2}}],[\"custom\",{\"0\":{\"319\":1},\"1\":{\"200\":4}}],[\"current\",{\"1\":{\"219\":2}}],[\"curr`\",{\"1\":{\"186\":1}}],[\"curr\",{\"1\":{\"186\":5}}],[\"cube\",{\"1\":{\"8\":2}}],[\"ccosf\",{\"1\":{\"159\":2}}],[\"csqrtf\",{\"1\":{\"159\":2}}],[\"class\",{\"1\":{\"284\":1}}],[\"classified\",{\"1\":{\"129\":2}}],[\"clap\",{\"1\":{\"44\":6,\"157\":1}}],[\"closed\",{\"1\":{\"129\":4}}],[\"closedbox\",{\"1\":{\"129\":3}}],[\"closedbox<t>\",{\"1\":{\"129\":3}}],[\"closures\",{\"0\":{\"343\":1}}],[\"closure\",{\"0\":{\"358\":1},\"1\":{\"83\":9,\"167\":1,\"185\":2,\"238\":3}}],[\"cloned\",{\"1\":{\"149\":1,\"178\":2}}],[\"clone\",{\"0\":{\"178\":1},\"1\":{\"0\":1,\"144\":2,\"145\":1,\"149\":1,\"158\":1,\"159\":1,\"178\":8,\"179\":1,\"181\":1,\"207\":1,\"209\":1,\"219\":2,\"249\":3,\"261\":1,\"263\":1}}],[\"clicked\",{\"1\":{\"57\":1}}],[\"click\",{\"1\":{\"57\":5}}],[\"cli\",{\"1\":{\"44\":1}}],[\"cardinal\",{\"1\":{\"247\":6}}],[\"carrot\",{\"1\":{\"217\":6}}],[\"cargo\",{\"0\":{\"2\":1,\"316\":1},\"1\":{\"0\":1,\"2\":2,\"15\":1,\"38\":2,\"41\":6,\"42\":5,\"43\":6,\"44\":15,\"45\":7,\"117\":3,\"168\":2,\"169\":1,\"170\":2,\"173\":3,\"174\":2,\"175\":1,\"176\":3,\"177\":3}}],[\"cause\",{\"1\":{\"207\":1}}],[\"case\",{\"1\":{\"191\":1,\"205\":1}}],[\"casting\",{\"1\":{\"193\":2}}],[\"cast\",{\"1\":{\"31\":1}}],[\"camel\",{\"1\":{\"191\":1}}],[\"capture\",{\"1\":{\"235\":1}}],[\"capital\",{\"1\":{\"153\":1}}],[\"capacity\",{\"1\":{\"146\":1,\"158\":1}}],[\"cat\",{\"1\":{\"152\":1,\"161\":5,\"288\":1}}],[\"calculate\",{\"1\":{\"112\":3,\"116\":5}}],[\"calls\",{\"1\":{\"186\":1}}],[\"calling\",{\"1\":{\"146\":3}}],[\"call\",{\"1\":{\"84\":2,\"131\":3,\"133\":3,\"146\":5,\"238\":3}}],[\"called\",{\"1\":{\"38\":3,\"53\":3,\"54\":3,\"110\":1,\"128\":12,\"131\":5,\"132\":2,\"133\":12,\"153\":1,\"187\":2}}],[\"cannot\",{\"1\":{\"146\":1,\"209\":1}}],[\"can\",{\"1\":{\"42\":1,\"84\":1,\"146\":1,\"153\":3,\"240\":1}}],[\"chunked\",{\"1\":{\"293\":2}}],[\"check\",{\"1\":{\"287\":3}}],[\"checked\",{\"1\":{\"147\":2,\"151\":4,\"286\":2}}],[\"christian\",{\"1\":{\"254\":1}}],[\"choose\",{\"1\":{\"272\":2}}],[\"chop\",{\"1\":{\"217\":3}}],[\"chopped\",{\"1\":{\"217\":5}}],[\"chosen\",{\"1\":{\"184\":1}}],[\"children\",{\"1\":{\"167\":4,\"293\":3}}],[\"child\",{\"1\":{\"166\":1,\"167\":2,\"228\":1,\"291\":1,\"292\":4,\"293\":2}}],[\"chicken\",{\"1\":{\"68\":1}}],[\"chinese\",{\"1\":{\"15\":1}}],[\"chain\",{\"1\":{\"185\":2}}],[\"chain<intoiter<i32>\",{\"1\":{\"185\":1}}],[\"channel\",{\"1\":{\"158\":2,\"293\":1}}],[\"channels\",{\"1\":{\"26\":1}}],[\"character\",{\"1\":{\"153\":3,\"193\":2}}],[\"characters\",{\"1\":{\"152\":1}}],[\"chars\",{\"1\":{\"152\":7,\"293\":1}}],[\"char\",{\"1\":{\"11\":2,\"20\":1,\"57\":2,\"152\":1,\"193\":1}}],[\"char`\",{\"1\":{\"11\":1}}],[\"ctrl\",{\"1\":{\"13\":1}}],[\"c++\",{\"1\":{\"10\":1,\"135\":1}}],[\"couldn\",{\"1\":{\"288\":2,\"289\":2,\"291\":3}}],[\"count`\",{\"1\":{\"235\":3}}],[\"counter\",{\"1\":{\"227\":4}}],[\"counted\",{\"1\":{\"144\":1}}],[\"counting\",{\"1\":{\"149\":1}}],[\"counts\",{\"1\":{\"141\":1,\"148\":1}}],[\"count\",{\"1\":{\"78\":6,\"149\":8,\"235\":6,\"310\":2}}],[\"coerced\",{\"1\":{\"275\":3}}],[\"coerce\",{\"1\":{\"275\":2}}],[\"coercion\",{\"1\":{\"193\":1}}],[\"correlation\",{\"1\":{\"231\":1}}],[\"cordon\",{\"1\":{\"215\":3}}],[\"cordonbleu\",{\"1\":{\"215\":3}}],[\"color\",{\"1\":{\"201\":3,\"235\":5,\"251\":6,\"252\":1,\"296\":16}}],[\"collected\",{\"1\":{\"154\":4}}],[\"collect\",{\"1\":{\"63\":1,\"64\":1,\"65\":1,\"66\":2,\"111\":3,\"152\":1,\"154\":1,\"156\":1,\"285\":6,\"287\":1}}],[\"collections\",{\"1\":{\"146\":1,\"284\":1,\"285\":1}}],[\"collection\",{\"1\":{\"15\":1,\"186\":1,\"284\":1,\"285\":2}}],[\"cow\",{\"1\":{\"184\":3}}],[\"cos\",{\"1\":{\"159\":3}}],[\"coordinate\",{\"1\":{\"259\":1}}],[\"coordinates\",{\"1\":{\"60\":1,\"259\":4}}],[\"cook\",{\"1\":{\"217\":3}}],[\"cooked\",{\"1\":{\"217\":9}}],[\"cookable\",{\"1\":{\"215\":4}}],[\"cookbook\",{\"1\":{\"157\":1}}],[\"cool\",{\"1\":{\"131\":5}}],[\"copy\",{\"1\":{\"145\":1,\"159\":1,\"178\":4,\"179\":2,\"219\":2,\"235\":1,\"249\":3,\"261\":1,\"263\":2}}],[\"copyright\",{\"1\":{\"141\":2,\"148\":2}}],[\"copy>\",{\"1\":{\"111\":1}}],[\"copied\",{\"1\":{\"35\":2,\"178\":2}}],[\"combinator\",{\"1\":{\"217\":1}}],[\"combine\",{\"1\":{\"185\":3}}],[\"commodo\",{\"1\":{\"288\":2}}],[\"common\",{\"1\":{\"173\":4}}],[\"commoner\",{\"1\":{\"68\":5}}],[\"comments\",{\"1\":{\"123\":1}}],[\"command\",{\"1\":{\"44\":1,\"141\":1,\"148\":1,\"166\":3,\"287\":2,\"291\":2,\"292\":3}}],[\"compatibility\",{\"0\":{\"315\":1}}],[\"compare\",{\"1\":{\"97\":5,\"256\":2}}],[\"comp\",{\"1\":{\"189\":1}}],[\"computer\",{\"1\":{\"189\":1}}],[\"compscistudent\",{\"1\":{\"189\":4}}],[\"complex\",{\"1\":{\"159\":9,\"257\":2}}],[\"completed\",{\"1\":{\"146\":1}}],[\"compiling\",{\"1\":{\"45\":2}}],[\"compound\",{\"0\":{\"21\":1}}],[\"com\",{\"1\":{\"44\":1,\"284\":1}}],[\"conditional\",{\"1\":{\"200\":2}}],[\"condition\",{\"1\":{\"200\":4}}],[\"conversion\",{\"0\":{\"317\":1},\"1\":{\"153\":2}}],[\"convert\",{\"1\":{\"47\":1,\"48\":1,\"52\":2,\"107\":1}}],[\"control\",{\"0\":{\"321\":1}}],[\"contain\",{\"1\":{\"244\":1,\"246\":1}}],[\"container\",{\"1\":{\"244\":12,\"246\":14,\"256\":1}}],[\"contains>\",{\"1\":{\"246\":2}}],[\"contains<i32\",{\"1\":{\"244\":1}}],[\"contains<a\",{\"1\":{\"244\":2,\"246\":1}}],[\"containstrait\",{\"1\":{\"244\":1,\"246\":1}}],[\"contains\",{\"1\":{\"60\":2,\"129\":2,\"138\":1,\"140\":4,\"235\":4,\"244\":4,\"246\":7,\"281\":3,\"285\":1,\"289\":2}}],[\"contact\",{\"1\":{\"146\":2}}],[\"contacts\",{\"1\":{\"146\":10}}],[\"contexts\",{\"1\":{\"141\":1,\"148\":1}}],[\"contents\",{\"1\":{\"129\":9,\"154\":1}}],[\"continue\",{\"1\":{\"78\":2,\"84\":2,\"226\":2}}],[\"concurrency\",{\"1\":{\"15\":1}}],[\"consequat\",{\"1\":{\"288\":2}}],[\"consectetur\",{\"1\":{\"288\":2}}],[\"consecutive\",{\"1\":{\"186\":1}}],[\"consume\",{\"1\":{\"235\":3}}],[\"cons\",{\"1\":{\"205\":5}}],[\"console\",{\"1\":{\"13\":1}}],[\"construct\",{\"1\":{\"136\":1}}],[\"constructor\",{\"1\":{\"86\":1}}],[\"const\",{\"1\":{\"6\":1,\"33\":1,\"55\":2,\"56\":1}}],[\"constant\",{\"1\":{\"6\":1,\"275\":1}}],[\"codepoint\",{\"1\":{\"153\":2}}],[\"code`\",{\"1\":{\"39\":1}}],[\"code\",{\"0\":{\"39\":1},\"1\":{\"0\":1,\"32\":1,\"39\":3,\"57\":1,\"60\":1,\"89\":1,\"107\":3,\"109\":1,\"128\":2,\"129\":1,\"133\":2,\"145\":2,\"174\":1,\"191\":1,\"201\":1,\"203\":1,\"215\":1,\"217\":1,\"219\":5,\"226\":1,\"261\":1,\"296\":1}}],[\"created\",{\"1\":{\"149\":1}}],[\"create\",{\"0\":{\"288\":1},\"1\":{\"0\":1,\"110\":3,\"141\":2,\"161\":4,\"242\":6,\"288\":5}}],[\"crates\",{\"0\":{\"318\":1},\"1\":{\"2\":1,\"44\":3}}],[\"crate\",{\"0\":{\"5\":1,\"38\":1,\"157\":1},\"1\":{\"0\":2,\"1\":5,\"5\":7,\"15\":3,\"38\":11,\"40\":3,\"41\":1,\"42\":1,\"44\":6,\"53\":4,\"54\":2,\"105\":1,\"118\":2,\"121\":1,\"131\":3,\"133\":9,\"153\":1,\"157\":2,\"168\":2,\"170\":2,\"173\":5}}],[\"cfg\",{\"0\":{\"36\":1,\"336\":1},\"1\":{\"0\":1,\"36\":7,\"37\":1,\"161\":1,\"162\":1,\"168\":1,\"174\":2,\"175\":1,\"177\":1,\"200\":5}}],[\"c\",{\"0\":{\"201\":1},\"1\":{\"0\":1,\"7\":1,\"10\":1,\"16\":1,\"57\":2,\"60\":2,\"76\":4,\"79\":1,\"91\":1,\"135\":3,\"136\":2,\"140\":2,\"141\":1,\"148\":1,\"152\":2,\"159\":2,\"161\":20,\"183\":2,\"193\":2,\"201\":1,\"209\":1,\"244\":3,\"246\":4,\"251\":4,\"263\":3,\"293\":1,\"296\":4,\"298\":1}}],[\"枚举类型\",{\"1\":{\"151\":1,\"214\":1,\"295\":1}}],[\"枚举类型可以用作可能失败的函数的返回值\",{\"1\":{\"151\":1}}],[\"枚举类型来实现\",{\"1\":{\"147\":1}}],[\"枚举\",{\"0\":{\"57\":1,\"296\":1},\"1\":{\"0\":2,\"15\":1,\"57\":1,\"77\":1,\"82\":1,\"229\":1}}],[\"duis\",{\"1\":{\"288\":2}}],[\"dublin\",{\"1\":{\"251\":1}}],[\"d`\",{\"1\":{\"161\":4}}],[\"data\",{\"1\":{\"293\":9}}],[\"day\",{\"1\":{\"215\":8}}],[\"days\",{\"1\":{\"99\":9,\"107\":1}}],[\"daniel\",{\"1\":{\"146\":5}}],[\"dangling\",{\"1\":{\"140\":1}}],[\"d>\",{\"1\":{\"103\":3}}],[\"d\",{\"1\":{\"103\":2,\"136\":2,\"141\":1,\"148\":1,\"161\":2,\"183\":2}}],[\"d3b32b97275ec472\",{\"1\":{\"45\":2}}],[\"dolore\",{\"1\":{\"288\":4}}],[\"dolor\",{\"1\":{\"288\":4}}],[\"dolly\",{\"1\":{\"30\":5}}],[\"do\",{\"1\":{\"287\":2,\"288\":2}}],[\"douglas\",{\"1\":{\"261\":1}}],[\"doubleerror\",{\"1\":{\"209\":5,\"213\":11}}],[\"doubleerror>\",{\"1\":{\"209\":1,\"213\":1}}],[\"doubledrop<t>\",{\"1\":{\"93\":2}}],[\"doubled\",{\"1\":{\"67\":3,\"207\":1,\"209\":1,\"210\":6,\"211\":1,\"213\":1,\"240\":1}}],[\"double\",{\"1\":{\"67\":4,\"70\":2,\"93\":3,\"153\":1,\"185\":1,\"207\":6,\"209\":5,\"210\":8,\"211\":5,\"213\":4,\"240\":2,\"277\":2}}],[\"does\",{\"1\":{\"244\":1,\"246\":1,\"256\":1}}],[\"doesn\",{\"1\":{\"210\":1,\"304\":2}}],[\"doing\",{\"1\":{\"153\":1}}],[\"dogs\",{\"1\":{\"152\":1}}],[\"dog\",{\"1\":{\"107\":1,\"152\":2,\"291\":1}}],[\"doccomments\",{\"1\":{\"170\":4}}],[\"documentation\",{\"1\":{\"123\":1}}],[\"doc=\",{\"1\":{\"118\":1}}],[\"doc\",{\"1\":{\"28\":1,\"83\":1,\"117\":3,\"118\":4,\"119\":1,\"120\":1,\"121\":1,\"122\":1,\"126\":1,\"170\":1,\"173\":1,\"175\":1,\"176\":2,\"177\":2}}],[\"domain\",{\"1\":{\"16\":1}}],[\"done\",{\"1\":{\"185\":1}}],[\"don\",{\"1\":{\"16\":1,\"76\":1,\"111\":1,\"146\":2,\"153\":1,\"215\":1}}],[\"digit\",{\"1\":{\"293\":2}}],[\"difference<c\",{\"1\":{\"246\":2}}],[\"difference<a\",{\"1\":{\"244\":1,\"246\":1}}],[\"difference\",{\"1\":{\"244\":4,\"246\":2,\"285\":6}}],[\"diary\",{\"1\":{\"240\":2}}],[\"dialed\",{\"1\":{\"146\":1}}],[\"discriminator\",{\"1\":{\"201\":2}}],[\"display`\",{\"1\":{\"254\":1,\"256\":3}}],[\"display的类型才能使用\",{\"1\":{\"107\":1}}],[\"display>\",{\"1\":{\"89\":2,\"97\":1}}],[\"display\",{\"0\":{\"256\":1,\"359\":1},\"1\":{\"0\":1,\"50\":2,\"89\":2,\"97\":2,\"107\":4,\"137\":3,\"153\":1,\"164\":2,\"207\":1,\"209\":1,\"211\":1,\"213\":1,\"251\":4,\"252\":1,\"254\":2,\"256\":11,\"257\":1,\"288\":5,\"289\":5,\"310\":3}}],[\"dir\",{\"1\":{\"161\":4}}],[\"directory\",{\"1\":{\"41\":1,\"161\":1,\"200\":1}}],[\"dimension\",{\"1\":{\"111\":1}}],[\"div\",{\"1\":{\"151\":2,\"170\":5,\"171\":2,\"286\":2}}],[\"divide\",{\"1\":{\"170\":1,\"171\":1,\"175\":9}}],[\"dividend\",{\"1\":{\"147\":6,\"148\":2}}],[\"divisor\",{\"1\":{\"147\":7,\"148\":3}}],[\"divisionbyzero\",{\"1\":{\"151\":2,\"286\":3}}],[\"division\",{\"1\":{\"147\":5,\"148\":4,\"170\":1,\"286\":1}}],[\"divisible\",{\"1\":{\"10\":4}}],[\"diverging\",{\"1\":{\"84\":1}}],[\"didn\",{\"1\":{\"76\":2}}],[\"dsl\",{\"0\":{\"112\":1},\"1\":{\"0\":1,\"16\":1,\"112\":1}}],[\"dry\",{\"0\":{\"111\":1},\"1\":{\"0\":1,\"16\":1,\"111\":4}}],[\"drop`\",{\"1\":{\"235\":1}}],[\"dropping\",{\"1\":{\"183\":1}}],[\"droppable\",{\"1\":{\"183\":6}}],[\"dropped\",{\"1\":{\"142\":1,\"149\":2}}],[\"droptrait\",{\"1\":{\"93\":1}}],[\"drop\",{\"0\":{\"183\":1},\"1\":{\"0\":1,\"93\":4,\"94\":1,\"121\":1,\"142\":5,\"178\":2,\"183\":9,\"235\":1,\"236\":1,\"240\":2,\"241\":1,\"289\":1}}],[\"dyn\",{\"0\":{\"184\":1},\"1\":{\"0\":1,\"184\":1,\"189\":1,\"207\":1,\"209\":1,\"213\":1}}],[\"dereferencing\",{\"1\":{\"298\":1}}],[\"dereference\",{\"1\":{\"298\":1}}],[\"derive\",{\"1\":{\"47\":1,\"48\":1,\"52\":1,\"60\":1,\"76\":2,\"89\":1,\"101\":2,\"102\":1,\"136\":1,\"145\":1,\"151\":1,\"159\":1,\"178\":2,\"179\":3,\"180\":1,\"187\":2,\"207\":1,\"209\":1,\"211\":1,\"213\":1,\"215\":2,\"217\":4,\"219\":2,\"249\":3,\"251\":1,\"254\":5,\"255\":1,\"256\":2,\"258\":1,\"261\":1,\"263\":1,\"270\":1,\"277\":3,\"279\":1,\"282\":1,\"284\":2,\"286\":1}}],[\"deep\",{\"1\":{\"254\":2}}],[\"deeply\",{\"1\":{\"132\":4}}],[\"delimiter\",{\"1\":{\"153\":2}}],[\"dedup\",{\"1\":{\"152\":1}}],[\"detected\",{\"1\":{\"141\":1,\"148\":1}}],[\"detector\",{\"1\":{\"141\":1,\"148\":1}}],[\"decrease\",{\"1\":{\"287\":6}}],[\"declare\",{\"1\":{\"196\":1}}],[\"deconstruct\",{\"1\":{\"136\":1}}],[\"decimal\",{\"1\":{\"60\":2,\"193\":4}}],[\"deserunt\",{\"1\":{\"288\":2}}],[\"description\",{\"1\":{\"207\":1}}],[\"descriptor\",{\"1\":{\"163\":1,\"289\":1}}],[\"destructure\",{\"1\":{\"298\":1}}],[\"destructuring\",{\"0\":{\"357\":1},\"1\":{\"295\":1,\"298\":1}}],[\"destructor\",{\"1\":{\"141\":1}}],[\"destroying\",{\"1\":{\"86\":1,\"138\":1,\"140\":1}}],[\"destroy\",{\"1\":{\"86\":3,\"140\":2}}],[\"designator\",{\"1\":{\"110\":1}}],[\"deps\",{\"1\":{\"45\":2,\"173\":1}}],[\"dependencies\",{\"1\":{\"44\":4,\"168\":2}}],[\"dev\",{\"1\":{\"45\":2,\"168\":2}}],[\"definitely\",{\"1\":{\"36\":2}}],[\"default\",{\"1\":{\"21\":2,\"41\":1,\"179\":1,\"279\":4}}],[\"dead\",{\"0\":{\"39\":1},\"1\":{\"0\":1,\"39\":3,\"57\":1,\"60\":1,\"89\":1,\"107\":3,\"109\":1,\"128\":2,\"129\":1,\"133\":2,\"145\":2,\"174\":1,\"201\":1,\"203\":1,\"215\":1,\"217\":1,\"261\":1,\"296\":1}}],[\"debugprintable\",{\"1\":{\"254\":1}}],[\"debug`\",{\"1\":{\"103\":2,\"254\":3}}],[\"debug>\",{\"1\":{\"89\":1,\"97\":1}}],[\"debug<t\",{\"1\":{\"89\":1}}],[\"debuginfo\",{\"1\":{\"45\":2}}],[\"debug\",{\"0\":{\"254\":1},\"1\":{\"0\":1,\"42\":1,\"45\":2,\"47\":1,\"48\":1,\"52\":1,\"60\":2,\"89\":4,\"97\":4,\"103\":2,\"107\":1,\"136\":1,\"137\":1,\"145\":1,\"151\":1,\"159\":1,\"173\":1,\"178\":2,\"179\":2,\"187\":2,\"207\":1,\"209\":1,\"211\":1,\"213\":1,\"215\":2,\"217\":4,\"249\":3,\"251\":1,\"254\":7,\"256\":7,\"257\":1,\"270\":4,\"277\":3,\"279\":1,\"282\":1,\"286\":1}}]],\"version\":2}}")).map(([e,t])=>[e,It(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const r=Ct[s];e==="suggest"?self.postMessage([e,o,et(t,r,n)]):e==="search"?self.postMessage([e,o,tt(t,r,n)]):self.postMessage({suggestions:[e,o,et(t,r,n)],results:[e,o,tt(t,r,n)]})};
//# sourceMappingURL=index.js.map
