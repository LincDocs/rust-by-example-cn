import{_ as e,e as n,k as a,o as t}from"./app-CY03Lsxp.js";const i={};function l(p,s){return t(),n("div",null,s[0]||(s[0]=[a(`<h1 id="散列集-hashset" tabindex="-1"><a class="header-anchor" href="#散列集-hashset"><span>散列集 HashSet</span></a></h1><p>请把 <code>HashSet</code> 当成这样一个 <code>HashMap</code>：我们只关心其中的键而非值（<code>HashSet&lt;T&gt;</code><br> 实际上只是对 <code>HashMap&lt;T, ()&gt;</code> 的封装）。</p><p>你可能会问：“这有什么意义呢？我完全可以将键存储到一个 <code>Vec</code> 中呀。”</p><p><code>HashSet</code> 的独特之处在于，它保证了不会出现重复的元素。这是任何 set 集合类型（set<br> collection）遵循的规定。<code>HashSet</code> 只是它的一个实现。（参见：<a href="https://rustwiki.org/zh-CN/std/collections/struct.BTreeSet.html" target="_blank" rel="noopener noreferrer"><code>BTreeSet</code></a>）</p><p>如果插入的值已经存在于 <code>HashSet</code> 中（也就是，新值等于已存在的值，并且拥有相同的散列值），那么新值将会替换旧的值。</p><p>如果你不想要一样东西出现多于一次，或者你要判断一样东西是不是已经存在，这种做法就很有用了。</p><p>不过集合（set）可以做更多的事。</p><p>集合（set）拥有 4 种基本操作（下面的调用全部都返回一个迭代器）：</p><ul><li><p><code>union</code>（并集）：获得两个集合中的所有元素（不含重复值）。</p></li><li><p><code>difference</code>（差集）：获取属于第一个集合而不属于第二集合的所有元素。</p></li><li><p><code>intersection</code>（交集）：获取同时属于两个集合的所有元素。</p></li><li><p><code>symmetric_difference</code>（对称差）：获取所有只属于其中一个集合，而不同时属于<br> 两个集合的所有元素。</p></li></ul><p>在下面的例子中尝试使用这些操作。</p><div class="language-rust,editable,ignore,mdbook-runnable line-numbers-mode" data-highlighter="shiki" data-ext="rust,editable,ignore,mdbook-runnable" data-title="rust,editable,ignore,mdbook-runnable" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>use std::collections::HashSet;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>fn main() {</span></span>
<span class="line"><span>    let mut a: HashSet&lt;i32&gt; = vec!(1i32, 2, 3).into_iter().collect();</span></span>
<span class="line"><span>    let mut b: HashSet&lt;i32&gt; = vec!(2i32, 3, 4).into_iter().collect();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    assert!(a.insert(4));</span></span>
<span class="line"><span>    assert!(a.contains(&amp;4));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 如果值已经存在，那么 \`HashSet::insert()\` 返回 false。</span></span>
<span class="line"><span>    assert!(b.insert(4), &quot;Value 4 is already in set B!&quot;);</span></span>
<span class="line"><span>    // 改正 ^ 将此行注释掉。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    b.insert(5);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 若一个集合（collection）的元素类型实现了 \`Debug\`，那么该集合也就实现了 \`Debug\`。</span></span>
<span class="line"><span>    // 这通常将元素打印成这样的格式 \`[elem1, elem2, ...]</span></span>
<span class="line"><span>    println!(&quot;A: {:?}&quot;, a);</span></span>
<span class="line"><span>    println!(&quot;B: {:?}&quot;, b);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 乱序打印 [1, 2, 3, 4, 5]。</span></span>
<span class="line"><span>    println!(&quot;Union: {:?}&quot;, a.union(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 这将会打印出 [1]</span></span>
<span class="line"><span>    println!(&quot;Difference: {:?}&quot;, a.difference(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 乱序打印 [2, 3, 4]。</span></span>
<span class="line"><span>    println!(&quot;Intersection: {:?}&quot;, a.intersection(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 打印 [1, 5]</span></span>
<span class="line"><span>    println!(&quot;Symmetric Difference: {:?}&quot;,</span></span>
<span class="line"><span>             a.symmetric_difference(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（例子改编自<a href="https://rustwiki.org/zh-CN/std/collections/struct.HashSet.html#method.difference" target="_blank" rel="noopener noreferrer">文档</a>。）</p>`,12)]))}const d=e(i,[["render",l],["__file","hashset.html.vue"]]),r=JSON.parse('{"path":"/std/hash/hashset.html","title":"散列集 HashSet","lang":"zh-CN","frontmatter":{"description":"散列集 HashSet 请把 HashSet 当成这样一个 HashMap：我们只关心其中的键而非值（HashSet<T> 实际上只是对 HashMap<T, ()> 的封装）。 你可能会问：“这有什么意义呢？我完全可以将键存储到一个 Vec 中呀。” HashSet 的独特之处在于，它保证了不会出现重复的元素。这是任何 set 集合类型（set co...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/rust-by-example-cn/std/hash/hashset.html"}],["meta",{"property":"og:site_name","content":"rust-by-example-cn"}],["meta",{"property":"og:title","content":"散列集 HashSet"}],["meta",{"property":"og:description","content":"散列集 HashSet 请把 HashSet 当成这样一个 HashMap：我们只关心其中的键而非值（HashSet<T> 实际上只是对 HashMap<T, ()> 的封装）。 你可能会问：“这有什么意义呢？我完全可以将键存储到一个 Vec 中呀。” HashSet 的独特之处在于，它保证了不会出现重复的元素。这是任何 set 集合类型（set co..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"散列集 HashSet\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/rust-by-example-cn/\\"}]}"]]},"git":{},"readingTime":{"minutes":1.86,"words":557},"filePathRelative":"std/hash/hashset.md","excerpt":"\\n<p>请把 <code>HashSet</code> 当成这样一个 <code>HashMap</code>：我们只关心其中的键而非值（<code>HashSet&lt;T&gt;</code><br>\\n实际上只是对 <code>HashMap&lt;T, ()&gt;</code> 的封装）。</p>\\n<p>你可能会问：“这有什么意义呢？我完全可以将键存储到一个 <code>Vec</code> 中呀。”</p>\\n<p><code>HashSet</code> 的独特之处在于，它保证了不会出现重复的元素。这是任何 set 集合类型（set<br>\\ncollection）遵循的规定。<code>HashSet</code> 只是它的一个实现。（参见：<a href=\\"https://rustwiki.org/zh-CN/std/collections/struct.BTreeSet.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\"><code>BTreeSet</code></a>）</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"std/hash/hashset.md","value":{"title":"hashset","path":"std/hash/hashset.md","outlink":[],"backlink":["SUMMARY.md"]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"SUMMARY.md","target":"std/hash/hashset.md"}]}}}');export{d as comp,r as data};
