import{_ as a,e as t,f as i,k as l,i as n,g as p,h as r,r as d,o as h}from"./app-CVSWwIkE.js";const c={};function k(o,s){const e=d("RouteLink");return h(),t("div",null,[s[3]||(s[3]=i("h1",{id:"类型匿名",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#类型匿名"},[i("span",null,"类型匿名")])],-1)),i("p",null,[s[1]||(s[1]=n("闭包从周围的作用域中捕获变量是简单明了的。这样会有某些后果吗？确实有。观察一下使用闭包作为函数参数，这要求闭包是")),p(e,{to:"/generics.html"},{default:r(()=>s[0]||(s[0]=[n("泛型")])),_:1}),s[2]||(s[2]=n("的，闭包定义的方式决定了这是必要的。"))]),s[4]||(s[4]=l(`<div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// \`F\` 必须是泛型的。</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> apply</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">F</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">f</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">F</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">    F</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">FnOnce</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    f</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当闭包被定义，编译器会隐式地创建一个匿名类型的结构体，用以储存闭包捕获的变量，同时为这个未知类型的结构体实现函数功能，通过 <code>Fn</code>、<code>FnMut</code> 或 <code>FnOnce</code> 三种 <code>trait</code> 中的一种。</p><p>若使用闭包作为函数参数，由于这个结构体的类型未知，任何的用法都要求是泛型的。然而，使用未限定类型的参数 <code>&lt;T&gt;</code> 过于不明确，并且是不允许的。事实上，指明为该结构体实现的是 <code>Fn</code>、<code>FnMut</code>、或 <code>FnOnce</code> 中的哪种 <code>trait</code>，对于约束该结构体的类型而言就已经足够了。</p><div class="language-rust,editable line-numbers-mode" data-highlighter="shiki" data-ext="rust,editable" data-title="rust,editable" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// \`F\` 必须为一个没有输入参数和返回值的闭包实现 \`Fn\`，这和对 \`print\` 的</span></span>
<span class="line"><span>// 要求恰好一样。</span></span>
<span class="line"><span>fn apply&lt;F&gt;(f: F) where</span></span>
<span class="line"><span>    F: Fn() {</span></span>
<span class="line"><span>    f();</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>fn main() {</span></span>
<span class="line"><span>    let x = 7;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 捕获 \`x\` 到匿名类型中，并为它实现 \`Fn\`。</span></span>
<span class="line"><span>    // 将闭包存储到 \`print\` 中。</span></span>
<span class="line"><span>    let print = || println!(&quot;{}&quot;, x);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    apply(print);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="参见" tabindex="-1"><a class="header-anchor" href="#参见"><span>参见：</span></a></h3><p><a href="https://huonw.github.io/blog/2015/05/finding-closure-in-rust/" target="_blank" rel="noopener noreferrer">详尽分析</a>, <a href="https://rustwiki.org/zh-CN/std/ops/trait.Fn.html" target="_blank" rel="noopener noreferrer"><code>Fn</code></a>, <a href="https://rustwiki.org/zh-CN/std/ops/trait.FnMut.html" target="_blank" rel="noopener noreferrer"><code>FnMut</code></a>,<br> 和 <a href="https://rustwiki.org/zh-CN/std/ops/trait.FnOnce.html" target="_blank" rel="noopener noreferrer"><code>FnOnce</code></a></p>`,6))])}const u=a(c,[["render",k],["__file","anonymity.html.vue"]]),g=JSON.parse('{"path":"/fn/closures/anonymity.html","title":"类型匿名","lang":"zh-CN","frontmatter":{"description":"类型匿名 闭包从周围的作用域中捕获变量是简单明了的。这样会有某些后果吗？确实有。观察一下使用闭包作为函数参数，这要求闭包是的，闭包定义的方式决定了这是必要的。 当闭包被定义，编译器会隐式地创建一个匿名类型的结构体，用以储存闭包捕获的变量，同时为这个未知类型的结构体实现函数功能，通过 Fn、FnMut 或 FnOnce 三种 trait 中的一种。 若使...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/rust-by-example-cn-/fn/closures/anonymity.html"}],["meta",{"property":"og:site_name","content":"rust-by-example-cn-"}],["meta",{"property":"og:title","content":"类型匿名"}],["meta",{"property":"og:description","content":"类型匿名 闭包从周围的作用域中捕获变量是简单明了的。这样会有某些后果吗？确实有。观察一下使用闭包作为函数参数，这要求闭包是的，闭包定义的方式决定了这是必要的。 当闭包被定义，编译器会隐式地创建一个匿名类型的结构体，用以储存闭包捕获的变量，同时为这个未知类型的结构体实现函数功能，通过 Fn、FnMut 或 FnOnce 三种 trait 中的一种。 若使..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"类型匿名\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/rust-by-example-cn-/\\"}]}"]]},"git":{},"readingTime":{"minutes":1.26,"words":379},"filePathRelative":"fn/closures/anonymity.md","excerpt":"\\n<p>闭包从周围的作用域中捕获变量是简单明了的。这样会有某些后果吗？确实有。观察一下使用闭包作为函数参数，这要求闭包是<a href=\\"/rust-by-example-cn-/generics.html\\" target=\\"_blank\\">泛型</a>的，闭包定义的方式决定了这是必要的。</p>\\n<div class=\\"language-rust line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"rust\\" data-title=\\"rust\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span style=\\"--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic\\">// `F` 必须是泛型的。</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">fn</span><span style=\\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\\"> apply</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">&lt;</span><span style=\\"--shiki-light:#0184BC;--shiki-dark:#E5C07B\\">F</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">&gt;(</span><span style=\\"--shiki-light:#E45649;--shiki-dark:#E06C75\\">f</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">: </span><span style=\\"--shiki-light:#0184BC;--shiki-dark:#E5C07B\\">F</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">) </span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">where</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#0184BC;--shiki-dark:#E5C07B\\">    F</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">: </span><span style=\\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\\">FnOnce</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">() {</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\\">    f</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">();</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">}</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true,"bioChainData":{"outlink":[{"title":"generics","link":"generics.html"}],"backlink":[{"title":"SUMMARY","link":"SUMMARY.html"},{"title":"explicit","link":"scope/lifetime/explicit.html"}],"localMap":{"nodes":[{"id":"fn/closures/anonymity.md","value":{"title":"anonymity","path":"fn/closures/anonymity.md","outlink":["generics.md"],"backlink":["SUMMARY.md","scope/lifetime/explicit.md"]}},{"id":"generics.md","value":{"title":"generics","path":"generics.md","outlink":[],"backlink":[]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}},{"id":"scope/lifetime/explicit.md","value":{"title":"explicit","path":"scope/lifetime/explicit.md","outlink":[],"backlink":[]}}],"links":[{"source":"fn/closures/anonymity.md","target":"generics.md"},{"source":"SUMMARY.md","target":"fn/closures/anonymity.md"},{"source":"scope/lifetime/explicit.md","target":"fn/closures/anonymity.md"}]}}}');export{u as comp,g as data};
