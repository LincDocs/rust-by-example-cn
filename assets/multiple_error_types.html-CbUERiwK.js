import{_ as s,e as n,k as t,o as i}from"./app-CVSWwIkE.js";const a={};function l(r,e){return i(),n("div",null,e[0]||(e[0]=[t(`<h1 id="处理多种错误类型" tabindex="-1"><a class="header-anchor" href="#处理多种错误类型"><span>处理多种错误类型</span></a></h1><p>前面出现的例子都是很方便的情况；都是 <code>Result</code> 和其他 <code>Result</code> 交互，还有 <code>Option</code><br> 和其他 <code>Option</code> 交互。</p><p>有时 <code>Option</code> 需要和 <code>Result</code> 进行交互，或是 <code>Result&lt;T, Error1&gt;</code> 需要和<br><code>Result&lt;T, Error2&gt;</code> 进行交互。在这类情况下，我们想要以一种方式来管理不同的错误类型，使得它们可组合且易于交互。</p><p>在下面代码中，<code>unwrap</code> 的两个实例生成了不同的错误类型。<code>Vec::first</code> 返回一个<br><code>Option</code>，而 <code>parse::&lt;i32&gt;</code> 返回一个 <code>Result&lt;i32, ParseIntError&gt;</code>：</p><div class="language-rust,editable,ignore,mdbook-runnable line-numbers-mode" data-highlighter="shiki" data-ext="rust,editable,ignore,mdbook-runnable" data-title="rust,editable,ignore,mdbook-runnable" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; i32 {</span></span>
<span class="line"><span>    let first = vec.first().unwrap(); // 生成错误 1</span></span>
<span class="line"><span>    2 * first.parse::&lt;i32&gt;().unwrap() // 生成错误 2</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>fn main() {</span></span>
<span class="line"><span>    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];</span></span>
<span class="line"><span>    let empty = vec![];</span></span>
<span class="line"><span>    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    println!(&quot;The first doubled is {}&quot;, double_first(numbers));</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    println!(&quot;The first doubled is {}&quot;, double_first(empty));</span></span>
<span class="line"><span>    // 错误1：输入 vector 为空</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    println!(&quot;The first doubled is {}&quot;, double_first(strings));</span></span>
<span class="line"><span>    // 错误2：此元素不能解析成数字</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在下面几节中，我们会看到处理这类问题的几种策略。</p>`,6)]))}const p=s(a,[["render",l],["__file","multiple_error_types.html.vue"]]),c=JSON.parse('{"path":"/error/multiple_error_types.html","title":"处理多种错误类型","lang":"zh-CN","frontmatter":{"description":"处理多种错误类型 前面出现的例子都是很方便的情况；都是 Result 和其他 Result 交互，还有 Option 和其他 Option 交互。 有时 Option 需要和 Result 进行交互，或是 Result<T, Error1> 需要和 Result<T, Error2> 进行交互。在这类情况下，我们想要以一种方式来管理不同的错误类型，使得...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/rust-by-example-cn-/error/multiple_error_types.html"}],["meta",{"property":"og:site_name","content":"rust-by-example-cn-"}],["meta",{"property":"og:title","content":"处理多种错误类型"}],["meta",{"property":"og:description","content":"处理多种错误类型 前面出现的例子都是很方便的情况；都是 Result 和其他 Result 交互，还有 Option 和其他 Option 交互。 有时 Option 需要和 Result 进行交互，或是 Result<T, Error1> 需要和 Result<T, Error2> 进行交互。在这类情况下，我们想要以一种方式来管理不同的错误类型，使得..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"处理多种错误类型\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/rust-by-example-cn-/\\"}]}"]]},"git":{},"readingTime":{"minutes":0.86,"words":257},"filePathRelative":"error/multiple_error_types.md","excerpt":"\\n<p>前面出现的例子都是很方便的情况；都是 <code>Result</code> 和其他 <code>Result</code> 交互，还有 <code>Option</code><br>\\n和其他 <code>Option</code> 交互。</p>\\n<p>有时 <code>Option</code> 需要和 <code>Result</code> 进行交互，或是 <code>Result&lt;T, Error1&gt;</code> 需要和<br>\\n<code>Result&lt;T, Error2&gt;</code> 进行交互。在这类情况下，我们想要以一种方式来管理不同的错误类型，使得它们可组合且易于交互。</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"error/multiple_error_types.md","value":{"title":"multiple_error_types","path":"error/multiple_error_types.md","outlink":[],"backlink":["SUMMARY.md"]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"SUMMARY.md","target":"error/multiple_error_types.md"}]}}}');export{p as comp,c as data};
