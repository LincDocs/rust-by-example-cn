import{_ as a,e,k as i,f as l,g as p,h as r,r as c,o as d,i as t}from"./app-CY03Lsxp.js";const v={};function u(m,n){const s=c("RouteLink");return d(),e("div",null,[n[1]||(n[1]=i('<h1 id="指针和引用" tabindex="-1"><a class="header-anchor" href="#指针和引用"><span>指针和引用</span></a></h1><p>对指针来说，解构（destructure）和解引用（dereference）要区分开，因为这两者的概念是不同的，和 <code>C</code> 那样的语言用法不一样。</p><ul><li>解引用使用 <code>*</code></li><li>解构使用 <code>&amp;</code>、<code>ref</code>、和 <code>ref mut</code></li></ul><div class="language-rust,editable line-numbers-mode" data-highlighter="shiki" data-ext="rust,editable" data-title="rust,editable" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>fn main() {</span></span>\n<span class="line"><span>    // 获得一个 `i32` 类型的引用。`&amp;` 表示取引用。</span></span>\n<span class="line"><span>    let reference = &amp;4;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    match reference {</span></span>\n<span class="line"><span>        // 如果用 `&amp;val` 这个模式去匹配 `reference`，就相当于做这样的比较：</span></span>\n<span class="line"><span>        // `&amp;i32`（译注：即 `reference` 的类型）</span></span>\n<span class="line"><span>        // `&amp;val`（译注：即用于匹配的模式）</span></span>\n<span class="line"><span>        // ^ 我们看到，如果去掉匹配的 `&amp;`，`i32` 应当赋给 `val`。</span></span>\n<span class="line"><span>        // 译注：因此可用 `val` 表示被 `reference` 引用的值 4。</span></span>\n<span class="line"><span>        &amp;val =&gt; println!(&quot;Got a value via destructuring: {:?}&quot;, val),</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    // 如果不想用 `&amp;`，需要在匹配前解引用。</span></span>\n<span class="line"><span>    match *reference {</span></span>\n<span class="line"><span>        val =&gt; println!(&quot;Got a value via dereferencing: {:?}&quot;, val),</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    // 如果一开始就不用引用，会怎样？ `reference` 是一个 `&amp;` 类型，因为赋值语句</span></span>\n<span class="line"><span>    // 的右边已经是一个引用。但下面这个不是引用，因为右边不是。</span></span>\n<span class="line"><span>    let _not_a_reference = 3;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    // Rust 对这种情况提供了 `ref`。它更改了赋值行为，从而可以对具体值创建引用。</span></span>\n<span class="line"><span>    // 下面这行将得到一个引用。</span></span>\n<span class="line"><span>    let ref _is_a_reference = 3;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    // 相应地，定义两个非引用的变量，通过 `ref` 和 `ref mut` 仍可取得其引用。</span></span>\n<span class="line"><span>    let value = 5;</span></span>\n<span class="line"><span>    let mut mut_value = 6;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    // 使用 `ref` 关键字来创建引用。</span></span>\n<span class="line"><span>    // 译注：下面的 r 是 `&amp;i32` 类型，它像 `i32` 一样可以直接打印，因此用法上</span></span>\n<span class="line"><span>    // 似乎看不出什么区别。但读者可以把 `println!` 中的 `r` 改成 `*r`，仍然能</span></span>\n<span class="line"><span>    // 正常运行。前面例子中的 `println!` 里就不能是 `*val`，因为不能对整数解</span></span>\n<span class="line"><span>    // 引用。</span></span>\n<span class="line"><span>    match value {</span></span>\n<span class="line"><span>        ref r =&gt; println!(&quot;Got a reference to a value: {:?}&quot;, r),</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    // 类似地使用 `ref mut`。</span></span>\n<span class="line"><span>    match mut_value {</span></span>\n<span class="line"><span>        ref mut m =&gt; {</span></span>\n<span class="line"><span>            // 已经获得了 `mut_value` 的引用，先要解引用，才能改变它的值。</span></span>\n<span class="line"><span>            *m += 10;</span></span>\n<span class="line"><span>            println!(&quot;We added 10. `mut_value`: {:?}&quot;, m);</span></span>\n<span class="line"><span>        },</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="参见" tabindex="-1"><a class="header-anchor" href="#参见"><span>参见：</span></a></h3>',5)),l("p",null,[p(s,{to:"/scope/borrow/ref.html"},{default:r(()=>n[0]||(n[0]=[t("ref 模式")])),_:1})])])}const b=a(v,[["render",u],["__file","destructure_pointers.html.vue"]]),f=JSON.parse('{"path":"/flow_control/match/destructuring/destructure_pointers.html","title":"指针和引用","lang":"zh-CN","frontmatter":{"description":"指针和引用 对指针来说，解构（destructure）和解引用（dereference）要区分开，因为这两者的概念是不同的，和 C 那样的语言用法不一样。 解引用使用 * 解构使用 &、ref、和 ref mut 参见：","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/rust-by-example-cn/flow_control/match/destructuring/destructure_pointers.html"}],["meta",{"property":"og:site_name","content":"rust-by-example-cn"}],["meta",{"property":"og:title","content":"指针和引用"}],["meta",{"property":"og:description","content":"指针和引用 对指针来说，解构（destructure）和解引用（dereference）要区分开，因为这两者的概念是不同的，和 C 那样的语言用法不一样。 解引用使用 * 解构使用 &、ref、和 ref mut 参见："}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"指针和引用\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/rust-by-example-cn/\\"}]}"]]},"git":{},"readingTime":{"minutes":1.62,"words":487},"filePathRelative":"flow_control/match/destructuring/destructure_pointers.md","excerpt":"\\n<p>对指针来说，解构（destructure）和解引用（dereference）要区分开，因为这两者的概念是不同的，和 <code>C</code> 那样的语言用法不一样。</p>\\n<ul>\\n<li>解引用使用 <code>*</code></li>\\n<li>解构使用 <code>&amp;</code>、<code>ref</code>、和 <code>ref mut</code></li>\\n</ul>\\n<div class=\\"language-rust,editable line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"rust,editable\\" data-title=\\"rust,editable\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>fn main() {</span></span>\\n<span class=\\"line\\"><span>    // 获得一个 `i32` 类型的引用。`&amp;` 表示取引用。</span></span>\\n<span class=\\"line\\"><span>    let reference = &amp;4;</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    match reference {</span></span>\\n<span class=\\"line\\"><span>        // 如果用 `&amp;val` 这个模式去匹配 `reference`，就相当于做这样的比较：</span></span>\\n<span class=\\"line\\"><span>        // `&amp;i32`（译注：即 `reference` 的类型）</span></span>\\n<span class=\\"line\\"><span>        // `&amp;val`（译注：即用于匹配的模式）</span></span>\\n<span class=\\"line\\"><span>        // ^ 我们看到，如果去掉匹配的 `&amp;`，`i32` 应当赋给 `val`。</span></span>\\n<span class=\\"line\\"><span>        // 译注：因此可用 `val` 表示被 `reference` 引用的值 4。</span></span>\\n<span class=\\"line\\"><span>        &amp;val =&gt; println!(\\"Got a value via destructuring: {:?}\\", val),</span></span>\\n<span class=\\"line\\"><span>    }</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    // 如果不想用 `&amp;`，需要在匹配前解引用。</span></span>\\n<span class=\\"line\\"><span>    match *reference {</span></span>\\n<span class=\\"line\\"><span>        val =&gt; println!(\\"Got a value via dereferencing: {:?}\\", val),</span></span>\\n<span class=\\"line\\"><span>    }</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    // 如果一开始就不用引用，会怎样？ `reference` 是一个 `&amp;` 类型，因为赋值语句</span></span>\\n<span class=\\"line\\"><span>    // 的右边已经是一个引用。但下面这个不是引用，因为右边不是。</span></span>\\n<span class=\\"line\\"><span>    let _not_a_reference = 3;</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    // Rust 对这种情况提供了 `ref`。它更改了赋值行为，从而可以对具体值创建引用。</span></span>\\n<span class=\\"line\\"><span>    // 下面这行将得到一个引用。</span></span>\\n<span class=\\"line\\"><span>    let ref _is_a_reference = 3;</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    // 相应地，定义两个非引用的变量，通过 `ref` 和 `ref mut` 仍可取得其引用。</span></span>\\n<span class=\\"line\\"><span>    let value = 5;</span></span>\\n<span class=\\"line\\"><span>    let mut mut_value = 6;</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    // 使用 `ref` 关键字来创建引用。</span></span>\\n<span class=\\"line\\"><span>    // 译注：下面的 r 是 `&amp;i32` 类型，它像 `i32` 一样可以直接打印，因此用法上</span></span>\\n<span class=\\"line\\"><span>    // 似乎看不出什么区别。但读者可以把 `println!` 中的 `r` 改成 `*r`，仍然能</span></span>\\n<span class=\\"line\\"><span>    // 正常运行。前面例子中的 `println!` 里就不能是 `*val`，因为不能对整数解</span></span>\\n<span class=\\"line\\"><span>    // 引用。</span></span>\\n<span class=\\"line\\"><span>    match value {</span></span>\\n<span class=\\"line\\"><span>        ref r =&gt; println!(\\"Got a reference to a value: {:?}\\", r),</span></span>\\n<span class=\\"line\\"><span>    }</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    // 类似地使用 `ref mut`。</span></span>\\n<span class=\\"line\\"><span>    match mut_value {</span></span>\\n<span class=\\"line\\"><span>        ref mut m =&gt; {</span></span>\\n<span class=\\"line\\"><span>            // 已经获得了 `mut_value` 的引用，先要解引用，才能改变它的值。</span></span>\\n<span class=\\"line\\"><span>            *m += 10;</span></span>\\n<span class=\\"line\\"><span>            println!(\\"We added 10. `mut_value`: {:?}\\", m);</span></span>\\n<span class=\\"line\\"><span>        },</span></span>\\n<span class=\\"line\\"><span>    }</span></span>\\n<span class=\\"line\\"><span>}</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true,"bioChainData":{"outlink":[{"title":"ref","link":"scope/borrow/ref.html"}],"backlink":[{"title":"SUMMARY","link":"SUMMARY.html"},{"title":"move","link":"scope/move.html"}],"localMap":{"nodes":[{"id":"flow_control/match/destructuring/destructure_pointers.md","value":{"title":"destructure_pointers","path":"flow_control/match/destructuring/destructure_pointers.md","outlink":["scope/borrow/ref.md"],"backlink":["SUMMARY.md","scope/move.md"]}},{"id":"scope/borrow/ref.md","value":{"title":"ref","path":"scope/borrow/ref.md","outlink":[],"backlink":[]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}},{"id":"scope/move.md","value":{"title":"move","path":"scope/move.md","outlink":[],"backlink":[]}}],"links":[{"source":"flow_control/match/destructuring/destructure_pointers.md","target":"scope/borrow/ref.md"},{"source":"SUMMARY.md","target":"flow_control/match/destructuring/destructure_pointers.md"},{"source":"scope/move.md","target":"flow_control/match/destructuring/destructure_pointers.md"}]}}}');export{b as comp,f as data};
