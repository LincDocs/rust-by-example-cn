import{_ as r,e as d,f as a,k as o,i as s,g as t,h as i,r as l,o as m}from"./app-CVSWwIkE.js";const c={},u={href:"https://rustwiki.org/zh-CN/std/marker/struct.PhantomData.html",target:"_blank",rel:"noopener noreferrer"};function v(h,n){const p=l("VPIcon"),e=l("RouteLink");return m(),d("div",null,[n[9]||(n[9]=a("h1",{id:"虚类型参数",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#虚类型参数"},[a("span",null,"虚类型参数")])],-1)),n[10]||(n[10]=a("p",null,"虚类型（phantom type）参数是一种在运行时不出现，而在（且仅在）编译时进行静态检查的类型参数。",-1)),n[11]||(n[11]=a("p",null,"可以用额外的泛型类型参数指定数据类型，该类型可以充当标记，也可以供编译时类型检查使用。这些额外的参数没有存储值，也没有运行时行为。",-1)),a("p",null,[n[2]||(n[2]=s("在下面例子中，我们使用 ")),a("a",u,[n[0]||(n[0]=s("std")),t(p,{icon:"marker"}),n[1]||(n[1]=s("PhantomData"))]),n[3]||(n[3]=s(" 作为虚类型参数的类型，创建包含不同数据类型的元组。"))]),n[12]||(n[12]=o(`<div class="language-rust,editable line-numbers-mode" data-highlighter="shiki" data-ext="rust,editable" data-title="rust,editable" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>use std::marker::PhantomData;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这个虚元组结构体对 \`A\` 是泛型的，并且带有隐藏参数 \`B\`。</span></span>
<span class="line"><span>#[derive(PartialEq)] // 允许这种类型进行相等测试（equality test）。</span></span>
<span class="line"><span>struct PhantomTuple&lt;A, B&gt;(A,PhantomData&lt;B&gt;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这个虚类型结构体对 \`A\` 是泛型的，并且带有隐藏参数 \`B\`。</span></span>
<span class="line"><span>#[derive(PartialEq)] // 允许这种类型进行相等测试。</span></span>
<span class="line"><span>struct PhantomStruct&lt;A, B&gt; { first: A, phantom: PhantomData&lt;B&gt; }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 注意：对于泛型 \`A\` 会分配存储空间，但 \`B\` 不会。</span></span>
<span class="line"><span>//       因此，\`B\` 不能参与运算。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>fn main() {</span></span>
<span class="line"><span>    // 这里的 \`f32\` 和 \`f64\` 是隐藏参数。</span></span>
<span class="line"><span>    // 被指定为 \`&lt;char, f32&gt;\` 的 \`PhantomTuple\` 类型。</span></span>
<span class="line"><span>    let _tuple1: PhantomTuple&lt;char, f32&gt; = PhantomTuple(&#39;Q&#39;, PhantomData);</span></span>
<span class="line"><span>    // 被指定为 \`&lt;char, f64&gt;\` \`PhantomTuple\` 类型。</span></span>
<span class="line"><span>    let _tuple2: PhantomTuple&lt;char, f64&gt; = PhantomTuple(&#39;Q&#39;, PhantomData);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 被指定为 \`&lt;char, f32&gt;\` 的类型。</span></span>
<span class="line"><span>    let _struct1: PhantomStruct&lt;char, f32&gt; = PhantomStruct {</span></span>
<span class="line"><span>        first: &#39;Q&#39;,</span></span>
<span class="line"><span>        phantom: PhantomData,</span></span>
<span class="line"><span>    };</span></span>
<span class="line"><span>    // 被指定为 \`&lt;char, f64&gt;\` 的类型。</span></span>
<span class="line"><span>    let _struct2: PhantomStruct&lt;char, f64&gt; = PhantomStruct {</span></span>
<span class="line"><span>        first: &#39;Q&#39;,</span></span>
<span class="line"><span>        phantom: PhantomData,</span></span>
<span class="line"><span>    };</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    // 编译期错误！类型不匹配，所以这些值不能够比较：</span></span>
<span class="line"><span>    //println!(&quot;_tuple1 == _tuple2 yields: {}&quot;,</span></span>
<span class="line"><span>    //          _tuple1 == _tuple2);</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    // 编译期错误！类型不匹配，所以这些值不能够比较：</span></span>
<span class="line"><span>    //println!(&quot;_struct1 == _struct2 yields: {}&quot;,</span></span>
<span class="line"><span>    //          _struct1 == _struct2);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="参见" tabindex="-1"><a class="header-anchor" href="#参见"><span>参见：</span></a></h3>`,2)),a("p",null,[t(e,{to:"/trait/derive.html"},{default:i(()=>n[4]||(n[4]=[s("Derive")])),_:1}),n[7]||(n[7]=s(", ")),t(e,{to:"/custom_types/structs.html"},{default:i(()=>n[5]||(n[5]=[s("结构体")])),_:1}),n[8]||(n[8]=s(", 和 ")),t(e,{to:"/custom_types/structs.html"},{default:i(()=>n[6]||(n[6]=[s("元组结构体")])),_:1})])])}const g=r(c,[["render",v],["__file","phantom.html.vue"]]),k=JSON.parse('{"path":"/generics/phantom.html","title":"虚类型参数","lang":"zh-CN","frontmatter":{"description":"虚类型参数 虚类型（phantom type）参数是一种在运行时不出现，而在（且仅在）编译时进行静态检查的类型参数。 可以用额外的泛型类型参数指定数据类型，该类型可以充当标记，也可以供编译时类型检查使用。这些额外的参数没有存储值，也没有运行时行为。 在下面例子中，我们使用 std 作为虚类型参数的类型，创建包含不同数据类型的元组。 参见： , , 和","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/rust-by-example-cn-/generics/phantom.html"}],["meta",{"property":"og:site_name","content":"rust-by-example-cn-"}],["meta",{"property":"og:title","content":"虚类型参数"}],["meta",{"property":"og:description","content":"虚类型参数 虚类型（phantom type）参数是一种在运行时不出现，而在（且仅在）编译时进行静态检查的类型参数。 可以用额外的泛型类型参数指定数据类型，该类型可以充当标记，也可以供编译时类型检查使用。这些额外的参数没有存储值，也没有运行时行为。 在下面例子中，我们使用 std 作为虚类型参数的类型，创建包含不同数据类型的元组。 参见： , , 和"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"虚类型参数\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/rust-by-example-cn-/\\"}]}"]]},"git":{},"readingTime":{"minutes":1.47,"words":441},"filePathRelative":"generics/phantom.md","excerpt":"\\n<p>虚类型（phantom type）参数是一种在运行时不出现，而在（且仅在）编译时进行静态检查的类型参数。</p>\\n<p>可以用额外的泛型类型参数指定数据类型，该类型可以充当标记，也可以供编译时类型检查使用。这些额外的参数没有存储值，也没有运行时行为。</p>\\n<p>在下面例子中，我们使用 <a href=\\"https://rustwiki.org/zh-CN/std/marker/struct.PhantomData.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">std</a> 作为虚类型参数的类型，创建包含不同数据类型的元组。</p>","autoDesc":true,"bioChainData":{"outlink":[{"title":"derive","link":"trait/derive.html"},{"title":"structs","link":"custom_types/structs.html"}],"backlink":[{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"generics/phantom.md","value":{"title":"phantom","path":"generics/phantom.md","outlink":["trait/derive.md","custom_types/structs.md"],"backlink":["SUMMARY.md"]}},{"id":"trait/derive.md","value":{"title":"derive","path":"trait/derive.md","outlink":[],"backlink":[]}},{"id":"custom_types/structs.md","value":{"title":"structs","path":"custom_types/structs.md","outlink":[],"backlink":[]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"generics/phantom.md","target":"trait/derive.md"},{"source":"generics/phantom.md","target":"custom_types/structs.md"},{"source":"SUMMARY.md","target":"generics/phantom.md"}]}}}');export{g as comp,k as data};
