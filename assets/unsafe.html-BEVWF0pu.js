import{_ as i,e as l,f as n,k as t,i as e,g as p,h as r,r as d,o}from"./app-CVSWwIkE.js";const c={};function u(m,s){const a=d("RouteLink");return o(),l("div",null,[s[6]||(s[6]=n("h1",{id:"不安全操作",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#不安全操作"},[n("span",null,"不安全操作")])],-1)),s[7]||(s[7]=n("p",null,[e("在本章一开始，我们借用"),n("a",{href:"unsafe"},"官方文档"),e("的一句话，“在整个代码库（code base，指构建一个软件系统所使用的全部代码）中，要尽可能减少不安全代码的量”。记住这句话，接着我们进入学习！在 Rust 中，不安全代码块用于避开编译器的保护策略；具体地说，不安全代码块主要用于四件事情：")],-1)),n("ul",null,[s[3]||(s[3]=n("li",null,"解引用裸指针",-1)),n("li",null,[s[1]||(s[1]=e("通过 FFI 调用函数（这已经在")),p(a,{to:"/std_misc/ffi.html"},{default:r(()=>s[0]||(s[0]=[e("之前的章节")])),_:1}),s[2]||(s[2]=e("介绍过了）"))]),s[4]||(s[4]=n("li",null,"调用不安全的函数",-1)),s[5]||(s[5]=n("li",null,"内联汇编（inline assembly）",-1))]),s[8]||(s[8]=t(`<h3 id="原始指针" tabindex="-1"><a class="header-anchor" href="#原始指针"><span>原始指针</span></a></h3><p>原始指针（raw pointer，裸指针）<code>*</code> 和引用 <code>&amp;T</code> 有类似的功能，但引用总是安全的，因为借用检查器保证了它指向一个有效的数据。解引用一个裸指针只能通过不安全代码块执行。</p><div class="language-rust,editable line-numbers-mode" data-highlighter="shiki" data-ext="rust,editable" data-title="rust,editable" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>fn main() {</span></span>
<span class="line"><span>    let raw_p: *const u32 = &amp;10;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    unsafe {</span></span>
<span class="line"><span>        assert!(*raw_p == 10);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="调用不安全函数" tabindex="-1"><a class="header-anchor" href="#调用不安全函数"><span>调用不安全函数</span></a></h3><p>一些函数可以声明为不安全的（<code>unsafe</code>），这意味着在使用它时保证正确性不再是编译器的责任，而是程序员的。一个例子就是 <a href="https://rustwiki.org/zh-CN/std/slice/fn.from_raw_parts.html" target="_blank" rel="noopener noreferrer"><code>std::slice::from_raw_parts</code></a>，向它传入指向第一个元素的指针和长度参数，它会创建一个切片。</p><div class="language-rust,editable line-numbers-mode" data-highlighter="shiki" data-ext="rust,editable" data-title="rust,editable" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>use std::slice;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>fn main() {</span></span>
<span class="line"><span>    let some_vector = vec![1, 2, 3, 4];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    let pointer = some_vector.as_ptr();</span></span>
<span class="line"><span>    let length = some_vector.len();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    unsafe {</span></span>
<span class="line"><span>        let my_slice: &amp;[u32] = slice::from_raw_parts(pointer, length);</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        assert_eq!(some_vector.as_slice(), my_slice);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>slice::from_raw_parts</code> 假设传入的指针指向有效的内存，且被指向的内存具有正确的数据类型，我们<strong>必须</strong>满足这一假设，否则程序的行为是未定义的（undefined），于是我们就不能预测会发生些什么了。</p>`,7))])}const v=i(c,[["render",u],["__file","unsafe.html.vue"]]),h=JSON.parse('{"path":"/unsafe.html","title":"不安全操作","lang":"zh-CN","frontmatter":{"description":"不安全操作 在本章一开始，我们借用官方文档的一句话，“在整个代码库（code base，指构建一个软件系统所使用的全部代码）中，要尽可能减少不安全代码的量”。记住这句话，接着我们进入学习！在 Rust 中，不安全代码块用于避开编译器的保护策略；具体地说，不安全代码块主要用于四件事情： 解引用裸指针 通过 FFI 调用函数（这已经在介绍过了） 调用不安全...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/rust-by-example-cn-/unsafe.html"}],["meta",{"property":"og:site_name","content":"rust-by-example-cn-"}],["meta",{"property":"og:title","content":"不安全操作"}],["meta",{"property":"og:description","content":"不安全操作 在本章一开始，我们借用官方文档的一句话，“在整个代码库（code base，指构建一个软件系统所使用的全部代码）中，要尽可能减少不安全代码的量”。记住这句话，接着我们进入学习！在 Rust 中，不安全代码块用于避开编译器的保护策略；具体地说，不安全代码块主要用于四件事情： 解引用裸指针 通过 FFI 调用函数（这已经在介绍过了） 调用不安全..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"不安全操作\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/rust-by-example-cn-/\\"}]}"]]},"git":{},"readingTime":{"minutes":1.47,"words":441},"filePathRelative":"unsafe.md","excerpt":"\\n<p>在本章一开始，我们借用<a href=\\"unsafe\\">官方文档</a>的一句话，“在整个代码库（code base，指构建一个软件系统所使用的全部代码）中，要尽可能减少不安全代码的量”。记住这句话，接着我们进入学习！在 Rust 中，不安全代码块用于避开编译器的保护策略；具体地说，不安全代码块主要用于四件事情：</p>\\n<ul>\\n<li>解引用裸指针</li>\\n<li>通过 FFI 调用函数（这已经在<a href=\\"/rust-by-example-cn-/std_misc/ffi.html\\" target=\\"_blank\\">之前的章节</a>介绍过了）</li>\\n<li>调用不安全的函数</li>\\n<li>内联汇编（inline assembly）</li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"unsafe.md","value":{"title":"unsafe","path":"unsafe.md","outlink":[],"backlink":["SUMMARY.md"]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"SUMMARY.md","target":"unsafe.md"}]}}}');export{v as comp,h as data};
