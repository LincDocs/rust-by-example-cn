import{_ as s,e as n,k as a,o as i}from"./app-CY03Lsxp.js";const r={};function t(l,e){return i(),n("div",null,e[0]||(e[0]=[a(`<h1 id="的其他用法" tabindex="-1"><a class="header-anchor" href="#的其他用法"><span><code>?</code> 的其他用法</span></a></h1><p>注意在上一个例子中，我们调用 <code>parse</code> 后总是立即将错误从标准库的错误 <code>map</code>（映射）到装箱错误。</p><div class="language-rust,ignore line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore" data-title="rust,ignore" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>.and_then(|s| s.parse::&lt;i32&gt;()</span></span>
<span class="line"><span>    .map_err(|e| e.into())</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>因为这个操作很简单常见，如果有省略写法就好了。遗憾的是 <code>and_then</code> 不够灵活，所以实现不了这样的写法。不过，我们可以使用 <code>?</code> 来代替它。</p><p><code>?</code> 之前被解释为要么 <code>unwrap</code>，要么 <code>return Err(err)</code>，这只是在大多数情况下是正确的。<code>?</code> 实际上是指 <code>unwrap</code> 或 <code>return Err(From::from(err))</code>。由于 <code>From::from</code> 是不同类型之间的转换工具，也就是说，如果在错误可转换成返回类型地方使用 <code>?</code>，它将自动转换成返回类型。</p><p>我们在这里使用 <code>?</code> 重写之前的例子。重写后，只要为我们的错误类型实现 <code>From::from</code>，就可以不再使用 <code>map_err</code>。</p><div class="language-rust,editable line-numbers-mode" data-highlighter="shiki" data-ext="rust,editable" data-title="rust,editable" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>use std::error;</span></span>
<span class="line"><span>use std::fmt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 为 \`Box&lt;error::Error&gt;\` 取别名。</span></span>
<span class="line"><span>type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;dyn error::Error&gt;&gt;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#[derive(Debug)]</span></span>
<span class="line"><span>struct EmptyVec;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>impl fmt::Display for EmptyVec {</span></span>
<span class="line"><span>    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {</span></span>
<span class="line"><span>        write!(f, &quot;invalid first item to double&quot;)</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>impl error::Error for EmptyVec {}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这里的结构和之前一样，但是这次没有把所有的 \`Result\` 和 \`Option\` 串起来，</span></span>
<span class="line"><span>// 而是使用 \`?\` 立即得到内部值。</span></span>
<span class="line"><span>fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {</span></span>
<span class="line"><span>    let first = vec.first().ok_or(EmptyVec)?;</span></span>
<span class="line"><span>    let parsed = first.parse::&lt;i32&gt;()?;</span></span>
<span class="line"><span>    Ok(2 * parsed)</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>fn print(result: Result&lt;i32&gt;) {</span></span>
<span class="line"><span>    match result {</span></span>
<span class="line"><span>        Ok(n)  =&gt; println!(&quot;The first doubled is {}&quot;, n),</span></span>
<span class="line"><span>        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>fn main() {</span></span>
<span class="line"><span>    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];</span></span>
<span class="line"><span>    let empty = vec![];</span></span>
<span class="line"><span>    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    print(double_first(numbers));</span></span>
<span class="line"><span>    print(double_first(empty));</span></span>
<span class="line"><span>    print(double_first(strings));</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码已经相当清晰了。与原来的 <code>panic</code> 相比，除了返回类型是 <code>Result</code> 之外，它就像是把所有的 <code>unwrap</code> 调用都换成 <code>?</code> 一样。因此必须在顶层解构它们。</p><h3 id="参见" tabindex="-1"><a class="header-anchor" href="#参见"><span>参见：</span></a></h3><p><a href="https://rustwiki.org/zh-CN/std/convert/trait.From.html" target="_blank" rel="noopener noreferrer"><code>From::from</code></a> 和 <a href="https://rustwiki.org/zh-CN/reference/expressions/operator-expr.html#%E9%97%AE%E5%8F%B7%E6%93%8D%E4%BD%9C%E7%AC%A6" target="_blank" rel="noopener noreferrer"><code>?</code></a></p>`,10)]))}const d=s(r,[["render",t],["__file","reenter_question_mark.html.vue"]]),o=JSON.parse('{"path":"/error/multiple_error_types/reenter_question_mark.html","title":"? 的其他用法","lang":"zh-CN","frontmatter":{"description":"? 的其他用法 注意在上一个例子中，我们调用 parse 后总是立即将错误从标准库的错误 map（映射）到装箱错误。 因为这个操作很简单常见，如果有省略写法就好了。遗憾的是 and_then 不够灵活，所以实现不了这样的写法。不过，我们可以使用 ? 来代替它。 ? 之前被解释为要么 unwrap，要么 return Err(err)，这只是在大多数情况...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/rust-by-example-cn/error/multiple_error_types/reenter_question_mark.html"}],["meta",{"property":"og:site_name","content":"rust-by-example-cn"}],["meta",{"property":"og:title","content":"? 的其他用法"}],["meta",{"property":"og:description","content":"? 的其他用法 注意在上一个例子中，我们调用 parse 后总是立即将错误从标准库的错误 map（映射）到装箱错误。 因为这个操作很简单常见，如果有省略写法就好了。遗憾的是 and_then 不够灵活，所以实现不了这样的写法。不过，我们可以使用 ? 来代替它。 ? 之前被解释为要么 unwrap，要么 return Err(err)，这只是在大多数情况..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"? 的其他用法\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/rust-by-example-cn/\\"}]}"]]},"git":{},"readingTime":{"minutes":1.56,"words":468},"filePathRelative":"error/multiple_error_types/reenter_question_mark.md","excerpt":"\\n<p>注意在上一个例子中，我们调用 <code>parse</code> 后总是立即将错误从标准库的错误 <code>map</code>（映射）到装箱错误。</p>\\n<div class=\\"language-rust,ignore line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"rust,ignore\\" data-title=\\"rust,ignore\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>.and_then(|s| s.parse::&lt;i32&gt;()</span></span>\\n<span class=\\"line\\"><span>    .map_err(|e| e.into())</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"SUMMARY","link":"SUMMARY.html"},{"title":"enter_question_mark","link":"error/result/enter_question_mark.html"}],"localMap":{"nodes":[{"id":"error/multiple_error_types/reenter_question_mark.md","value":{"title":"reenter_question_mark","path":"error/multiple_error_types/reenter_question_mark.md","outlink":[],"backlink":["SUMMARY.md","error/result/enter_question_mark.md"]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}},{"id":"error/result/enter_question_mark.md","value":{"title":"enter_question_mark","path":"error/result/enter_question_mark.md","outlink":[],"backlink":[]}}],"links":[{"source":"SUMMARY.md","target":"error/multiple_error_types/reenter_question_mark.md"},{"source":"error/result/enter_question_mark.md","target":"error/multiple_error_types/reenter_question_mark.md"}]}}}');export{d as comp,o as data};
