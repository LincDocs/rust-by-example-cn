import{_ as i,e as a,k as e,f as l,g as p,h as t,r,o as d,i as o}from"./app-CVSWwIkE.js";const c={};function h(k,s){const n=r("RouteLink");return d(),a("div",null,[s[1]||(s[1]=e(`<h1 id="raii" tabindex="-1"><a class="header-anchor" href="#raii"><span>RAII</span></a></h1><p>Rust 的变量不只是在栈中保存数据：它们也<strong>占有</strong>资源，比如 <code>Box&lt;T&gt;</code> 占有堆（heap）中的内存。Rust 强制实行 <a href="https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization" target="_blank" rel="noopener noreferrer">RAII</a>（Resource Acquisition Is Initialization，资源获取即初始化），所以任何对象在离开作用域时，它的析构函数（destructor）就被调用，然后它占有的资源就被释放。</p><p>这种行为避免了<strong>资源泄漏</strong>（resource leak），所以你再也不用手动释放内存或者担心内存泄漏（memory leak）！下面是个快速入门示例：</p><div class="language-rust,editable line-numbers-mode" data-highlighter="shiki" data-ext="rust,editable" data-title="rust,editable" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// raii.rs</span></span>
<span class="line"><span>fn create_box() {</span></span>
<span class="line"><span>    // 在堆上分配一个整型数据</span></span>
<span class="line"><span>    let _box1 = Box::new(3i32);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // \`_box1\` 在这里被销毁，内存得到释放</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>fn main() {</span></span>
<span class="line"><span>    // 在堆上分配一个整型数据</span></span>
<span class="line"><span>    let _box2 = Box::new(5i32);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 嵌套作用域：</span></span>
<span class="line"><span>    {</span></span>
<span class="line"><span>        // 在堆上分配一个整型数据</span></span>
<span class="line"><span>        let _box3 = Box::new(4i32);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // \`_box3\` 在这里被销毁，内存得到释放</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一大堆 box（只是因为好玩）。</span></span>
<span class="line"><span>    // 完全不需要手动释放内存！</span></span>
<span class="line"><span>    for _ in 0u32..1_000 {</span></span>
<span class="line"><span>        create_box();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // \`_box2\` 在这里被销毁，内存得到释放</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然我们可以使用 <a href="https://valgrind.org/info/" target="_blank" rel="noopener noreferrer"><code>valgrind</code></a> 对内存错误进行仔细检查：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> rustc</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> raii.rs</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &amp;&amp; </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">valgrind</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ./raii</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">==26873==</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> Memcheck,</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> a</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> memory</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> error</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> detector</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">==26873==</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> Copyright</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (C) 2002-2013, and GNU GPL</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;d, by Julian Seward et al.</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">==26873== Using Valgrind-3.9.0 and LibVEX; rerun with -h for copyright info</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">==26873== Command: ./raii</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">==26873==</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">==26873==</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">==26873== HEAP SUMMARY:</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">==26873==     in use at exit: 0 bytes in 0 blocks</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">==26873==   total heap usage: 1,013 allocs, 1,013 frees, 8,696 bytes allocated</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">==26873==</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">==26873== All heap blocks were freed -- no leaks are possible</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">==26873==</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">==26873== For counts of detected and suppressed errors, rerun with: -v</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">==26873== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 2 from 2)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>完全没有泄漏！</p><h2 id="析构函数" tabindex="-1"><a class="header-anchor" href="#析构函数"><span>析构函数</span></a></h2><p>Rust 中的析构函数概念是通过 <a href="https://rustwiki.org/zh-CN/std/ops/trait.Drop.html" target="_blank" rel="noopener noreferrer"><code>Drop</code></a> trait 提供的。当资源离开作用域，就调用析构函数。你无需为每种类型都实现 <a href="https://rustwiki.org/zh-CN/std/ops/trait.Drop.html" target="_blank" rel="noopener noreferrer"><code>Drop</code></a> trait，只要为那些需要自己的析构函数逻辑的类型实现就可以了。</p><p>运行下列例子，看看 <a href="https://rustwiki.org/zh-CN/std/ops/trait.Drop.html" target="_blank" rel="noopener noreferrer"><code>Drop</code></a> trait 是怎样工作的。当 <code>main</code> 函数中的变量离开作用域，自定义的析构函数就会被调用：</p><div class="language-rust,editable line-numbers-mode" data-highlighter="shiki" data-ext="rust,editable" data-title="rust,editable" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>struct ToDrop;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>impl Drop for ToDrop {</span></span>
<span class="line"><span>    fn drop(&amp;mut self) {</span></span>
<span class="line"><span>        println!(&quot;ToDrop is being dropped&quot;);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>fn main() {</span></span>
<span class="line"><span>    let x = ToDrop;</span></span>
<span class="line"><span>    println!(&quot;Made a ToDrop!&quot;);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="参见" tabindex="-1"><a class="header-anchor" href="#参见"><span>参见：</span></a></h3>`,12)),l("p",null,[p(n,{to:"/std/box.html"},{default:t(()=>s[0]||(s[0]=[o("Box")])),_:1})])])}const v=i(c,[["render",h],["__file","raii.html.vue"]]),m=JSON.parse('{"path":"/scope/raii.html","title":"RAII","lang":"zh-CN","frontmatter":{"description":"RAII Rust 的变量不只是在栈中保存数据：它们也占有资源，比如 Box<T> 占有堆（heap）中的内存。Rust 强制实行 RAII（Resource Acquisition Is Initialization，资源获取即初始化），所以任何对象在离开作用域时，它的析构函数（destructor）就被调用，然后它占有的资源就被释放。 这种行为避免...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/rust-by-example-cn-/scope/raii.html"}],["meta",{"property":"og:site_name","content":"rust-by-example-cn-"}],["meta",{"property":"og:title","content":"RAII"}],["meta",{"property":"og:description","content":"RAII Rust 的变量不只是在栈中保存数据：它们也占有资源，比如 Box<T> 占有堆（heap）中的内存。Rust 强制实行 RAII（Resource Acquisition Is Initialization，资源获取即初始化），所以任何对象在离开作用域时，它的析构函数（destructor）就被调用，然后它占有的资源就被释放。 这种行为避免..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RAII\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/rust-by-example-cn-/\\"}]}"]]},"git":{},"readingTime":{"minutes":1.87,"words":561},"filePathRelative":"scope/raii.md","excerpt":"\\n<p>Rust 的变量不只是在栈中保存数据：它们也<strong>占有</strong>资源，比如 <code>Box&lt;T&gt;</code> 占有堆（heap）中的内存。Rust 强制实行 <a href=\\"https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">RAII</a>（Resource Acquisition Is Initialization，资源获取即初始化），所以任何对象在离开作用域时，它的析构函数（destructor）就被调用，然后它占有的资源就被释放。</p>","autoDesc":true,"bioChainData":{"outlink":[{"title":"box","link":"std/box.html"}],"backlink":[{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"scope/raii.md","value":{"title":"raii","path":"scope/raii.md","outlink":["std/box.md"],"backlink":["SUMMARY.md"]}},{"id":"std/box.md","value":{"title":"box","path":"std/box.md","outlink":[],"backlink":[]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"scope/raii.md","target":"std/box.md"},{"source":"SUMMARY.md","target":"scope/raii.md"}]}}}');export{v as comp,m as data};
